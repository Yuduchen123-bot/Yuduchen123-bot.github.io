<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java基础</title>
    <url>/posts/38943.html</url>
    <content><![CDATA[<h1 id="1-Java基础-面试"><a href="#1-Java基础-面试" class="headerlink" title="1.Java基础:(面试)"></a>1.Java基础:(面试)</h1><h2 id="1-1基本数据类型"><a href="#1-1基本数据类型" class="headerlink" title="1.1基本数据类型"></a>1.1基本数据类型</h2><p><img src="https://pic.imgdb.cn/item/672b3adcd29ded1a8cd66e83.png" alt="1"></p>
<p>注意:byte取值范围 -128 - 127</p>
<p><img src="https://pic.imgdb.cn/item/672b3b52d29ded1a8cd6df09.png" alt="2"></p>
<p>2.引用数据类型</p>
<p>除了基本数据类型其他全是引用数据类型</p>
<h2 id="1-2顶级学习网址"><a href="#1-2顶级学习网址" class="headerlink" title="1.2顶级学习网址"></a>1.2顶级学习网址</h2><p><a href="https://www.cnblogs.com/zhangzhixi/tag/SpringMVC/">https://www.cnblogs.com/zhangzhixi/tag/SpringMVC/</a></p>
<h1 id="2-java内存分配"><a href="#2-java内存分配" class="headerlink" title="2.java内存分配"></a>2.java内存分配</h1><p><img src="https://pic.imgdb.cn/item/672b3b6ad29ded1a8cd6f2c4.png" alt="4"></p>
<p>单例模式:JavaBean</p>
<h2 id="2-1成员变量和局部变量的区别"><a href="#2-1成员变量和局部变量的区别" class="headerlink" title="2.1成员变量和局部变量的区别"></a>2.1成员变量和局部变量的区别</h2><p><img src="https://pic.imgdb.cn/item/672b3b93d29ded1a8cd72391.png" alt="5"></p>
<h1 id="3-Java设计模式之工厂方法模式详解"><a href="#3-Java设计模式之工厂方法模式详解" class="headerlink" title="3.Java设计模式之工厂方法模式详解"></a>3.Java设计模式之工厂方法模式详解</h1><h2 id="3-1什么是工厂方法模式？-创建型"><a href="#3-1什么是工厂方法模式？-创建型" class="headerlink" title="3.1什么是工厂方法模式？(创建型)"></a>3.1什么是工厂方法模式？(创建型)</h2><p>  工厂方法模式是一种创建型设计模式，其主要目的是定义一个用于创建对象的接口，让子类决定实例化哪个类。工厂方法使一个类的实例化延迟到其子类。这种模式在创建对象的超类(父类)中有一个创建对象的接口，让子类决定将哪个类实例化。</p>
<p>  具体设计模式分为:创建型模式,结构型模式,行为型模式</p>
<h2 id="3-2工厂方法模式的优势"><a href="#3-2工厂方法模式的优势" class="headerlink" title="3.2工厂方法模式的优势"></a>3.2工厂方法模式的优势</h2><ul>
<li><strong>降低耦合性：</strong> 将产品的实例化过程与使用过程解耦，客户端不需要知道具体产品的类名，只需知道具体工厂即可。</li>
<li><strong>增加扩展性：</strong> 添加新的产品类时，只需要添加相应的具体产品类和对应的具体工厂类，无需修改已有代码。</li>
<li><strong>符合开闭原则：</strong> 对扩展开放，对修改关闭。</li>
</ul>
<h2 id="3-3简单工厂模式（静态工厂方法）"><a href="#3-3简单工厂模式（静态工厂方法）" class="headerlink" title="3.3简单工厂模式（静态工厂方法）"></a>3.3简单工厂模式（静态工厂方法）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface Product &#123;</span><br><span class="line">    void produce();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteProductA implements Product &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void produce() &#123;</span><br><span class="line">        System.out.println(&quot;生产产品A&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteProductB implements Product &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void produce() &#123;</span><br><span class="line">        System.out.println(&quot;生产产品B&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class SimpleFactory &#123;</span><br><span class="line">    public static Product createProduct(String type) &#123;</span><br><span class="line">        if (&quot;A&quot;.equals(type)) &#123;</span><br><span class="line">            return new ConcreteProductA();</span><br><span class="line">        &#125; else if (&quot;B&quot;.equals(type)) &#123;</span><br><span class="line">            return new ConcreteProductB();</span><br><span class="line">        &#125;</span><br><span class="line">        throw new IllegalArgumentException(&quot;Invalid product type&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-4工厂方法模式"><a href="#3-4工厂方法模式" class="headerlink" title="3.4工厂方法模式"></a>3.4工厂方法模式</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface Factory &#123;</span><br><span class="line">    Product createProduct();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteFactoryA implements Factory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Product createProduct() &#123;</span><br><span class="line">        return new ConcreteProductA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteFactoryB implements Factory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Product createProduct() &#123;</span><br><span class="line">        return new ConcreteProductB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="3-5工厂方法模式的实际应用技巧-灵活扩展产品族"><a href="#3-5工厂方法模式的实际应用技巧-灵活扩展产品族" class="headerlink" title="3.5工厂方法模式的实际应用技巧(灵活扩展产品族)"></a>3.5工厂方法模式的实际应用技巧(灵活扩展产品族)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface Factory &#123;</span><br><span class="line">    Product createProduct();</span><br><span class="line">    // 扩展新的产品族</span><br><span class="line">    Product createSpecialProduct();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteFactoryA implements Factory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Product createProduct() &#123;</span><br><span class="line">        return new ConcreteProductA();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Product createSpecialProduct() &#123;</span><br><span class="line">        return new SpecialProductA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteFactoryB implements Factory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Product createProduct() &#123;</span><br><span class="line">        return new ConcreteProductB();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Product createSpecialProduct() &#123;</span><br><span class="line">        return new SpecialProductB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="3-6使用抽象工厂模式"><a href="#3-6使用抽象工厂模式" class="headerlink" title="3.6使用抽象工厂模式"></a>3.6使用抽象工厂模式</h2><p>抽象工厂模式是工厂方法模式的一种变种，它在创建产品族时更加灵活，可以创建多个不同产品的产品族。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface AbstractFactory &#123;</span><br><span class="line">    Product createProduct();</span><br><span class="line">    SpecialProduct createSpecialProduct();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteFactoryA implements AbstractFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Product createProduct() &#123;</span><br><span class="line">        return new ConcreteProductA();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public SpecialProduct createSpecialProduct() &#123;</span><br><span class="line">        return new SpecialProductA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteFactoryB implements AbstractFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Product createProduct() &#123;</span><br><span class="line">        return new ConcreteProductB();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public SpecialProduct createSpecialProduct() &#123;</span><br><span class="line">        return new SpecialProductB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="3-7工厂方法模式的典型应用场景"><a href="#3-7工厂方法模式的典型应用场景" class="headerlink" title="3.7工厂方法模式的典型应用场景"></a>3.7工厂方法模式的典型应用场景</h2><h3 id="1-日志记录器"><a href="#1-日志记录器" class="headerlink" title="1.日志记录器"></a>1.日志记录器</h3><p>在日志记录器中，不同类型的日志记录器可以由不同的日志记录器工厂负责创建</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface LoggerFactory &#123;</span><br><span class="line">    Logger createLogger();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class FileLoggerFactory implements LoggerFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Logger createLogger() &#123;</span><br><span class="line">        return new FileLogger();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class DatabaseLoggerFactory implements LoggerFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Logger createLogger() &#123;</span><br><span class="line">        return new DatabaseLogger();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-数据库连接池"><a href="#2-数据库连接池" class="headerlink" title="2.数据库连接池"></a>2.数据库连接池</h3><p>在数据库连接池中，可以由不同的连接池工厂负责创建不同类型的数据库连接池</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface ConnectionPoolFactory &#123;</span><br><span class="line">    ConnectionPool createConnectionPool();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class OracleConnectionPoolFactory implements ConnectionPoolFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public ConnectionPool createConnectionPool() &#123;</span><br><span class="line">        return new OracleConnectionPool();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MySQLConnectionPoolFactory implements ConnectionPoolFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public ConnectionPool createConnectionPool() &#123;</span><br><span class="line">        return new MySQLConnectionPool();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-UI控件库"><a href="#3-UI控件库" class="headerlink" title="3.UI控件库"></a>3.UI控件库</h3><p>在UI控件库中，可以由不同的控件工厂负责创建不同类型的UI控件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public interface UIControlFactory &#123;</span><br><span class="line">    Button createButton();</span><br><span class="line">    TextBox createTextBox();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class WindowsUIControlFactory implements UIControlFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Button createButton() &#123;</span><br><span class="line">        return new WindowsButton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public TextBox createTextBox() &#123;</span><br><span class="line">        return new WindowsTextBox();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class LinuxUIControlFactory implements UIControlFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Button createButton() &#123;</span><br><span class="line">        return new LinuxButton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public TextBox createTextBox() &#123;</span><br><span class="line">        return new LinuxTextBox();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="4-Java设计模式详解—-单例模式"><a href="#4-Java设计模式详解—-单例模式" class="headerlink" title="4.Java设计模式详解—-单例模式"></a>4.Java设计模式详解—-单例模式</h1><p><img src="https://pic.imgdb.cn/item/672b3bb6d29ded1a8cd754c9.jpg" alt="3"></p>
<h2 id="4-1：什么是单例模式"><a href="#4-1：什么是单例模式" class="headerlink" title="4.1：什么是单例模式"></a>4.1：什么是单例模式</h2><p>保证一个类只有一个实例，并且提供一个访问该全局访问点</p>
<h2 id="4-2单例模式的优缺点"><a href="#4-2单例模式的优缺点" class="headerlink" title="4.2单例模式的优缺点"></a>4.2单例模式的优缺点</h2><p>优点:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 在单例模式中，活动的单例只有一个实例，对单例类的所有实例化得到的都是相同的一个实例。这样就防止其它对象对自己的实例化，确保所有的对象都访问一个实例</span><br><span class="line">2. 单例模式具有一定的伸缩性，类自己来控制实例化进程，类就在改变实例化进程上有相应的伸缩性。</span><br><span class="line">3. 提供了对唯一实例的受控访问。</span><br><span class="line">4. 由于在系统内存中只存在一个对象，因此可以节约系统资源，当需要频繁创建和销毁的对象时单例模式无疑可以提高系统的性能。</span><br><span class="line">5. 允许可变数目的实例。</span><br><span class="line">6. 避免对共享资源的多重占用。</span><br></pre></td></tr></table></figure>

<p>缺点:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 不适用于变化的对象，如果同一类型的对象总是要在不同的用例场景发生变化，单例就会引起数据的错误，不能保存彼此的状态。</span><br><span class="line">2. 由于单利模式中没有抽象层，因此单例类的扩展有很大的困难。</span><br><span class="line">3. 单例类的职责过重，在一定程度上违背了 “ 单一职责原则 ” 。</span><br><span class="line">4. 滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；如果实例化的对象长时间不被利用，系统会认为是垃圾而被回收，这将导致对象状态的丢失。</span><br></pre></td></tr></table></figure>

<h2 id="4-3单例模式的应用场景"><a href="#4-3单例模式的应用场景" class="headerlink" title="4.3单例模式的应用场景"></a>4.3单例模式的应用场景</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 网站的计数器，一般也是采用单例模式实现，否则难以同步。</span><br><span class="line">2. 应用程序的日志应用，一般都是单例模式实现，只有一个实例去操作才好，否则内容不好追加显示。</span><br><span class="line">3. 多线程的线程池的设计一般也是采用单例模式，因为线程池要方便对池中的线程进行控制</span><br><span class="line">4. Windows 的（任务管理器）就是很典型的单例模式，他不能打开俩个</span><br><span class="line">5. windows 的（回收站）也是典型的单例应用。在整个系统运行过程中，回收站只维护一个实例。</span><br></pre></td></tr></table></figure>

<h2 id="4-4单例模式的分类"><a href="#4-4单例模式的分类" class="headerlink" title="4.4单例模式的分类"></a>4.4单例模式的分类</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 饿汉式: 类初始化时 , 会立即加载该对象，线程天生安全 , 调用效率高。</span><br><span class="line">2. 懒汉式 : 类初始化时 , 不会初始化该对象 , 真正需要使用的时候才会创建该对象 , 具备懒加载功能。</span><br><span class="line">3. 静态内部方式 : 结合了懒汉式和饿汉式各自的优点，真正需要对象的时候才会加载，加载类是线程安全的。</span><br><span class="line">4. 枚举单例 : 使用枚举实现单例模式 优点 : 实现简单、调用效率高，枚举本身就是单例，由 jvm 从根本上提供保障! 避免通过反射和反序列化的漏洞， 缺点没有延迟加载。</span><br><span class="line">5. 双重检测锁方式 ( 因为 JVM 本质重排序的原因，可能会初始化多次，不推荐使用 )</span><br></pre></td></tr></table></figure>

<h3 id="4-4-1饿汉式"><a href="#4-4-1饿汉式" class="headerlink" title="4.4.1饿汉式"></a>4.4.1饿汉式</h3><p>饿汉式 : 类初始化时 , 会立即加载该对象，线程天生安全 , 调用效率高。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @author: dlwlrma</span><br><span class="line"> * @data 2024年10月26日 19:50</span><br><span class="line"> * @Description: TODO:单例模式之饿汉式</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">public class Demo1 &#123;</span><br><span class="line">    //饿汉式，类初始化时，会立即创建对象，调用效率高，但可能会造成内存的浪费</span><br><span class="line">    private static Demo1 demo1=new Demo1();</span><br><span class="line">    private Demo1()&#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    public static Demo1 getInstance()&#123;</span><br><span class="line">        return demo1;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Demo1 demo11=Demo1.getInstance();</span><br><span class="line">        Demo1 demo12=Demo1.getInstance();</span><br><span class="line">        System.out.println(demo11==demo12);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-4-2懒汉式"><a href="#4-4-2懒汉式" class="headerlink" title="4.4.2懒汉式"></a>4.4.2懒汉式</h3><p>懒汉式 : 类初始化时 , 不会初始化该对象 , 真正需要使用的时候才会创建该对象 , 具备懒加载功能。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @author: dlwlrma</span><br><span class="line"> * @data 2024年10月26日 19:52</span><br><span class="line"> * @Description: TODO:单例模式之懒汉式</span><br><span class="line"> */</span><br><span class="line">//懒汉式</span><br><span class="line">public class Demo2 &#123;</span><br><span class="line">    //类初始化时，不会初始化该对象，真正需要使用的时候才会创建该对象。</span><br><span class="line">    private static Demo2 demo2;</span><br><span class="line">    private Demo2() &#123;</span><br><span class="line">        System.out.println(&quot;私有Demo2构造参数初始化&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public synchronized static Demo2 getInstance() &#123;</span><br><span class="line">        if (demo2 == null) &#123;</span><br><span class="line">            demo2 = new Demo2();</span><br><span class="line">        &#125;</span><br><span class="line">        return demo2;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Demo2 s1 = Demo2.getInstance();</span><br><span class="line">        Demo2 s2 = Demo2.getInstance();</span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-4-3静态内部式"><a href="#4-4-3静态内部式" class="headerlink" title="4.4.3静态内部式"></a>4.4.3静态内部式</h3><p>静态内部方式 : 结合了懒汉式和饿汉式各自的优点，真正需要对象的时候才会加载，加载类是线程安全的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 静态内部类方式</span><br><span class="line"> * @author dlwlrma</span><br><span class="line"> * @date 2024/10/26 19:56</span><br><span class="line"> * @return null</span><br><span class="line"> */</span><br><span class="line">public class Demo3 &#123;</span><br><span class="line">    private Demo3() &#123;</span><br><span class="line">        System.out.println(&quot;私有Demo3构造参数初始化&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static class SingletonClassInstance &#123;</span><br><span class="line">        private static final Demo3 DEMO_3 = new Demo3();</span><br><span class="line">    &#125;</span><br><span class="line">    // 方法没有同步</span><br><span class="line">    public static Demo3 getInstance() &#123;</span><br><span class="line">        return SingletonClassInstance.DEMO_3;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Demo3 s1 = Demo3.getInstance();</span><br><span class="line">        Demo3 s2 = Demo3.getInstance();</span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>特别注意的是:private static final Demo3 DEMO_3 &#x3D; new Demo3();</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">不可变性：DEMO_3 引用被声明为 final，这意味着一旦 DEMO_3 被初始化指向了某个 Demo3 类型的对象之后，就不能再改变指向其他对象了。这有助于确保对象引用的不可变性，对于多线程环境下的编程特别有用，因为不可变对象是线程安全的。</span><br><span class="line"></span><br><span class="line">静态上下文：由于 DEMO_3 同时被声明为 static，这意味着它是属于类级别的，而不是实例级别的。所有该类的实例将共享同一个 DEMO_3 对象。此外，当类首次被加载时，静态成员就会被初始化。</span><br><span class="line"></span><br><span class="line">私有访问控制：private 关键字限制了对 DEMO_3 的访问权限，只有定义它的类中的代码能够直接访问它。这有助于封装数据，保护对象不受外部干扰。</span><br></pre></td></tr></table></figure>

<h3 id="4-4-4双重检测锁式"><a href="#4-4-4双重检测锁式" class="headerlink" title="4.4.4双重检测锁式"></a>4.4.4双重检测锁式</h3><p>双重检测锁方式 ( 因为 JVM 本质重排序的原因，可能会初始化多次，不推荐使用 )</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @author: dlwlrma</span><br><span class="line"> * @data 2024年10月26日 19:59</span><br><span class="line"> * @Description: TODO:双重检测锁方式</span><br><span class="line"> */</span><br><span class="line">//双重检测锁方式</span><br><span class="line">public class Demo5 &#123;</span><br><span class="line">    private static Demo5 demo5;</span><br><span class="line">    private Demo5() &#123;</span><br><span class="line">        System.out.println(&quot;私有Demo4构造参数初始化&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static Demo5 getInstance() &#123;</span><br><span class="line">        if (demo5 == null) &#123;</span><br><span class="line">            synchronized (Demo5.class) &#123;</span><br><span class="line">                if (demo5 == null) &#123;</span><br><span class="line">                    demo5 = new Demo5();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return demo5;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Demo5 s1 = Demo5.getInstance();</span><br><span class="line">        Demo5 s2 = Demo5.getInstance();</span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-4-5枚举单例式"><a href="#4-4-5枚举单例式" class="headerlink" title="4.4.5枚举单例式"></a>4.4.5枚举单例式</h3><p>枚举单例 : 使用枚举实现单例模式 优点 : 实现简单、调用效率高，枚举本身就是单例，由 jvm 从根本上提供保障! 避免通过反射和反序列化的漏洞， 缺点没有延迟加载。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @author: dlwlrma</span><br><span class="line"> * @data 2024年10月26日 19:57</span><br><span class="line"> * @Description: TODO: 使用枚举实现单例模式 优点:实现简单、枚举本身就是单例，由jvm从根本上提供 </span><br><span class="line">                       保障!避免通过反射和反序列化的漏洞 缺点没有延迟加载</span><br><span class="line"> */</span><br><span class="line">public class Demo4 &#123;</span><br><span class="line">    public static Demo4 getInstance() &#123;</span><br><span class="line">        return Demo.INSTANCE.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Demo4 s1 = Demo4.getInstance();</span><br><span class="line">        Demo4 s2 = Demo4.getInstance();</span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">    &#125;</span><br><span class="line">    //定义枚举</span><br><span class="line">    private static enum Demo &#123;</span><br><span class="line">        INSTANCE;</span><br><span class="line">        // 枚举元素为单例</span><br><span class="line">        private Demo4 demo4;</span><br><span class="line">        private Demo() &#123;</span><br><span class="line">            System.out.println(&quot;枚举Demo私有构造参数&quot;);</span><br><span class="line">            demo4 = new Demo4();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        public Demo4 getInstance() &#123;</span><br><span class="line">            return demo4;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-集合"><a href="#5-集合" class="headerlink" title="5.集合"></a>5.集合</h1><h2 id="5-1ArrayList集合"><a href="#5-1ArrayList集合" class="headerlink" title="5.1ArrayList集合"></a>5.1ArrayList集合</h2><h3 id="5-1-1ArrayList集合成员方法"><a href="#5-1-1ArrayList集合成员方法" class="headerlink" title="5.1.1ArrayList集合成员方法"></a>5.1.1ArrayList集合成员方法</h3><p><img src="https://pic.imgdb.cn/item/672b3bdcd29ded1a8cd77d35.png" alt="6"></p>
<h3 id="5-1-2Arrays-asList集合类的集合转换方法的坑！！！"><a href="#5-1-2Arrays-asList集合类的集合转换方法的坑！！！" class="headerlink" title="5.1.2Arrays.asList集合类的集合转换方法的坑！！！"></a>5.1.2Arrays.asList集合类的集合转换方法的坑！！！</h3><p>不支持的操作异常：UnsupportedOperationException)</p>
<p><a href="https://www.cnblogs.com/zhangzhixi/p/14766636.html">https://www.cnblogs.com/zhangzhixi/p/14766636.html</a></p>
<h2 id="5-2顶级父类集合collection"><a href="#5-2顶级父类集合collection" class="headerlink" title="5.2顶级父类集合collection"></a>5.2顶级父类集合collection</h2><p>集合主要分为两类:</p>
<ul>
<li>单列集合</li>
<li>双列集合</li>
</ul>
<h3 id="5-2-1单列体系结构"><a href="#5-2-1单列体系结构" class="headerlink" title="5.2.1单列体系结构"></a>5.2.1单列体系结构</h3><p><img src="https://pic.imgdb.cn/item/672b3bf5d29ded1a8cd791cb.png" alt="10"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list系列集合：添加的元素是有序、可重复、有索引的。</span><br><span class="line">有序：指的是存和取的顺序是一致的</span><br><span class="line">set系列集合：添加的元素是无序、不可重复、无索引的</span><br></pre></td></tr></table></figure>

<h3 id="5-2-2Collection"><a href="#5-2-2Collection" class="headerlink" title="5.2.2Collection"></a>5.2.2Collection</h3><ul>
<li>collection：collection是一个接口，是单列集合的最顶层接口，它的功能是全部单列集合都可以继承使用。</li>
<li>collection：常见的方法：</li>
</ul>
<p><img src="https://pic.imgdb.cn/item/672b3bf5d29ded1a8cd791da.png" alt="11"></p>
<h2 id="5-3单列集合的遍历方式"><a href="#5-3单列集合的遍历方式" class="headerlink" title="5.3单列集合的遍历方式"></a>5.3单列集合的遍历方式</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Collection集合主要有三种遍历方式：迭代器遍历、增强for遍历、Lambda表达式遍历。</span><br><span class="line">以上三种遍历方式是单列集合通用的遍历方式</span><br></pre></td></tr></table></figure>

<h3 id="5-3-1迭代器遍历"><a href="#5-3-1迭代器遍历" class="headerlink" title="5.3.1迭代器遍历"></a>5.3.1迭代器遍历</h3><p>​    用迭代器进行遍历，不依赖索引，它是集合专用的遍历方式，在 Java 中其类名写作 Iterator。<br>​    使用 Collection 集合获取迭代器，默认指向当前集合的 0 索引处。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p> 然后利用集合中的两个方法来获取和遍历集合中的元素。</p>
<table>
<thead>
<tr>
<th>常用方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>boolean hasNext()</td>
<td>判断当前位置是否有元素，有元素返回true，没有元素返回false</td>
</tr>
<tr>
<td>E next()</td>
<td>获取当前位置的元素，并将迭代器对象移向下一个位置</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package Colletcion;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Collection;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line"></span><br><span class="line">public class Iterators &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Collection&lt;String&gt; coll = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        coll.add(&quot;三&quot;);</span><br><span class="line">        coll.add(&quot;连&quot;);</span><br><span class="line">        coll.add(&quot;外&quot;);</span><br><span class="line">        coll.add(&quot;加&quot;);</span><br><span class="line">        coll.add(&quot;转&quot;);</span><br><span class="line">        coll.add(&quot;发&quot;);</span><br><span class="line">        coll.add(&quot;了&quot;);</span><br><span class="line">        coll.add(&quot;吗&quot;);</span><br><span class="line">        coll.add(&quot;?&quot;);</span><br><span class="line">        coll.add(&quot;?&quot;);</span><br><span class="line"></span><br><span class="line">        Iterator&lt;String&gt; it = coll.iterator();</span><br><span class="line">        //hasNext()表示获取当前位置是否有元素，可作为循环的判断依据</span><br><span class="line">        while(it.hasNext())&#123;</span><br><span class="line">                String str = it.next();</span><br><span class="line">                System.out.print(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>    使用迭代器遍历时，要注意以下几点：
</code></pre>
<p>如果迭代器已经指向空，再调用 next 方法会报错：NoSuchElementException。</p>
<p>迭代器遍历完毕后，指针不会复位。</p>
<p>循环中只能用一次 next 方法。</p>
<p>迭代器遍历时，不能用集合的方法进行增加或删除，否则可能会发生指针异常。</p>
<p>想要继续第二次遍历集合，只能再次获取一个新的迭代器对象</p>
<h3 id="5-3-2增强for遍历"><a href="#5-3-2增强for遍历" class="headerlink" title="5.3.2增强for遍历"></a>5.3.2增强for遍历</h3><p>增强 for 的底层其实就是迭代器，它是为了简化迭代器的代码书写而诞生的。它在JDK5之后出现，其内部原理是一个 Iterator 迭代器。</p>
<p>注意，所有的<strong>单列集合</strong>和<strong>数组</strong>才能用增强 for 进行遍历。<br>格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (元素的数据类型 变量名:数组或集合)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-3-3Lambda表达式遍历"><a href="#5-3-3Lambda表达式遍历" class="headerlink" title="5.3.3Lambda表达式遍历"></a>5.3.3Lambda表达式遍历</h3><p>实现 Consumer 接口重写 accept 方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package Colletcion;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Collection;</span><br><span class="line">import java.util.function.Consumer;</span><br><span class="line"></span><br><span class="line">public class LambdaTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //1.创建集合并添加元素</span><br><span class="line">        Collection&lt;String&gt; coll = new ArrayList&lt;&gt;();</span><br><span class="line">        coll.add(&quot;zhangsan&quot;);</span><br><span class="line">        coll.add(&quot;lisi&quot;);</span><br><span class="line">        coll.add(&quot;wangwu&quot;);</span><br><span class="line">        //2.利用匿名内部类的形式</span><br><span class="line">        //forEach底层其实也会自己遍历集合，依次得到每一个元素</span><br><span class="line">        //s就是记录每一个元素的遍历，传递给accept方法</span><br><span class="line">        /*coll.forEach(new Consumer&lt;String&gt;()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            //s依次表示集合中的每一个数据</span><br><span class="line">            public void accept(String s) &#123;</span><br><span class="line">                System.out.println(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);*/</span><br><span class="line">        </span><br><span class="line">        //lambda表达式</span><br><span class="line">        //() -&gt; &#123;&#125;</span><br><span class="line">        coll.forEach(s -&gt; System.out.println(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-4List集合"><a href="#5-4List集合" class="headerlink" title="5.4List集合"></a>5.4List集合</h2><h3 id="5-4-1List集合基本方法"><a href="#5-4-1List集合基本方法" class="headerlink" title="5.4.1List集合基本方法"></a>5.4.1List集合基本方法</h3><p>List 集合是 Collection 下的一种旁支，它的特点是：有序、有索引、可重复。Collection 中的方法，List 都有继承，而 List 集合加入了索引相关的方法，我们只需要再学习索引相关操作即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方法名称	说明</span><br><span class="line">void add(int index, E element)	在此集合中的指定位置插入指定的元素</span><br><span class="line">E remove(int index)	删除指定索引处的元素，返回被删除的元素</span><br><span class="line">E set(int index, E element)	修改指定索引处的元素，返回被修改的元素</span><br><span class="line">E get(int index)	返回指定索引处的元素</span><br></pre></td></tr></table></figure>

<h3 id="5-4-2遍历方式"><a href="#5-4-2遍历方式" class="headerlink" title="5.4.2遍历方式"></a>5.4.2遍历方式</h3><ul>
<li>迭代器遍历</li>
<li>列表迭代器遍历(List独有,Set不行)</li>
<li>增强 for 遍历</li>
<li>Lambda 表达式遍历</li>
<li>基本 for 循环遍历(List独有,Set不行)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package Colletcion;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.ListIterator;</span><br><span class="line">import java.util.function.Consumer;</span><br><span class="line"></span><br><span class="line">public class ListTest2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //创建集合并添加元素</span><br><span class="line">        List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        list.add(&quot;aaa&quot;);</span><br><span class="line">        list.add(&quot;bbb&quot;);</span><br><span class="line">        list.add(&quot;ccc&quot;);</span><br><span class="line"></span><br><span class="line">        //1.迭代器方式</span><br><span class="line">        Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line">        while(it.hasNext()) &#123;</span><br><span class="line">            String str = it.next();</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //2.增强for</span><br><span class="line">        for (String s : list) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //3.lambda表达式</span><br><span class="line">		/*list.forEach(new Consumer&lt;String&gt;()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void accept(String s)&#123;</span><br><span class="line">                System.out.println(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);*/</span><br><span class="line"></span><br><span class="line">        list.forEach(s -&gt; System.out.println(s));</span><br><span class="line"></span><br><span class="line">        //4.简单for循环</span><br><span class="line">        for(int i = 0; i &lt; list.size(); i++) &#123;</span><br><span class="line">            System.out.println(list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //5.列表迭代器</span><br><span class="line">        //列表迭代器是一个接口，不能直接创建对象</span><br><span class="line">        //hasNext() next() hasPrevious() previous() add()</span><br><span class="line">        //获取一个列表迭代器的对象用listIterator()方法</span><br><span class="line">        ListIterator&lt;String&gt; itr = list.listIterator();</span><br><span class="line">        while(itr.hasNext()) &#123;</span><br><span class="line">            String str = itr.next();</span><br><span class="line">            //list迭代器额外添加了一个方法：在遍历过程中，可以添加元素</span><br><span class="line">            //下面的代码在“bbb”元素后添加了一个“QQQ”元素，调用迭代器本身的add()方法</span><br><span class="line">            if(&quot;bbb&quot;.equals(str))&#123;</span><br><span class="line">                itr.add(&quot;QQQ&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(list);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code> 这五种遍历方式可以说是有不同的用途：
</code></pre>
<p>在遍历过程中，如果要删除元素，请使用迭代器遍历。<br>在遍历过程中，如果要添加元素，请使用列表迭代器遍历。<br>如果仅仅想遍历，那么使用增强 for 或 Lambda 表达式即可。<br>如果在遍历时想对索引进行操作，可以使用普通 for 循环进行遍历。</p>
<h2 id="5-5Set集合"><a href="#5-5Set集合" class="headerlink" title="5.5Set集合"></a>5.5Set集合</h2><pre><code>Set 集合系列是单列集合体系结构的另一条分支，有别于 List 集合的有序、可重复、有索引，Set 集合的特征是无序、不重复、无索引。
</code></pre>
<p>无序：存取顺序不一致。<br>不重复：可以去除重复数据。<br>无索引：没有带索引的方法，所以不能使用普通 for 循环遍历，也不能通过索引来获取元素。<br>Set 集合有三个实现类，它们分别是：</p>
<p>HashSet：无序、不重复、无索引。<br>LinkedHashSet：有序、不重复、无索引。<br>TreeSet：可排序、不重复、无索引。</p>
<p>Set 本身是一个接口，它里面的方法基本上和 Collection 的 API 一致。</p>
<h3 id="5-5-1Set-集合的遍历"><a href="#5-5-1Set-集合的遍历" class="headerlink" title="5.5.1Set 集合的遍历"></a>5.5.1Set 集合的遍历</h3><p>Set 集合也可以用常用的那三种方式遍历，即：[迭代器]  、增强 for 、Lambda 表达式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package Set;</span><br><span class="line"></span><br><span class="line">import java.util.HashSet;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.Set;</span><br><span class="line">import java.util.function.Consumer;</span><br><span class="line"></span><br><span class="line">public class SetDemo1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        /*</span><br><span class="line">        遍历Set</span><br><span class="line">         */</span><br><span class="line"></span><br><span class="line">        //1.创建一个Set集合的对象</span><br><span class="line">        //由于Set是一个接口，所以只能创建其实现类对象，可以利用多态实现调用Set中的方法</span><br><span class="line">        Set&lt;String&gt; s = new HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        //2.添加元素</span><br><span class="line">        //add方法的返回值是一个布尔类型，用于判断元素是否添加成功</span><br><span class="line">        //如果已经有重复元素，添加就会失败</span><br><span class="line">        s.add(&quot;aaa&quot;);</span><br><span class="line">        s.add(&quot;bbb&quot;);</span><br><span class="line">        System.out.println(s.add(&quot;bbb&quot;));</span><br><span class="line">        s.add(&quot;ccc&quot;);</span><br><span class="line"></span><br><span class="line">        //3.打印集合</span><br><span class="line">        System.out.println(s);</span><br><span class="line"></span><br><span class="line">        //迭代器遍历</span><br><span class="line">        Iterator&lt;String&gt; it = s.iterator();</span><br><span class="line">        while(it.hasNext()) &#123;</span><br><span class="line">            System.out.println(it.next());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //增强for</span><br><span class="line">        for (String str : s) &#123;</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //lambda表达式</span><br><span class="line">        s.forEach(str -&gt; System.out.println(str));</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-5-2HashSet"><a href="#5-5-2HashSet" class="headerlink" title="5.5.2HashSet"></a>5.5.2HashSet</h3><h4 id="1-哈希值"><a href="#1-哈希值" class="headerlink" title="1.哈希值"></a>1.哈希值</h4><p>HashSet 集合在底层采取<strong>哈希表</strong>存储数据。<br>    哈希表是一种对于增删改查数据性能都良好的结构。<br>    在 JDK8 以前，哈希表的底层是数组+链表；在 JDK8 以后，哈希表的底层是数组+链表+红黑树。</p>
<p>哈希值是对象的<strong>整数</strong>表现形式。<br>哈希表在底层是有一个数组存在的，这个数组存储数据时，存储在哪个位置上的索引，是有公式要求的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int index = (数组长度 - 1) &amp; 哈希值;</span><br></pre></td></tr></table></figure>

<p> 公式中的这个哈希值，是 Java 根据 hashCode() 方法计算出来的 int 类型的整数，这个方法定义在 Object 类中，所以所有对象都可以调用，默认使用对象的地址值进行计算。<br>但是，一般情况下，我们在使用时会改写 hashCode 方法，利用对象内部的属性值来计算哈希值。因此：</p>
<p>如果没有重写 hashCode() 方法，不同对象计算出的哈希值一定是不同的。<br>如果已经重写 hashCode() 方法，不同的对象只要属性值相同，计算出的哈希值就是相同的。<br>小概率事件（哈希碰撞）：不同的属性值或者不同的地址值计算出来的哈希值出现了一样的情况。</p>
<h4 id="2-HashSet-存储底层原理"><a href="#2-HashSet-存储底层原理" class="headerlink" title="2.HashSet 存储底层原理"></a>2.HashSet 存储底层原理</h4><p><img src="https://pic.imgdb.cn/item/672b3bffd29ded1a8cd79a99.png" alt="12"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数组长度 × 加载因子 = 数组存储元素个数上限</span><br></pre></td></tr></table></figure>

<p>​        默认16 × 0.75 &#x3D; 12，当存储12个元素时，数组会扩容成原来的两倍。<br>​        而当链表长度大于8且数组长度大于等于64时，当前链表就会自动转化为红黑树，从而提高了查找效率。</p>
<p>两个注意点：<br>1.JDK8 以后，当链表长度超过8，而且数组长度大于等于64时，自动把链表转换为红黑树。<br>2.如果集合中存储的是自定义对象，必须要重写 hashCode 和 equals 方法。</p>
<h4 id="3-HashSet-集合的特点"><a href="#3-HashSet-集合的特点" class="headerlink" title="3.HashSet 集合的特点"></a>3.HashSet 集合的特点</h4><p>1.HashSet 存和取的顺序不一样。</p>
<p>   HashSet 在读数据时，从数组0索引开始，一条链表一条链表地遍历，这和我们添加元素时的顺序不一样，因此 HashSet 存和取的顺序是不一样的。</p>
<p>2.HashSet 没有索引。</p>
<p>​    HashSet 在底层是数组+链表+红黑树组成，没有办法用一个索引值来找寻一个元素。</p>
<p>3.HashSet 为什么能数据去重？</p>
<p>​    HashSet 就是利用 hashCode() 方法和 equals() 方法来去重的。在添加元素前，先用 hashCode() 方法算出元素应该存到数组的哪个位置，如果这个位置上有元素了，再调用 equals() 方法，判断这个元素和要添加的元素是不是完全一样，如果一样，就不用添加了。因此完成了数据去重。</p>
<p>注意：如果集合里要放的是自定义对象，那就必须重写 hashCode() 和 equals() 方法；但是如果你要放的是 String 或者 Integer 这样本来就有的类，就不需要重写那两个方法了，Java 已经自动帮我们重写好了。</p>
<h3 id="5-5-3LinkedHashSet"><a href="#5-5-3LinkedHashSet" class="headerlink" title="5.5.3LinkedHashSet"></a>5.5.3LinkedHashSet</h3><p><img src="https://pic.imgdb.cn/item/672b3bffd29ded1a8cd79ab2.png" alt="13"></p>
<h3 id="5-5-4TreeSet"><a href="#5-5-4TreeSet" class="headerlink" title="5.5.4TreeSet"></a>5.5.4TreeSet</h3><p>​    TreeSet 是 Set 体系中的一种集合类。它的特点是：不重复、无索引、可排序。<br>​    TreeSet 可排序，且按照元素的默认规则（由小到大）排序。它的底层是基于红黑树的数据结构实现排序的，增删改查性能都较好。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TreeSet 集合对于数值类型：Integer，Double，默认都是按照从小到大排列的。</span><br><span class="line">        而对于字符、字符串类型：按照字符在 ASCII 码表中的数字升序进行排序。比如 “a” 是 97，“A” 是 65。</span><br><span class="line">        如果字符串内容比较多，它会从首字母开始挨个比较，此时和字符串的长度没有任何关系。比如：“aaa” 就大于 “ab” ，因为第一个字母一样，比较第二个字母，“a” &gt; “b” ，已经可以确定大小关系，因此不再比较后面的字母</span><br></pre></td></tr></table></figure>

<ul>
<li>其一是默认排序 &#x2F; 自然排序：利用 Javabean 类实现 Comparable 接口指定比较规则。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//在Student类中重写Comparable接口中的抽象方法</span><br><span class="line">    @Override</span><br><span class="line">    public int compareTo(Student o) &#123;</span><br><span class="line">        //指定排序规则</span><br><span class="line">        //只看年龄，按照年龄升序排列</span><br><span class="line">        //TreeSet内部是红黑树结构，Student不需要重写其equals和hashCode方法</span><br><span class="line">        //this：表示当前要添加的元素</span><br><span class="line">        //o：表示已经在红黑树存在的元素</span><br><span class="line">        //返回值：负数：认为当前要添加的元素是小的，就要存左边</span><br><span class="line">        //正数：认为要添加的元素是大的，就要存右边</span><br><span class="line">        //0：认为当前要添加的元素已经存在，舍弃不存</span><br><span class="line">        System.out.println(&quot;-------------------------&quot;);</span><br><span class="line">        System.out.println(&quot;this:&quot; + this);</span><br><span class="line">        System.out.println(&quot;o:&quot; + o);</span><br><span class="line">        return this.getAge() - o.getAge();</span><br></pre></td></tr></table></figure>

<ul>
<li><p>其二是比较器排序：在创建 TreeSet 对象的时候，传递比较器 Comparator 指定规则（参数是一个 Comparator 接口的匿名实现类）。传递 Comparator 接口的匿名实现类（可以用Lambda表达式），然后在内部重写 compare 方法，指定比较规则。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package Set;</span><br><span class="line"></span><br><span class="line">import java.util.Comparator;</span><br><span class="line">import java.util.TreeSet;</span><br><span class="line"></span><br><span class="line">public class TreeSetDemo3 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        /*</span><br><span class="line">        存入四个字符串，&quot;c&quot;，&quot;ab&quot;，&quot;df&quot;，&quot;qwer&quot; 按照长度排序，如果一样长就按照首字母排序</span><br><span class="line"></span><br><span class="line">        比较器排序：创建集合时传入一个比较器对象</span><br><span class="line">         */</span><br><span class="line"></span><br><span class="line">        //1.创建集合</span><br><span class="line">        //参数传递一个Comparator的匿名实现类，重写compare方法</span><br><span class="line">/*        TreeSet&lt;String&gt; ts = new TreeSet&lt;&gt;(new Comparator&lt;String&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public int compare(String o1, String o2) &#123;</span><br><span class="line">                //按照长度排序</span><br><span class="line">                int i = o1.length() - o2.length();</span><br><span class="line">                //如果一样长就按照首字母排序，否则按照长度排序</span><br><span class="line">                i = i == 0 ? o1.compareTo(o2) : i;</span><br><span class="line">                return i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);*/</span><br><span class="line"></span><br><span class="line">        //改写为Lambda表达式</span><br><span class="line">                TreeSet&lt;String&gt; ts = new TreeSet&lt;&gt;((o1, o2) -&gt; &#123;</span><br><span class="line">                //按照长度排序</span><br><span class="line">                int i = o1.length() - o2.length();</span><br><span class="line">                //如果一样长就按照首字母排序，否则按照长度排序</span><br><span class="line">                //compareTo默认是按照字符串首字母排序的</span><br><span class="line">                i = i == 0 ? o1.compareTo(o2) : i;</span><br><span class="line">                return i;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">        </span><br><span class="line">        //2.添加元素</span><br><span class="line">        ts.add(&quot;c&quot;);</span><br><span class="line">        ts.add(&quot;ab&quot;);</span><br><span class="line">        ts.add(&quot;df&quot;);</span><br><span class="line">        ts.add(&quot;qwer&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(ts);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="5-6List和Set集合总结"><a href="#5-6List和Set集合总结" class="headerlink" title="5.6List和Set集合总结"></a>5.6List和Set集合总结</h2><p><img src="https://pic.imgdb.cn/item/672b3bffd29ded1a8cd79ae6.png" alt="14"></p>
<h1 id="6-static-静态变量"><a href="#6-static-静态变量" class="headerlink" title="6.static-静态变量"></a>6.static-静态变量</h1><h2 id="6-1static-修饰成员变量"><a href="#6-1static-修饰成员变量" class="headerlink" title="6.1static 修饰成员变量"></a>6.1static 修饰成员变量</h2><p>成员变量一旦被 static修饰之后，这个成员变量就叫做静态变量。</p>
<p>静态变量 的特点：</p>
<ul>
<li><p>被这个类所有对象共享</p>
</li>
<li><p>不属于对象，属于类</p>
</li>
<li><p>随着类的加载而加载，优先于对象存在</p>
<p>而对象一定要等 new 关键字执行了，它才在内存中出现</p>
</li>
</ul>
<h2 id="6-2static修饰成员方法"><a href="#6-2static修饰成员方法" class="headerlink" title="6.2static修饰成员方法"></a>6.2static修饰成员方法</h2><p>被static修饰的成员方法被称之为静态成员方法，是类的方法，不是某个对象所特有的，静态成员一般通过类名进行访问</p>
<h3 id="6-21工具类"><a href="#6-21工具类" class="headerlink" title="6.21工具类"></a>6.21工具类</h3><p>1：类名见名知意</p>
<p>2：私有化构造方法</p>
<p>3：方法定义为静态</p>
<h2 id="6-3静态代码块（重点）"><a href="#6-3静态代码块（重点）" class="headerlink" title="6.3静态代码块（重点）"></a>6.3静态代码块（重点）</h2><p>使用static修饰的{ }，称之为静态代码块，一般用于初始化静态成员变量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private String name;</span><br><span class="line">private int age;</span><br><span class="line">public static String classRoom;</span><br><span class="line"></span><br><span class="line">static &#123;</span><br><span class="line">    classRoom = &quot;405班&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>  静态代码块在整个工程中，随着类的加载而加载，并且自动触发，只会调用一次，无论实例化多少个对象，静态代码块只会在第一次实例化对象的时候调用。</p>
<p>使用场景：在类加载的时候，做一些数据初始化的时候使用</p>
<h2 id="6-4构造代码块（了解一下）"><a href="#6-4构造代码块（了解一下）" class="headerlink" title="6.4构造代码块（了解一下）"></a>6.4构造代码块（了解一下）</h2><p>构造代码块：定义在类中的代码块，同样是没有任何关键字修饰，只有{ }包围的代码，构造代码块也被称之为实例代码块。<br>    与普通代码块不同的是，构造代码块是定义在类中的，并且一般用于初始化成员变量，普通代码块不一定是在类中定义的，只能说普通代码块里面包含有构造代码块。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  name = &quot;梨花&quot;;</span><br><span class="line">  age = 20;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是：构造代码块先执行，然后才会执行构造方法，构造代码块实际上可以理解为一种默认的初始化， 因为当我们使用了构造代码块的时候，构造代码块里面的成员变量就已经固定了，除非我们更改代码，否则在调用默认无参构造方法的情况下，每次实例化对象，对象的数据都是构造代码块的数据，此时我们想要定义不同数据的代码块时，就可以通过构造方法，在重载构造方法的情况下调用含参的构造方法，从而达到实例化不同数据的对象的目的。</p>
<p>作用：可以把多个构造方法中重复的代码抽取出来</p>
<h2 id="6-5总结"><a href="#6-5总结" class="headerlink" title="6.5总结"></a>6.5总结</h2><p>​        1、静态代码块不管生成多少个对象，其都只会实行一次<br>    2、静态成员变量是类的属性，因此是在JVM加载类时开辟空间并初始化的<br>    3、如果一个类中包含有多个静态代码块或者构造代码块，在编译代码的时候，编译器会按照定义的顺序依次执行。 因为类中定义的静态代码块相当于同一等级到代码，没有执行的先后顺序，编译器就会按照定义的顺序依次执行，构造代码块也是如此。<br>    4、实例代码块只有在实例化对象时才会执行。 当通过类创建类类型的引用时，如果没有通过new关键字实例化对象，那么构造代码块一样不会执行<br>    5、先执行静态代码块，然后执行构造代码块，最后执行构造方法。</p>
<h1 id="7-final"><a href="#7-final" class="headerlink" title="7.final"></a>7.final</h1><h2 id="7-1修饰类"><a href="#7-1修饰类" class="headerlink" title="7.1修饰类"></a>7.1修饰类</h2><p>当某个类的整体定义为 final 时，就表明了你不打算继承该类，而且也不允许别人这么做。即这个类是不能有子类的。</p>
<h2 id="7-2修饰方法"><a href="#7-2修饰方法" class="headerlink" title="7.2修饰方法"></a>7.2修饰方法</h2><p>被 final 修饰的方法称为常量方法，该方法可以被重载，也可以被子类继承，但却不能被重写。当一个方法的功能已经可以满足当前要求，不需要进行扩展，我们就不用任何子类来重写该方法，防止该方法的内容被修改。比如 Object 类中，就有一个 final 修饰的 getClass() 方法，Object 的任何子类都不能重写这个方法。</p>
<h2 id="7-3修饰变量"><a href="#7-3修饰变量" class="headerlink" title="7.3修饰变量"></a>7.3修饰变量</h2><p>根据修饰变量的数据类型，比如在修饰基本类型和引用类型的变量时，final 也有不同的特性：</p>
<ol>
<li>final修饰基本类型的变量时，不能把基本类型的值重新赋值，因此基本类型的变量值不能被改变。</li>
<li>final修饰引用类型的变量时，final 只会保证引用类型的变量所引用的地址不会改变，即保证该变量会一直引用同一个对象。因为引用类型的变量保存的仅仅是一个引用地址，所以 final 修饰引用类型的变量时，该变量会一直引用同一个对象，但这个对象本身的成员和数据是完全可以发生改变的</li>
</ol>
<h2 id="7-4static-final"><a href="#7-4static-final" class="headerlink" title="7.4static final"></a>7.4static final</h2><p>一个既是 static 又是 final 的字段只占据一段不能改变的存储空间，它必须在定义的时候进行赋值，否则编译器将不予通过。</p>
<h2 id="7-5private-final"><a href="#7-5private-final" class="headerlink" title="7.5private final"></a>7.5private final</h2><p>private final byte[] value；字符串底层</p>
<p>由于value是private的，且没有提供setValue等公共方法来修改这个value值，所以在String类的外部是无法修改value值的，也就是说一旦初始化就不能被修改。此外，value变量是final的， 也就是说在String类内部，一旦这个值初始化了，value这个变量所引用的地址就不会改变了，即一直引用同一个对象。正是基于这一层，所以说String对象是不可变的对象</p>
<p>注意：但其实value所引用对象的内容完全可以发生改变，我们可以利用 [反射来消除String类对象的不可变特性]</p>
<h1 id="8权限修饰符"><a href="#8权限修饰符" class="headerlink" title="8权限修饰符"></a>8权限修饰符</h1><p><img src="https://pic.imgdb.cn/item/672b3bf5d29ded1a8cd79191.png" alt="7"></p>
<h1 id="9-接口"><a href="#9-接口" class="headerlink" title="9.接口"></a>9.接口</h1><h2 id="9-1接口概述"><a href="#9-1接口概述" class="headerlink" title="9.1接口概述"></a>9.1接口概述</h2><p>interface：[引用数据类型]：类、数组、接口</p>
<p>接口是对Java单继承的补充。Java只支持单继承（亲爹唯一），如果在开发过程中想额外增强类的功能，可以借助接口实现（可以拜师，拜多个师傅也可以）。</p>
<p>接口是Java中一种重要的抽象机制，它提供了一种定义行为规范和实现多态性的方式。通过合理使用接口，可以提高代码的可扩展性、可维护性和灵活性。</p>
<p>接口是除了类和数组之外，另外一种<strong>引用数据类型</strong>，需要使用 <code>interface</code> 关键字来定义，接口最终也会被编译成<code>.class文件</code>，但一定要明确接口并不是类，而是另外一种引用数据类型。</p>
<h2 id="9-2接口基础定义格式"><a href="#9-2接口基础定义格式" class="headerlink" title="9.2接口基础定义格式"></a>9.2接口基础定义格式</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[修饰符] interface 接口名 &#123;</span><br><span class="line">    //数据成员，可以定义多个</span><br><span class="line">    [public static final] 数据类型 数据成员 = 值;</span><br><span class="line"></span><br><span class="line">    //抽象方法：可以定义多个</span><br><span class="line">    [public abstract] 返回值类型 方法名(形参列表);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>案例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.briup.chap07.test;</span><br><span class="line"></span><br><span class="line">//使用interface关键字来定义接口</span><br><span class="line">interface IAction &#123;</span><br><span class="line">	//数据成员,下面2行效果一样</span><br><span class="line">	//public static final int NUM = 10;</span><br><span class="line">	int NUM = 10;</span><br><span class="line"></span><br><span class="line">	//成员方法,下面2行效果一样</span><br><span class="line">	//public abstract void start();</span><br><span class="line">	void start();</span><br><span class="line"></span><br><span class="line">	public abstract void end();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Test021_Basic &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		//接口不可以实例化对象</span><br><span class="line">        //IAction ac = new IAction(); error</span><br><span class="line">        </span><br><span class="line">        System.out.println(IAction.NUM);</span><br><span class="line">        </span><br><span class="line">        //接口中数据成员默认 public static final，故而下行编译报错</span><br><span class="line">        //IAction.NUM = 20;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意1， 定义类使用关键字<code>class</code>，定义接口使用关键字<code>interface</code></p>
<p>注意2，接口中的数据成员，默认<code>public static final</code>修饰，是常量，名称全大写（符合命名规范）</p>
<p>注意3，接口中的方法，默认<code>public abstract</code>修饰，是抽象方法</p>
<ul>
<li><strong>JDK8</strong>中，还允许在接口中编写<strong>静态方法</strong>和<strong>默认方法</strong></li>
<li><strong>JDK9</strong>中，还允许在接口中编写<strong>私有方法</strong></li>
</ul>
<h2 id="9-3-接口实现"><a href="#9-3-接口实现" class="headerlink" title="9.3 接口实现"></a>9.3 接口实现</h2><p>Java中类和类之间的关系是继承，且只能是单继承</p>
<p>类和接口是实现关系，通过implements关键字表示，可以是单实现，也可以是多实现</p>
<p>子类还可以在继承一个父类的同时实现多个接口</p>
<p><strong>接口的实现类书写格式</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//一个类可以同时实现多个接口</span><br><span class="line">[修饰符] class 类名 implements 接口名1,接口名2,... &#123;</span><br><span class="line">	重写所有抽象方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-4JDK8新特性"><a href="#9-4JDK8新特性" class="headerlink" title="9.4JDK8新特性"></a>9.4JDK8新特性</h2><p>JDK8新特性：接口可以包含静态方法和默认方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.briup.chap07.test;</span><br><span class="line"></span><br><span class="line">//JDK8中接口 可以添加默认方法和static方法</span><br><span class="line">interface JDK8Action &#123;</span><br><span class="line">	// 接口中静态常量</span><br><span class="line">	String OPS_MODE = &quot;auto&quot;;</span><br><span class="line"></span><br><span class="line">	// 接口中抽象方法</span><br><span class="line">	void start();</span><br><span class="line">	void stop();</span><br><span class="line">  </span><br><span class="line">    //下面是JDK8新特性</span><br><span class="line">	//默认方法</span><br><span class="line">	public default void dFun() &#123;</span><br><span class="line">		System.out.println(&quot;in default fun() ...&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">	//静态方法</span><br><span class="line">	public static void sFun() &#123;</span><br><span class="line">		System.out.println(&quot;in static fun() ...&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Demo01 implements JDK8Action &#123;</span><br><span class="line">	@Override</span><br><span class="line">	public void start() &#123;</span><br><span class="line">		System.out.println(&quot;重写start() ...&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public void stop() &#123;</span><br><span class="line">		System.out.println(&quot;重写stop() ...&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Test026_JDK8 &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		//1.接口引用指向实现类对象</span><br><span class="line">		JDK8Action a = new Demo01();</span><br><span class="line">		</span><br><span class="line">		//2.调用实现类重写方法</span><br><span class="line">		a.start();</span><br><span class="line">		a.stop();</span><br><span class="line">		</span><br><span class="line">		//3.调用default方法</span><br><span class="line">		a.dFun();</span><br><span class="line">		</span><br><span class="line">		//4.JDK8中接口可以定义static方法，只能通过接口名调用，但不能通过接口引用调用，也不能通过实现类名调用</span><br><span class="line">		//a.sFun();	编译报错</span><br><span class="line">        //Demo01.sFun(); 编译报错</span><br><span class="line">		JDK8Action.sFun();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-5JDK9新特性"><a href="#9-5JDK9新特性" class="headerlink" title="9.5JDK9新特性"></a>9.5JDK9新特性</h2><p>接口可以包含私有方法:分为普通的私有方法和静态的私有方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.briup.chap07.test;</span><br><span class="line"></span><br><span class="line">//使用interface关键字来定义接口</span><br><span class="line">interface JDK9Action &#123;</span><br><span class="line">	// 接口中的静态常量</span><br><span class="line">	String OPS_MODE = &quot;auto&quot;;</span><br><span class="line"></span><br><span class="line">	// 接口中的抽象方法</span><br><span class="line">	void start();</span><br><span class="line">	</span><br><span class="line">    //私有方法 jdk9以下报错</span><br><span class="line">	private void run() &#123;</span><br><span class="line">    	System.out.println(&quot;private run() ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Demo02 implements JDK8Action &#123;</span><br><span class="line">	@Override</span><br><span class="line">	public void start() &#123;</span><br><span class="line">		System.out.println(&quot;重写start() ...&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//测试类</span><br><span class="line">public class Test026_JDK9 &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">    	//1.接口引用指向实现类对象</span><br><span class="line">		JDK9Action a = new Demo02();</span><br><span class="line">        </span><br><span class="line">        //2.调用实现类重写的抽象方法</span><br><span class="line">        a.start();</span><br><span class="line">        </span><br><span class="line">        //3.调用接口private方法</span><br><span class="line">        a.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-6常见面试题"><a href="#9-6常见面试题" class="headerlink" title="9.6常见面试题"></a>9.6常见面试题</h2><p>接口和抽象类有什么区别？如何选择？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">定义方式：抽象类通过使用 abstract 关键字来定义，而接口使用 interface 关键字来定义</span><br><span class="line">数据成员：抽象类可以包含普通数据成员和static数据成员，而接口只能包含 static final 修饰的数据成员</span><br><span class="line">成员方法：抽象类可以包含具体的方法实现，而接口只能包含抽象方法，即没有方法体的方法声明</span><br><span class="line">构造函数：抽象类可以有构造函数，而接口不能有构造函数</span><br><span class="line">实现方式：一个类可以继承（extends）一个抽象类，而一个类可以实现（implements）多个接口</span><br><span class="line">多继承：Java不支持多继承，一个类只能继承一个抽象类，但可以实现多个接口</span><br></pre></td></tr></table></figure>

<h1 id="10-适配器设计模式"><a href="#10-适配器设计模式" class="headerlink" title="10.适配器设计模式"></a>10.适配器设计模式</h1><h2 id="10-1设计模式"><a href="#10-1设计模式" class="headerlink" title="10.1设计模式"></a>10.1设计模式</h2><p>设计模式是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。</p>
<p>使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性、程序的重用性。</p>
<h2 id="10-2适配器设计模式-结构型"><a href="#10-2适配器设计模式-结构型" class="headerlink" title="10.2适配器设计模式(结构型)"></a>10.2适配器设计模式(结构型)</h2><p>目的:，它可以来解决接口与接口实现类之间的矛盾问题。</p>
<p>案例:在这个接口中定义了10个抽象方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.a09interfacedemo9;</span><br><span class="line"></span><br><span class="line">public interface Inter &#123;</span><br><span class="line">    public abstract void method1();</span><br><span class="line">    public abstract void method2();</span><br><span class="line">    public abstract void method3();</span><br><span class="line">    public abstract void method4();</span><br><span class="line">    public abstract void method5();</span><br><span class="line">    public abstract void method6();</span><br><span class="line">    public abstract void method7();</span><br><span class="line">    public abstract void method8();</span><br><span class="line">    public abstract void method9();</span><br><span class="line">    public abstract void method10();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需求：我现在想要使用到这个接口的第5个抽象方法。</p>
<p>按照我们以前所学，先写一个实现类去实现 <code>Inter接口</code>。</p>
<p>实现一个接口，就需要重写里面所有的抽象方法。但是现在有一个问题：除了 method5() 方法外的其他9个抽象方法，都用不到！</p>
<p>在以前，由于接口的语法特点，其他的这些方法，我不得不重写，这样就会导致代码在书写起来的时候，或者后期在阅读的时候太麻烦了，不能让我一下子看到这个 method5()！<br>解决方法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当一个接口中抽象方法过多，但是我只要使用其中一部分方法时候，就可以使用适配器设计模式去简化代码</span><br><span class="line"></span><br><span class="line">它的使用方式有以下几步</span><br><span class="line"></span><br><span class="line">编写一个中间类，中间类的名字为：XXXAdapter，其中 XXX 是接口名，后面再加一个 Adapter 即可，表示它是一个中间适配器类。然后让它去实现对应的接口。</span><br><span class="line">让 XXXAdapter 对接口中所有的抽象方法进行空实现。</span><br><span class="line">让真正的实现类继承中间类 XXXAdapter ，并重写需要用的方法</span><br><span class="line">为了避免其他类去创建中间适配器类的对象，中间的适配器类需要使用 abstract 来进行修饰</span><br></pre></td></tr></table></figure>

<p>细节:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果实现类还有其他的父类该怎么办呢？但是在Java中又不能多继承。</span><br><span class="line"></span><br><span class="line">此时我们就可以让中间的适配器去继承你想要的类就行了，Java不能多继承但是可以间接继承。</span><br></pre></td></tr></table></figure>

<h1 id="11-API"><a href="#11-API" class="headerlink" title="11.API"></a>11.API</h1><h2 id="11-1LocalDate"><a href="#11-1LocalDate" class="headerlink" title="11.1LocalDate"></a>11.1LocalDate</h2><p><a href="https://www.cnblogs.com/zhangzhixi/p/16455137.html">https://www.cnblogs.com/zhangzhixi/p/16455137.html</a></p>
<h3 id="11-1-1LocalDateTime"><a href="#11-1-1LocalDateTime" class="headerlink" title="11.1.1LocalDateTime"></a>11.1.1LocalDateTime</h3><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>static LocalDateTime now()</td>
<td>获取默认时区的当前日期时间</td>
</tr>
<tr>
<td>static LocalDateTime now(Clock clock)</td>
<td>从指定时钟获取当前日期时间</td>
</tr>
<tr>
<td>static LocalDateTime now(ZoneId zone)</td>
<td>获取指定时区的当前日期时间</td>
</tr>
<tr>
<td>static LocalDateTime of(LocalDate date, LocalTime time)</td>
<td>根据日期和时间对象获取LocalDateTime 实例</td>
</tr>
<tr>
<td>static LocalDateTime of(int year, Month month, int dayOfMonth, int hour, int minute, int second)</td>
<td>second) 根据指定的年、月、日、时、分、秒获取LocalDateTime 实例</td>
</tr>
<tr>
<td>getYear</td>
<td>获取年份</td>
</tr>
<tr>
<td>getMonth</td>
<td>使用月份枚举类获取月份</td>
</tr>
<tr>
<td>getDayOfMonth</td>
<td>获取日期在该月是第几天</td>
</tr>
<tr>
<td>getDayOfWeek</td>
<td>获取日期是星期几</td>
</tr>
<tr>
<td>getDayOfYear</td>
<td>获取日期在该年是第几天</td>
</tr>
<tr>
<td>getHour</td>
<td>获取小时</td>
</tr>
<tr>
<td>getMinute</td>
<td>获取分钟</td>
</tr>
<tr>
<td>getSecond</td>
<td>获取秒</td>
</tr>
<tr>
<td>getNano</td>
<td>获取纳秒</td>
</tr>
<tr>
<td>plusYears</td>
<td>增加年</td>
</tr>
<tr>
<td>plusMonths</td>
<td>增加月</td>
</tr>
<tr>
<td>plusWeeks</td>
<td>增加周</td>
</tr>
<tr>
<td>plusDays</td>
<td>增加天</td>
</tr>
<tr>
<td>plusHours</td>
<td>增加小时</td>
</tr>
<tr>
<td>plusMinutes</td>
<td>增加分</td>
</tr>
<tr>
<td>plusSeconds</td>
<td>增加秒</td>
</tr>
<tr>
<td>plusNanos</td>
<td>增加纳秒</td>
</tr>
<tr>
<td>minusYears</td>
<td>减少年</td>
</tr>
<tr>
<td>minusMonths</td>
<td>减少月</td>
</tr>
<tr>
<td>meminusWeeks</td>
<td>减少周</td>
</tr>
<tr>
<td>minusDays</td>
<td>减少天</td>
</tr>
<tr>
<td>minusHours</td>
<td>减少小时</td>
</tr>
<tr>
<td>minusMinutes</td>
<td>减少分</td>
</tr>
<tr>
<td>minusSeconds</td>
<td>减少秒</td>
</tr>
<tr>
<td>minusNanos</td>
<td>减少纳秒</td>
</tr>
<tr>
<td>isEqual</td>
<td>判断日期时间是否相等</td>
</tr>
<tr>
<td>isBefore</td>
<td>检查是否在指定日期时间之前</td>
</tr>
<tr>
<td>isAfter</td>
<td>检查是否在指定日期时间之后</td>
</tr>
</tbody></table>
<h2 id="11-2常见算法API-Arrays"><a href="#11-2常见算法API-Arrays" class="headerlink" title="11.2常见算法API-Arrays"></a>11.2常见算法API-Arrays</h2><p>Arrays:数组类</p>
<h3 id="11-2-1常用方法"><a href="#11-2-1常用方法" class="headerlink" title="11.2.1常用方法:"></a>11.2.1常用方法:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static String toString(数组)                           把数组拼接成一个字符串</span><br><span class="line">public static int binarySearch (数组，查找的元素)               二分查找法查找元素</span><br><span class="line">public static int[] copyOf(原数组，新数组长度)                  拷贝数组</span><br><span class="line">public static int[] copyOfRange(原数组，起始索引，结束索引)       拷贝数组(指定范围)</span><br><span class="line">public static void fill(数组，元素)                            填充数组</span><br><span class="line">public static void sort(数组)                                 按照默认方式进行数组排序</span><br><span class="line">public static void sort(数组，排序规则)                        按照指定的规则排序</span><br></pre></td></tr></table></figure>

<p>示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//把数组拼接成一个字符串</span><br><span class="line">        int[] arr = &#123;1,2,3,4,5,6,7,8,9,10&#125;;</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">        //二分查找法查找元素,返回索引</span><br><span class="line">        System.out.println(Arrays.binarySearch(arr, 1));</span><br><span class="line"></span><br><span class="line">        //拷贝数组</span><br><span class="line">        int[] ints = Arrays.copyOf(arr, 12);</span><br><span class="line">        System.out.println(Arrays.toString(ints));</span><br><span class="line"></span><br><span class="line">        //拷贝数组(指定范围):包头不包尾</span><br><span class="line">        int[] ints1 = Arrays.copyOfRange(arr, 0, 9);</span><br><span class="line">        System.out.println(Arrays.toString(ints1));</span><br><span class="line"></span><br><span class="line">        //填充数组</span><br><span class="line">//        Arrays.fill(arr,1);</span><br><span class="line">//        System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">        //按照默认方式进行数组排序:升序</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="11-2-2常用方法排序规则"><a href="#11-2-2常用方法排序规则" class="headerlink" title="11.2.2常用方法排序规则"></a>11.2.2常用方法排序规则</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Integer[] arr = &#123;1,2,3,4,5,6,7,8,9,10&#125;;</span><br><span class="line">Arrays.sort(arr, new Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int compare(Integer o1, Integer o2) &#123;</span><br><span class="line">        return o2 - o1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Lambda表达式:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//匿名内部类:</span><br><span class="line">		Arrays.sort(arr, new Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public int compare(Integer o1, Integer o2) &#123;</span><br><span class="line">                return o1 - o2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">============================================================================================================  //Lambda表达式(标准格式):</span><br><span class="line">    	Arrays.sort(arr, (Integer o1, Integer o2)-&gt;&#123;</span><br><span class="line">                return o1 - o2;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br></pre></td></tr></table></figure>

<h1 id="12双列集合-—-Map-系列"><a href="#12双列集合-—-Map-系列" class="headerlink" title="12双列集合 — Map 系列"></a>12双列集合 — Map 系列</h1><h2 id="12-1-双列集合体系结构"><a href="#12-1-双列集合体系结构" class="headerlink" title="12.1.双列集合体系结构"></a>12.1.双列集合体系结构</h2><p><img src="https://pic.imgdb.cn/item/672b3bffd29ded1a8cd79af6.png" alt="15"></p>
<p>Map 集合定义了很多方法，如下表。</p>
<p><img src="https://pic.imgdb.cn/item/672b3bfed29ded1a8cd79a74.png" alt="16"></p>
<h2 id="12-2Map-的遍历方式"><a href="#12-2Map-的遍历方式" class="headerlink" title="12.2Map 的遍历方式"></a>12.2Map 的遍历方式</h2><p> Map 集合有三种遍历方式，键找值、依次键值对、Lambda 表达式遍历。</p>
<h3 id="1-键找值-三种方式"><a href="#1-键找值-三种方式" class="headerlink" title="1.键找值(三种方式)"></a>1.键找值(三种方式)</h3><p> 可以创建一个键的单列集合，通过每一个元素调用 get 方法来找对应的值。</p>
<p>案例:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package Maps;</span><br><span class="line"></span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">public class MapDemo2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //遍历方式1</span><br><span class="line">        //1.创建Map集合对象</span><br><span class="line">        Map&lt;String, String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        //2.添加元素</span><br><span class="line">        map.put(&quot;喜羊羊&quot;,&quot;美羊羊&quot;);</span><br><span class="line">        map.put(&quot;大大怪&quot;,&quot;小小怪&quot;);</span><br><span class="line">        map.put(&quot;虹猫&quot;,&quot;蓝兔&quot;);</span><br><span class="line"></span><br><span class="line">        //3.通过键找值</span><br><span class="line">        //3.1 把键获取放入单列集合</span><br><span class="line">        Set&lt;String&gt; keys = map.keySet();</span><br><span class="line">        //3.2 遍历单列集合得到每一个键,增强for</span><br><span class="line">           -------------------------------------------------------------------</span><br><span class="line">        for (String key : keys) &#123;</span><br><span class="line">            //System.out.println(key);</span><br><span class="line">            //3.3 利用键获取每一个值</span><br><span class="line">            String value = map.get(key);</span><br><span class="line">            System.out.println(key + &quot; = &quot; + value);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">           -------------------------------------------------------------------</span><br><span class="line">        //lambda表达式遍历单列集合keys :匿名内部类</span><br><span class="line">       keys.forEach(new Consumer&lt;String&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void accept(String s) &#123;</span><br><span class="line">                System.out.println(s + &quot; = &quot; + map.get(s));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        //lambda表达式简化</span><br><span class="line">       keys.forEach(s -&gt; System.out.println(s + &quot; = &quot; + map.get(s)));</span><br><span class="line">       </span><br><span class="line">     -------------------------------------------------------------------  </span><br><span class="line">       //迭代器的形式遍历</span><br><span class="line">               Iterator&lt;String&gt; it = keys.iterator();</span><br><span class="line">        while (it.hasNext()) &#123;</span><br><span class="line">            String key =  it.next();</span><br><span class="line">            System.out.println(key + &quot; = &quot; + map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-键值对遍历"><a href="#2-键值对遍历" class="headerlink" title="2.键值对遍历"></a>2.键值对遍历</h3><p>获取每一对键值对，然后调用 get 方法获取键和值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package Maps;</span><br><span class="line"></span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">public class MapDemo3 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //遍历方式2</span><br><span class="line">        //1.创建Map集合对象</span><br><span class="line">        Map&lt;String, String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        //2.添加元素</span><br><span class="line">        map.put(&quot;喜羊羊&quot;,&quot;美羊羊&quot;);</span><br><span class="line">        map.put(&quot;大大怪&quot;,&quot;小小怪&quot;);</span><br><span class="line">        map.put(&quot;虹猫&quot;,&quot;蓝兔&quot;);</span><br><span class="line"></span><br><span class="line">        //3.通过键值对对象遍历</span><br><span class="line">        //3.1 通过一个方法获取所有键值对对象，返回一个set集合</span><br><span class="line">        Set&lt;Map.Entry&lt;String, String&gt;&gt; entries = map.entrySet();</span><br><span class="line">        //3.2 遍历entries集合找到所有键值对对象</span><br><span class="line">        for (Map.Entry&lt;String, String&gt; entry : entries) &#123;</span><br><span class="line">            String key = entry.getKey();</span><br><span class="line">            String value = entry.getValue();</span><br><span class="line">            System.out.println(key + &quot; = &quot; + value);</span><br><span class="line">        &#125;</span><br><span class="line">        //3.3迭代器遍历</span><br><span class="line">		Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator = entries.iterator();</span><br><span class="line">        while (iterator.hasNext()) &#123;</span><br><span class="line">            Map.Entry&lt;String, String&gt; entry = iterator.next();</span><br><span class="line">            String key = entry.getKey();</span><br><span class="line">            String value = entry.getValue();</span><br><span class="line">            System.out.println(key + &quot; = &quot; + value);</span><br><span class="line">        &#125;</span><br><span class="line">        //3.4lambda遍历</span><br><span class="line">        entries.forEach(new Consumer&lt;Map.Entry&lt;String, String&gt;&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void accept(Map.Entry&lt;String, String&gt; stringStringEntry) &#123;</span><br><span class="line">                String key = stringStringEntry.getKey();</span><br><span class="line">                String value = stringStringEntry.getValue();</span><br><span class="line">                System.out.println(key + &quot; = &quot; + value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        //3.4简化</span><br><span class="line">        -------------------------------------------------------------------</span><br><span class="line">        entries.forEach(stringStringEntry -&gt; &#123;</span><br><span class="line">            String key = stringStringEntry.getKey();</span><br><span class="line">            String value = stringStringEntry.getValue();</span><br><span class="line">            System.out.println(key + &quot; = &quot; + value);</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-Lambda-表达式遍历键值对-底层第二种遍历"><a href="#3-Lambda-表达式遍历键值对-底层第二种遍历" class="headerlink" title="3. Lambda 表达式遍历键值对(底层第二种遍历)"></a>3. Lambda 表达式遍历键值对(底层第二种遍历)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package Maps;</span><br><span class="line"></span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.function.BiConsumer;</span><br><span class="line"></span><br><span class="line">public class MapDemo4 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //遍历方式3</span><br><span class="line">        //1.创建Map集合对象</span><br><span class="line">        Map&lt;String, String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        //2.添加元素</span><br><span class="line">        map.put(&quot;鲁迅&quot;,&quot;这句话是我说的&quot;);</span><br><span class="line">        map.put(&quot;曹操&quot;,&quot;不可能，绝对不可能&quot;);</span><br><span class="line">        map.put(&quot;刘备&quot;,&quot;接着奏乐，接着舞&quot;);</span><br><span class="line">        map.put(&quot;张飞&quot;,&quot;我一枪挑了大哥！&quot;);</span><br><span class="line"></span><br><span class="line">        //3.利用lambda表达式进行遍历</span><br><span class="line">/*  map.forEach(new BiConsumer&lt;String, String&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void accept(String key, String value) &#123;</span><br><span class="line">                System.out.println(key + &quot;=&quot; + value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);*/</span><br><span class="line">        map.forEach((key, value) -&gt; System.out.println(key + &quot;=&quot; + value));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="12-3HashMap"><a href="#12-3HashMap" class="headerlink" title="12.3HashMap"></a>12.3HashMap</h2><h3 id="1-HashMap的创建"><a href="#1-HashMap的创建" class="headerlink" title="1.HashMap的创建"></a>1.HashMap的创建</h3><pre><code>    HashMap 是 Map 的一个实现类。
    HashMap 中无额外方法，直接使用 Map 中的方法即可。
    HashMap 的特点由键决定：无序、不重复、无索引。
    HashMap 和 HashSet 在底层都是哈希表实现的：数组 + 链表 + 红黑树。
</code></pre>
<p> 1.在存入数据时，HashMap 是以键为准的，和值无关。它会利用键计算出哈希值，存入哈希表中。</p>
<p> 2.如果碰到已经存放元素的位置，还是根据键的属性值来判断。</p>
<p> 3.如果新元素的键和旧元素一模一样，直接覆盖之。</p>
<p>4.如果新元素的键和旧的不一样，直接挂在旧元素下面，形成链表。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当链表的长度超过8 &amp; 数组长度&gt;=64时，链表自动转成红黑树。</span><br><span class="line"></span><br><span class="line">        根据底层结构可知，HashMap 底层存储和值没有任何关系，其依赖 hashCode() 方法和 equals() 方法保证键的唯一，如果键存储的是自定义对象，一定要重写这两个方法；但如果值存储的是自定义对象，那就不需要重写，存储和值无关。</span><br></pre></td></tr></table></figure>

<h2 id="12-4LinkedHashMap"><a href="#12-4LinkedHashMap" class="headerlink" title="12.4LinkedHashMap"></a>12.4LinkedHashMap</h2><p><img src="https://pic.imgdb.cn/item/672b3c08d29ded1a8cd7a24f.png" alt="17"></p>
<h2 id="12-5TreeMap"><a href="#12-5TreeMap" class="headerlink" title="12.5TreeMap"></a>12.5TreeMap</h2><h3 id="1-TreeMap特点"><a href="#1-TreeMap特点" class="headerlink" title="1.TreeMap特点"></a>1.TreeMap特点</h3><p>TreeMap 和 TreeSet 底层原理一样，都是红黑树结构的。<br>        TreeMap 的特性由键决定：不重复、无索引、可排序。<br>        TreeMap 的排序是对键的排序，默认按照键的从小到大排序（字符串就是字典顺序），也可以按照自己规定的排序规则排序，规定方式和 TreeSet 别无二致。</p>
<h3 id="2-TreeMap集合排序两种方式"><a href="#2-TreeMap集合排序两种方式" class="headerlink" title="2.TreeMap集合排序两种方式"></a>2.TreeMap集合排序两种方式</h3><p>实现 Comparable 接口，指定比较规则。<br>创建集合时传入 Comparator 比较器对象，指定比较规则。</p>
<h3 id="3-两种方式比较"><a href="#3-两种方式比较" class="headerlink" title="3.两种方式比较:"></a>3.两种方式比较:</h3><p>适用场景不同：<br>Comparable 适用于当你拥有键类型的源码并且希望该类型总是遵循相同的排序规则时。<br>Comparator 更灵活，适合于你需要为同一个类型提供多种排序规则，或者你无法修改键类型源码的情况。<br>实现复杂度：<br>实现 Comparable 要求修改或创建新的类文件。<br>使用 Comparator 可以在创建 TreeMap 的时候直接指定，不需要改变现有类的结构。<br>可读性和维护性：<br>如果排序逻辑非常简单且通用，实现 Comparable 可能会使代码更加清晰。<br>复杂的排序逻辑或者多样的排序需求更适合用 Comparator，因为它可以更好地封装和复用这些逻辑</p>
<h1 id="13-Collections"><a href="#13-Collections" class="headerlink" title="13.Collections"></a>13.Collections</h1><p>Collections 是集合的工具类</p>
<p>下面前两个是常用API:</p>
<p><img src="https://pic.imgdb.cn/item/672b3c08d29ded1a8cd7a26d.png" alt="18"></p>
<h1 id="14-Stream流的思想"><a href="#14-Stream流的思想" class="headerlink" title="14.Stream流的思想"></a>14.Stream流的思想</h1><p><img src="https://pic.imgdb.cn/item/672b3c08d29ded1a8cd7a29b.png" alt="19"></p>
<h2 id="14-1-概述"><a href="#14-1-概述" class="headerlink" title="14.1 概述"></a>14.1 概述</h2><p>Stream流可以让你通过链式操作对集合中的元素进行过滤、映射、排序、组合等操作，这些操作都是惰性执行的，只有在终端操作（如forEach、collect等）被调用时才会触发实际计算。Stream流可以简化代码并提高代码的可读性，同时也可以让编译器更好地进行优化，提高代码的执行效率。</p>
<h2 id="14-2-常见方法"><a href="#14-2-常见方法" class="headerlink" title="14.2 常见方法"></a>14.2 常见方法</h2><p>Stream流的三类方法</p>
<ul>
<li>获取Stream流<ul>
<li>创建一条流水线并把数据放到流水线上准备进行操作</li>
</ul>
</li>
<li>中间方法<ul>
<li>流水线上的操作</li>
<li>一次操作完毕之后,还可以继续进行其他操作</li>
</ul>
</li>
<li>终结方法<ul>
<li>一个Stream流只能有一个终结方法</li>
<li>是流水线上的最后一个操作</li>
</ul>
</li>
</ul>
<h3 id="1-获取Stream的方式"><a href="#1-获取Stream的方式" class="headerlink" title="1.获取Stream的方式"></a>1.获取Stream的方式</h3><p><img src="https://pic.imgdb.cn/item/672b3c08d29ded1a8cd7a2d2.png" alt="20"></p>
<p>Stream流中的方法大多数都是函数式接口，因此可以用lambda表达式来简化开发</p>
<h3 id="2-中间方法"><a href="#2-中间方法" class="headerlink" title="2.中间方法"></a>2.中间方法</h3><p><img src="https://pic.imgdb.cn/item/672b3c08d29ded1a8cd7a22a.png" alt="21"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Demo05 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        Collections.addAll(list,&quot;1&quot;,&quot;2&quot;,&quot;3&quot;);</span><br><span class="line">//        list.stream().map(new Function&lt;String, Integer&gt;() &#123;</span><br><span class="line">//            @Override</span><br><span class="line">//            public Integer apply(String s) &#123;</span><br><span class="line">//                return Integer.parseInt(s);</span><br><span class="line">//            &#125;</span><br><span class="line">//        &#125;).forEach(s-&gt; System.out.println(s.getClass() + &quot; &quot; + s));</span><br><span class="line"> </span><br><span class="line">        //用lambda表达式后</span><br><span class="line">        list.stream()</span><br><span class="line">                .map(s -&gt; Integer.parseInt(s))</span><br><span class="line">                .forEach(s-&gt; System.out.println(s.getClass() + &quot; &quot; + s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">输出结果：</span><br><span class="line"> </span><br><span class="line">class java.lang.Integer  1</span><br><span class="line">class java.lang.Integer  2</span><br><span class="line">class java.lang.Integer  3</span><br></pre></td></tr></table></figure>



<h3 id="3-终结方法"><a href="#3-终结方法" class="headerlink" title="3.终结方法"></a>3.终结方法</h3><p><img src="https://pic.imgdb.cn/item/672b3da9d29ded1a8cd96866.png" alt="22"></p>
<p>案例如下:</p>
<h4 id="3-1toArray-终结方法"><a href="#3-1toArray-终结方法" class="headerlink" title="3.1toArray()终结方法:"></a>3.1toArray()终结方法:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Demo06 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        Collections.addAll(list,&quot;林俊杰&quot;,&quot;林忆莲&quot;,&quot;周杰伦&quot;,&quot;周兴哲&quot;);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        // toArray()          收集流中的数据，放到数组中</span><br><span class="line">        //Object[] arr1 = list.stream().toArray();</span><br><span class="line">        //System.out.println(Arrays.toString(arr1));</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        //IntFunction的泛型：具体要保存的数据类型</span><br><span class="line">        //apply的形参：流中的数据个数，要跟数组的长度保持一致</span><br><span class="line">        //apply的返回值：具体要保存的数据类型,这里需要指定values个数,不然会报错</span><br><span class="line">        String[] array = list.stream().toArray(new IntFunction&lt;String[]&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public String[] apply(int value) &#123;</span><br><span class="line">                return new String[value];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">输出结果：</span><br><span class="line"> </span><br><span class="line">[林俊杰, 林忆莲, 周杰伦, 周兴哲]</span><br></pre></td></tr></table></figure>

<h4 id="3-2-collect-Collector-collector"><a href="#3-2-collect-Collector-collector" class="headerlink" title="3.2 collect(Collector collector)"></a>3.2 collect(Collector collector)</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Demo07 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"> </span><br><span class="line">        /*</span><br><span class="line">            collect(Collector collector)            收集流中的数据，放到集合中 (List Set Map)</span><br><span class="line">            注意点：</span><br><span class="line">                如果我们要收集到Map集合当中，键不能重复，否则会报错</span><br><span class="line">       */</span><br><span class="line"> </span><br><span class="line">        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        Collections.addAll(list, &quot;张无忌-男-15&quot;, &quot;周芷若-女-14&quot;, &quot;赵敏-女-13&quot;, &quot;张强-男-20&quot;,</span><br><span class="line">                &quot;张三丰-男-100&quot;, &quot;张翠山-男-40&quot;, &quot;张良-男-35&quot;, &quot;王二麻子-男-37&quot;, &quot;谢广坤-男-41&quot;);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        //收集List集合当中</span><br><span class="line">        //需求：</span><br><span class="line">        //我要把所有的男性收集起来</span><br><span class="line">        List&lt;String&gt; newList1 = list.stream()</span><br><span class="line">                .filter(s -&gt; &quot;男&quot;.equals(s.split(&quot;-&quot;)[1]))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        //System.out.println(newList1);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        //收集Set集合当中</span><br><span class="line">        //需求：</span><br><span class="line">        //我要把所有的男性收集起来</span><br><span class="line">        Set&lt;String&gt; newList2 = list.stream().filter(s -&gt; &quot;男&quot;.equals(s.split(&quot;-&quot;)[1]))</span><br><span class="line">                .collect(Collectors.toSet());</span><br><span class="line">        //System.out.println(newList2);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        //收集Map集合当中</span><br><span class="line">        //谁作为键,谁作为值.</span><br><span class="line">        //我要把所有的男性收集起来</span><br><span class="line">        //键：姓名。 值：年龄</span><br><span class="line">        Map&lt;String, Integer&gt; map = list.stream()</span><br><span class="line">                .filter(s -&gt; &quot;男&quot;.equals(s.split(&quot;-&quot;)[1]))</span><br><span class="line">                /*</span><br><span class="line">                 *   toMap : 参数一表示键的生成规则</span><br><span class="line">                 *           参数二表示值的生成规则</span><br><span class="line">                 *</span><br><span class="line">                 * 参数一：</span><br><span class="line">                 *       Function泛型一：表示流中每一个数据的类型</span><br><span class="line">                 *               泛型二：表示Map集合中键的数据类型</span><br><span class="line">                 *</span><br><span class="line">                 *        方法apply形参：依次表示流里面的每一个数据</span><br><span class="line">                 *               方法体：生成键的代码</span><br><span class="line">                 *               返回值：已经生成的键</span><br><span class="line">                 *</span><br><span class="line">                 *</span><br><span class="line">                 * 参数二：</span><br><span class="line">                 *        Function泛型一：表示流中每一个数据的类型</span><br><span class="line">                 *                泛型二：表示Map集合中值的数据类型</span><br><span class="line">                 *</span><br><span class="line">                 *       方法apply形参：依次表示流里面的每一个数据</span><br><span class="line">                 *               方法体：生成值的代码</span><br><span class="line">                 *               返回值：已经生成的值</span><br><span class="line">                 *</span><br><span class="line">                 * */</span><br><span class="line">                .collect(Collectors.toMap(new Function&lt;String, String&gt;() &#123;</span><br><span class="line">                                              @Override</span><br><span class="line">                                              public String apply(String s) &#123;</span><br><span class="line">                                                  //张无忌-男-15</span><br><span class="line">                                                  return s.split(&quot;-&quot;)[0];</span><br><span class="line">                                              &#125;</span><br><span class="line">                                          &#125;,</span><br><span class="line">                        new Function&lt;String, Integer&gt;() &#123;</span><br><span class="line">                            @Override</span><br><span class="line">                            public Integer apply(String s) &#123;</span><br><span class="line">                                return Integer.parseInt(s.split(&quot;-&quot;)[2]);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;));</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        Map&lt;String, Integer&gt; map2 = list.stream()</span><br><span class="line">                .filter(s -&gt; &quot;男&quot;.equals(s.split(&quot;-&quot;)[1]))</span><br><span class="line">                .collect(Collectors.toMap(</span><br><span class="line">                        s -&gt; s.split(&quot;-&quot;)[0],</span><br><span class="line">                        s -&gt; Integer.parseInt(s.split(&quot;-&quot;)[2])));</span><br><span class="line"> </span><br><span class="line">        System.out.println(map2);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="15-方法引用"><a href="#15-方法引用" class="headerlink" title="15.方法引用"></a>15.方法引用</h1><p>(简化lambda表达式)</p>
<p>1.什么是方法引用?<br>把已经存在的方法拿过来用，当做函数式接口中抽象方法的方法体<br>2.方法引用时要注意什么?</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">需要有函数式接口</span><br><span class="line">被引用方法必须已经存在</span><br><span class="line">被引用方法的形参和返回值需要跟抽象方法保持一致</span><br><span class="line">被引用方法的功能要满足当前的需求</span><br></pre></td></tr></table></figure>

<h4 id="1-引用静态方法"><a href="#1-引用静态方法" class="headerlink" title="1.引用静态方法"></a>1.引用静态方法</h4><p>类名::静态方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Integer::parseInt</span><br></pre></td></tr></table></figure>

<h4 id="2-引用成员方法"><a href="#2-引用成员方法" class="headerlink" title="2.引用成员方法"></a>2.引用成员方法</h4><p>对象::成员方法</p>
<p> 其他类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">其他类对象::方法名</span><br></pre></td></tr></table></figure>

<p>本类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>::方法名</span><br></pre></td></tr></table></figure>

<p>父类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="built_in">super</span>::方法名</span><br></pre></td></tr></table></figure>

<h4 id="3-使用类名引用成员方法"><a href="#3-使用类名引用成员方法" class="headerlink" title="3.使用类名引用成员方法"></a>3.使用类名引用成员方法</h4><p>类名::成员方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String::substring</span><br></pre></td></tr></table></figure>

<p>后续补充</p>
<h1 id="16-IO流"><a href="#16-IO流" class="headerlink" title="16.IO流"></a>16.IO流</h1><h2 id="1-io流的分类"><a href="#1-io流的分类" class="headerlink" title="1.io流的分类"></a>1.io流的分类</h2><p><img src="https://pic.imgdb.cn/item/672b3c16d29ded1a8cd7ae90.png" alt="26"></p>
<p>注意，纯文本文件指的是：Windows 自带的记事本打开能读懂的文件，比如：txt、md、xml、lrc 等，它们可以用字符流的方式处理。而 docx、xls 等文件不是纯文本文件，只能用字节流的方式处理。</p>
<h2 id="2-io流的体系结构"><a href="#2-io流的体系结构" class="headerlink" title="2.io流的体系结构"></a>2.io流的体系结构</h2><p><img src="https://pic.imgdb.cn/item/672b3c16d29ded1a8cd7ae4e.png" alt="27"></p>
<p><img src="https://pic.imgdb.cn/item/672b3c1bd29ded1a8cd7b2c3.png" alt="28"></p>
<h2 id="3-FileOutputStream-字节流"><a href="#3-FileOutputStream-字节流" class="headerlink" title="3.FileOutputStream(字节流)"></a>3.FileOutputStream(字节流)</h2><p>FileOutputStream 是操作本地文件的字节输出流，可以把程序中的数据写到本地文件中。</p>
<p>① 创建字节输出流对象。<br>② 写数据。<br>③ 释放资源。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package IOByteStream;</span><br><span class="line"></span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class ByteStreamDemo1 &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        /*</span><br><span class="line">            演示：字节输出流FileOutputStream</span><br><span class="line">            需求：写出一段文字到本地文件中（写出）</span><br><span class="line">            实现步骤：创建对象、写出数据、释放资源</span><br><span class="line">         */</span><br><span class="line"></span><br><span class="line">        //1.创建对象</span><br><span class="line">        FileOutputStream fos = new FileOutputStream(&quot;D:\\IdeaProjects\\HelloWord\\src\\IOByteStream\\a.txt&quot;);</span><br><span class="line"></span><br><span class="line">        //2.写出数据</span><br><span class="line">        fos.write(97);</span><br><span class="line"></span><br><span class="line">        //3.释放资源</span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 在输出到文件的过程中存在诸多细节：</p>
<p>1.创建字节输出流对象时，参数可以是字符串表示的路径，也可以是 File 对象。<br>2.如果参数中的文件不存在会创建一个新的文件，但是一定要保证这个文件的父级路径是存在的。<br>3.如果文件已存在，会先清空这个文件，再写入。<br>4.write 方法的参数是整数，但是实际上写到本地文件中的是整数在ASCII上对应的字符，97 –&gt; a。<br>5.每次使用完流之后，都要释放资源。</p>
<h3 id="3-1-FileOutputStream-写数据的3种方式"><a href="#3-1-FileOutputStream-写数据的3种方式" class="headerlink" title="3.1 FileOutputStream 写数据的3种方式"></a>3.1 FileOutputStream 写数据的3种方式</h3><p><img src="https://pic.imgdb.cn/item/672b3c1bd29ded1a8cd7b2d1.png" alt="29"></p>
<h3 id="3-2换行写"><a href="#3-2换行写" class="headerlink" title="3.2换行写"></a>3.2换行写</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package IOByteStream;</span><br><span class="line"></span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class ByteStreamDemo3 &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        /*</span><br><span class="line">            换行写</span><br><span class="line">            Windows换行是 \r\n</span><br><span class="line">            Java中可以写 \r \n 任何一个作为换行符，在底层可以自动补全</span><br><span class="line"></span><br><span class="line">            续写</span><br><span class="line">         */</span><br><span class="line"></span><br><span class="line">        //1.创建对象</span><br><span class="line">        FileOutputStream fos = new FileOutputStream(&quot;D:\\IdeaProjects\\HelloWord\\src\\IOByteStream\\a.txt&quot;);</span><br><span class="line"></span><br><span class="line">        //2.写出数据</span><br><span class="line">        //kankelaoyezuishuai</span><br><span class="line">        String str1 = &quot;kankelaoyezuishuai&quot;;</span><br><span class="line">        byte[] bytes1 = str1.getBytes();</span><br><span class="line">        fos.write(bytes1);</span><br><span class="line"></span><br><span class="line">        String br = &quot;\r\n&quot;;</span><br><span class="line">        byte[] bytes2 = br.getBytes();</span><br><span class="line">        fos.write(bytes2);</span><br><span class="line"></span><br><span class="line">        String str2 = &quot;666&quot;;</span><br><span class="line">        byte[] bytes3 = str2.getBytes();</span><br><span class="line">        fos.write(bytes3);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //3.释放资源</span><br><span class="line">        fos.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3续写"><a href="#3-3续写" class="headerlink" title="3.3续写"></a>3.3续写</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package IOByteStream;</span><br><span class="line"></span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class ByteStreamDemo4 &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        /*</span><br><span class="line">            续写开关 boolean append</span><br><span class="line">            在创建对象时,这个变量如果是true,文件就不会清空，可以续写；如果是false，文件就会被覆盖</span><br><span class="line">         */</span><br><span class="line"></span><br><span class="line">        //1.创建对象</span><br><span class="line">        FileOutputStream fos = new FileOutputStream(&quot;D:\\IdeaProjects\\HelloWord\\src\\IOByteStream\\a.txt&quot;,true);</span><br><span class="line"></span><br><span class="line">        //2.写出数据</span><br><span class="line">        //kankelaoyezuishuai</span><br><span class="line">        String str1 = &quot;kankelaoyezuishuai&quot;;</span><br><span class="line">        byte[] bytes1 = str1.getBytes();</span><br><span class="line">        fos.write(bytes1);</span><br><span class="line">        </span><br><span class="line">        //3.释放资源</span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-FileInputStream"><a href="#4-FileInputStream" class="headerlink" title="4.FileInputStream"></a>4.FileInputStream</h2><p> FileInputStream 字节输入流可以操作本地文件，把里面的数据读取到程序中来。<br>书写步骤：<br>    ① 创建字节输入流对象。<br>    ② 读数据。<br>    ③ 释放资源。</p>
<h3 id="4-1-FileInputStream-循环读取"><a href="#4-1-FileInputStream-循环读取" class="headerlink" title="4.1 FileInputStream 循环读取"></a>4.1 FileInputStream 循环读取</h3><p>由于 read 方法每次只能读取一个字节，所以我们要学习循环读取，这样才能读完一个文件中所有的内容。<br>定义一个变量 b ，用来存储读到的每一个字符，然后用一个 while 循环打印每一个字符，循环条件用 read() 方法赋值给 b，每进行一次这个赋值，读取字符的“指针”就前进一步，循环直到 read() 方法返回 -1，此时意味着读到了文件尾，循环结束。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package IOByteStream;</span><br><span class="line"></span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class ByteStreamDemo6 &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        /*</span><br><span class="line">            字节输入流循环读取</span><br><span class="line">         */</span><br><span class="line"></span><br><span class="line">        //1.创建对象</span><br><span class="line">        FileInputStream fis = new FileInputStream(&quot;D:\\IdeaProjects\\HelloWord\\src\\IOByteStream\\a.txt&quot;);</span><br><span class="line"></span><br><span class="line">        //2.循环读取</span><br><span class="line">        int b;</span><br><span class="line">        while((b = fis.read()) != -1) &#123;</span><br><span class="line">            System.out.print((char)b);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //3.释放资源</span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2文件拷贝"><a href="#4-2文件拷贝" class="headerlink" title="4.2文件拷贝"></a>4.2文件拷贝</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package IOByteStream;</span><br><span class="line"></span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class ByteStreamDemo7 &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        /*</span><br><span class="line">            文件拷贝</span><br><span class="line">            把D:\IdeaProjects\HelloWord\src\Files\beCopied拷贝到当前模块下</span><br><span class="line"></span><br><span class="line">        */</span><br><span class="line"></span><br><span class="line">        //1.创建对象</span><br><span class="line">        FileInputStream fis = new FileInputStream(&quot;D:\\IdeaProjects\\HelloWord\\src\\Files\\beCopied&quot;);</span><br><span class="line">        FileOutputStream fos = new FileOutputStream(&quot;D:\\IdeaProjects\\HelloWord\\src\\IOByteStream\\Copy.txt&quot;);</span><br><span class="line"></span><br><span class="line">        //2.拷贝</span><br><span class="line">        //核心思想：边读边写</span><br><span class="line">        int b;</span><br><span class="line">        while((b = fis.read()) != -1) &#123;</span><br><span class="line">            fos.write(b);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //3.释放资源</span><br><span class="line">        //规则：先开的流最后再关闭</span><br><span class="line">        fos.close();</span><br><span class="line">        fis.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>文件拷贝存在一个很严肃的问题，如果拷贝的文件过大，速度会不会有影响？会的，速度非常慢。因为 FileInputStream 在拷贝时，一次只读写一个字节，有多少个字节，就要循环多少次。<br>        如果想要提高拷贝的速度，就需要一次读取多个字节，它也有相关的方法，看下面的表格：<br><img src="https://pic.imgdb.cn/item/672b3c1bd29ded1a8cd7b2f4.png" alt="30"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package IOByteStream;</span><br><span class="line"></span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class ByteStreamDemo9 &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        /*</span><br><span class="line">            &quot;D:\\IdeaProjects\\HelloWord\\src\\Files\\beCopied&quot;拷贝到&quot;D:\\IdeaProjects\\HelloWord\\src\\IOByteStream\\Copy.txt&quot;</span><br><span class="line">         */</span><br><span class="line"></span><br><span class="line">        long l1 = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        //1.创建IO流</span><br><span class="line">        FileInputStream fis = new FileInputStream(&quot;D:\\IdeaProjects\\HelloWord\\src\\Files\\beCopied&quot;);</span><br><span class="line">        FileOutputStream fos = new FileOutputStream(&quot;D:\\IdeaProjects\\HelloWord\\src\\IOByteStream\\Copy.txt&quot;);</span><br><span class="line"></span><br><span class="line">        //2.一次读取多个字节的数据</span><br><span class="line">        int len;</span><br><span class="line">        byte[] bytes = new byte[1024 * 1024 * 5];</span><br><span class="line">        while((len = fis.read(bytes)) != -1) &#123;</span><br><span class="line">            fos.write(bytes,0, len);            //将bytes[] 数组中 0索引开始 len 长度的数据写入文件</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //3.关闭IO流</span><br><span class="line">        fis.close();</span><br><span class="line">        fos.close();</span><br><span class="line"></span><br><span class="line">        long l2 = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(l2 - l1);            //用了2毫秒</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="17-字符集"><a href="#17-字符集" class="headerlink" title="17.字符集"></a>17.字符集</h1><p>一、常见的字符集</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. GB2312 字符集：1980年发布，1981年5月1日实施的简体中文汉字编码标准，收录7445个图形字符，其中包括6763个简体汉字。</span><br><span class="line">2. BIG5 字符集：台湾地区繁体中文标准字符集，共收录13053个中文汉字，1984年实施。</span><br><span class="line">3. GBK 字符集：2000年3月17日发布，收录21003个汉字，包含国家标准 GB13000-1 中的全部中日韩汉字，和 BIG5 编码中的所有汉字。在 Windows 系统中默认使用的字符集就是 GBK。GB 代表国标，K 代表扩展。在微软系统中起的名字叫 ANSI 。</span><br><span class="line">4. Unicode 字符集：国际标准字符集，它将世界各种语言的每个字符定义一个唯一的编码，以满足跨语言、跨平台的文本信息转换。</span><br></pre></td></tr></table></figure>

<img src="D:\面试文档\assets\31.jpg" alt="31" style="zoom: 67%;" />

<p>二、计算机的 GBK 存储规则（英文）</p>
<p>​    GBK 编码是完全向下兼容 ASCII 码的。英文字母用一个字节来存储，完全兼容 ASCII 。在存储字符时，不足8位在前面补0。</p>
<p><img src="https://pic.imgdb.cn/item/672b3c1bd29ded1a8cd7b2b2.png" alt="32"></p>
<p>三、计算机的 GBK 存储规则（汉字）<br>        一个汉字的长度是 2 个字节（16 bit）。第一个字节被称为高位字节，第二个字节被称为低位字节。高位字节的二进制一定以1开头，转成十进制后是一个负数。字节码的二进制格式在存储到计算机中时，不需要变动。计算机底层以编码最高位是 0 还是 1 来区分中文字符和英文字符<br><img src="https://pic.imgdb.cn/item/672b3c20d29ded1a8cd7b7db.png" alt="33"></p>
<p>四、Unicode 字符集</p>
<p>​    Unicode 字符集是统一码联盟发布的一个统一字符集，包含了世界上大部分国家的文字字符。Unicode 在编码时，有多种编码方案。早前有 UTF-16、UTF-32 等编码方案，后都已废弃。后来出现了 UTF-8 编码规则，它是一种针对 Unicode 字符集的可变长度编码规则，它规定一个字符用 1~4 个字节保存。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UTF-8 规定，如果是 ASCII 码中有的字符，就用 1 个字节存储；如果是拉丁文、希伯来文等文字，用 2 个字节存储；如果中日韩文字、东南亚文字、中东文字，用 3 个字节存储；其他语言，用 4 个字节存储。四种编码的数字补充格式如下：</span><br><span class="line">1.Unicode字符集的UTF-8编码格式</span><br><span class="line">一个英文占一个字节，二进制第一位是0，转成十进制是正数</span><br><span class="line"></span><br><span class="line">一个中文占三个字节，二进制第一位是1，第一个字节转成十进制是负数</span><br></pre></td></tr></table></figure>

<p>UTF-8解码:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. **识别字节顺序和长度**：</span><br><span class="line">   - 对于UTF-8编码，每个字符根据其Unicode码点范围使用不同数量的字节进行编码。</span><br><span class="line">     - 单字节：U+0000至U+007F，编码为`0xxxxxxx`</span><br><span class="line">     - 双字节：U+0080至U+07FF，编码为`110xxxxx 10xxxxxx`</span><br><span class="line">     - 三字节：U+0800至U+FFFF，编码为`1110xxxx 10xxxxxx 10xxxxxx`</span><br><span class="line">     - 四字节：U+10000至U+10FFFF，编码为`11110xxx 10xxxxxx 10xxxxxx 10xxxxxx`</span><br><span class="line">2. **解码过程**：</span><br><span class="line">   - 遍历UTF-8字符串的每个字节。</span><br><span class="line">   - 根据首位的1的数量确定后续字节的数量和模式。</span><br><span class="line">   - 分别从每个字节中提取有效位并拼接起来，形成最终的Unicode码点</span><br><span class="line">eg:</span><br><span class="line">UTF-8编码1110 1001 1010 0011 1001 1110  将1.中的xx取出来得到 1001 1000 1101 1110就是对应unicode编码</span><br></pre></td></tr></table></figure>

<h1 id="18-字符流"><a href="#18-字符流" class="headerlink" title="18.字符流"></a>18.字符流</h1><p>什么是字符流?</p>
<p> 字符流的底层就是字符流+字符集，它能实现在读取时，碰到英文字母，还按 1 个字节读取，碰到汉字时，则按多个字节读取（UTF-8 是 3 个字节，GBK 是 2 个字节）。因此，字符流用于纯文本场景的数据输入和输出。</p>
<h2 id="18-1Reader-——-字符输入流"><a href="#18-1Reader-——-字符输入流" class="headerlink" title="18.1Reader —— 字符输入流"></a>18.1Reader —— 字符输入流</h2><pre><code>Reader 是字符输入流的抽象总类，它不能直接创建对象。但是有 FileReader 继承 Reader，它可以实现对本地文件的字符输入。
FileReader 的使用步骤如下：
</code></pre>
<p><img src="https://pic.imgdb.cn/item/672b3c20d29ded1a8cd7b7ea.png" alt="34"></p>
<p><img src="https://pic.imgdb.cn/item/672b3c20d29ded1a8cd7b80c.png" alt="35"></p>
<h3 id="1-read-空参读取："><a href="#1-read-空参读取：" class="headerlink" title="1.read() 空参读取："></a>1.read() 空参读取：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package IOCharStream;</span><br><span class="line"></span><br><span class="line">import java.io.FileReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class CharStreamDemo1 &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        /*</span><br><span class="line">            字符输入流的使用</span><br><span class="line">         */</span><br><span class="line"></span><br><span class="line">        //1.创建对象</span><br><span class="line">        FileReader fr = new FileReader(&quot;D:\\IdeaProjects\\HelloWord\\src\\IOCharStream\\hhh.txt&quot;);</span><br><span class="line"></span><br><span class="line">        //2.读取数据 read() 空参</span><br><span class="line">        int ch;</span><br><span class="line">        while((ch = fr.read()) != -1)&#123;</span><br><span class="line">            System.out.print((char)ch);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //read() 细节：</span><br><span class="line">        //1.默认一个字节一个字节读取，但是遇到中文会一次读 3 个字节（默认UTF-8）</span><br><span class="line">        //2.该方法读取的字符会将二进制转成十进制，这个十进制也表示在字符集上的数字</span><br><span class="line">        //3.如果想看中文汉字，直接将这些十进制数据强转即可</span><br><span class="line"></span><br><span class="line">        //3.释放资源</span><br><span class="line">        fr.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-带参-read-方法详解："><a href="#2-带参-read-方法详解：" class="headerlink" title="2.带参 read() 方法详解："></a>2.带参 read() 方法详解：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package IOCharStream;</span><br><span class="line"></span><br><span class="line">import java.io.FileReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class CharStreamDemo2 &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        /*</span><br><span class="line">            public int read(char[]  buffer)     //一次读取多个数据，参数为char类型数组，返回值为读取到的字符个数</span><br><span class="line">         */</span><br><span class="line"></span><br><span class="line">        //1.创建对象</span><br><span class="line">        FileReader fr = new FileReader(&quot;D:\\IdeaProjects\\HelloWord\\src\\IOCharStream\\hhh.txt&quot;);</span><br><span class="line"></span><br><span class="line">        //2.读取数据</span><br><span class="line">        char[] chars = new char[2];         //一次读两个字符</span><br><span class="line">        int len;</span><br><span class="line">        //read(chars):读取数据，解码，强制类型转换，三合一，将强转之后的字符放入数组中</span><br><span class="line">        //带参read = 空参read + 强转</span><br><span class="line">        while((len = fr.read(chars)) != -1)&#123;</span><br><span class="line">            //把数组中的数据变成字符串再打印</span><br><span class="line">            System.out.print(new String(chars, 0 , len));           //转字符串细节：从0索引到len索引转</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //3.释放资源</span><br><span class="line">        fr.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="18-2Writer-——-字符输出流"><a href="#18-2Writer-——-字符输出流" class="headerlink" title="18.2Writer —— 字符输出流"></a>18.2Writer —— 字符输出流</h2><p>Writer 是字符输出流的抽象总类，它不能直接创建对象。但有 FileWriter 继承自它，可以实现对本地文件数据的输出。<br>FileWriter 的使用方法如下：</p>
<h3 id="①利用构造方法生成对象。"><a href="#①利用构造方法生成对象。" class="headerlink" title="①利用构造方法生成对象。"></a>①利用构造方法生成对象。</h3><p><img src="https://pic.imgdb.cn/item/672b3c20d29ded1a8cd7b81f.png" alt="36"></p>
<p>细节1：参数是字符串表示的路径或者 File 对象表示的路径都可以。<br>细节2：如果文件不存在，会自动创建一个新的文件，但要保证父级路径是存在的。<br>细节3：如果文件已存在，默认覆写文件，如果不想清空可以打开续写开关。</p>
<h3 id="②-调用成员方法写出。"><a href="#②-调用成员方法写出。" class="headerlink" title="② 调用成员方法写出。"></a>② 调用成员方法写出。</h3><p>![1730879855873](D:\新建文件夹\WeChat Files\wxid_cqgchisdtjwi22\FileStorage\Temp\1730879855873.jpg)</p>
<p>细节：如果 write 方法的参数是一个整数，实际上写到本地文件中的是这个整数在字符集上对应的 char 字符。</p>
<p>③ 释放资源</p>
<p><img src="https://pic.imgdb.cn/item/672b3c20d29ded1a8cd7b7c9.png" alt="37"></p>
<h1 id="19-高级流"><a href="#19-高级流" class="headerlink" title="19.高级流"></a>19.高级流</h1><h2 id="19-1缓冲流体系"><a href="#19-1缓冲流体系" class="headerlink" title="19.1缓冲流体系"></a>19.1缓冲流体系</h2><p><img src="https://pic.imgdb.cn/item/672b3c26d29ded1a8cd7bce7.png" alt="38"></p>
<h3 id="1-字节缓冲流"><a href="#1-字节缓冲流" class="headerlink" title="1.字节缓冲流"></a>1.字节缓冲流</h3><p>字节缓冲流底层自带了一次可以读写 8192 长度的缓冲区。它的构造方法是将基本流通过一个方法进行包装，加入缓冲区。</p>
<p><img src="https://pic.imgdb.cn/item/672b3c26d29ded1a8cd7bcfc.png" alt="39"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">以下演示了如何利用字节缓冲流来拷贝一个文件：</span><br><span class="line">package BufferedStream;</span><br><span class="line"></span><br><span class="line">import java.io.*;</span><br><span class="line"></span><br><span class="line">public class BufferedStreamDemo1 &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        /*</span><br><span class="line">            字节缓冲流拷贝文件（一次读写一个字节）</span><br><span class="line">         */</span><br><span class="line"></span><br><span class="line">        //1.创建缓冲流对象</span><br><span class="line">        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;D:\\IdeaProjects\\HelloWord\\src\\BufferedStream\\a.txt&quot;));</span><br><span class="line">        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;D:\\IdeaProjects\\HelloWord\\src\\BufferedStream\\a_Copied.txt&quot;));</span><br><span class="line"></span><br><span class="line">        //2.循环读取并写入目的地</span><br><span class="line">        int b;</span><br><span class="line">        while((b = bis.read()) != -1)&#123;</span><br><span class="line">            bos.write(b);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //3.释放资源</span><br><span class="line">        bos.close();</span><br><span class="line">        bis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package BufferedStream;</span><br><span class="line"></span><br><span class="line">import java.io.*;</span><br><span class="line"></span><br><span class="line">public class BufferedStreamDemo2 &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        /*</span><br><span class="line">            字节缓冲流拷贝文件（一次读写一个字节数组）</span><br><span class="line">         */</span><br><span class="line"></span><br><span class="line">        //1.创建缓冲流对象</span><br><span class="line">        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;D:\\IdeaProjects\\HelloWord\\src\\BufferedStream\\a.txt&quot;));</span><br><span class="line">        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;D:\\IdeaProjects\\HelloWord\\src\\BufferedStream\\a_Copied.txt&quot;));</span><br><span class="line"></span><br><span class="line">        //2.字节数组</span><br><span class="line">        byte[] bytes = new byte[1024 * 1024 * 5];</span><br><span class="line">        int len;</span><br><span class="line">        while((len = bis.read(bytes)) != -1)&#123;</span><br><span class="line">            bos.write(bytes,0,len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //3.关闭流</span><br><span class="line">        bos.close();</span><br><span class="line">        bis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-字节缓冲流提高效率的底层原理"><a href="#2-字节缓冲流提高效率的底层原理" class="headerlink" title="2.字节缓冲流提高效率的底层原理"></a>2.字节缓冲流提高效率的底层原理</h3><p><img src="https://pic.imgdb.cn/item/672b3c26d29ded1a8cd7bd0a.png" alt="40"></p>
<p>可以看到，读写数据时，字节数据是在<strong>内存</strong>中的缓冲区进行倒手的，而内存的读写数据是非常非常快的，它的读写速度快到这个倒手的过程可以忽略不计，大大节省了数据与硬盘之间的交互时间。</p>
<h2 id="19-2字符缓冲流"><a href="#19-2字符缓冲流" class="headerlink" title="19.2字符缓冲流"></a>19.2字符缓冲流</h2><p><img src="https://pic.imgdb.cn/item/672b3c26d29ded1a8cd7bd2c.png" alt="41"></p>
<p>构造方法如下：</p>
<p><img src="https://pic.imgdb.cn/item/672b3c26d29ded1a8cd7bd38.png" alt="42"></p>
<p><img src="https://pic.imgdb.cn/item/672b3c28d29ded1a8cd7c05a.png" alt="43"></p>
<h3 id="1-字符缓冲输入流的用法："><a href="#1-字符缓冲输入流的用法：" class="headerlink" title="1.字符缓冲输入流的用法："></a>1.字符缓冲输入流的用法：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package BufferedStream;</span><br><span class="line"></span><br><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.FileReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class BufferedStreamDemo3 &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        /*</span><br><span class="line">            字符缓冲输入流</span><br><span class="line">         */</span><br><span class="line"></span><br><span class="line">        //1.创建字符缓冲输入流对象</span><br><span class="line">        BufferedReader br = new BufferedReader(new FileReader(&quot;D:\\IdeaProjects\\HelloWord\\src\\BufferedStream\\a.txt&quot;));</span><br><span class="line"></span><br><span class="line">        //2.一行一行读</span><br><span class="line">        String line;</span><br><span class="line">        while((line = br.readLine()) != null) &#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //3.释放资源</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-字符缓冲输出流的用法"><a href="#2-字符缓冲输出流的用法" class="headerlink" title="2.字符缓冲输出流的用法:"></a>2.字符缓冲输出流的用法:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package BufferedStream;</span><br><span class="line"></span><br><span class="line">import java.io.BufferedWriter;</span><br><span class="line">import java.io.FileWriter;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class BufferedStreamDemo5 &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        /*</span><br><span class="line">            字符缓冲输出流</span><br><span class="line">         */</span><br><span class="line"></span><br><span class="line">        //1.创建</span><br><span class="line">        BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;D:\\IdeaProjects\\HelloWord\\src\\BufferedStream\\b.txt&quot;));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //2.写出数据</span><br><span class="line">        bw.write(&quot;你嘴角上扬的样子，百度搜索不到&quot;);</span><br><span class="line">        bw.newLine();       								//跨平台换行</span><br><span class="line">        bw.write(&quot;以后如果我结婚了，你一定要来哦，没有新娘我会很尴尬&quot;);</span><br><span class="line">        bw.newLine();</span><br><span class="line"></span><br><span class="line">        //3.释放资源</span><br><span class="line">        bw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="19-3转换流"><a href="#19-3转换流" class="headerlink" title="19.3转换流"></a>19.3转换流</h2><h2 id="19-4序列化流和反序列化流"><a href="#19-4序列化流和反序列化流" class="headerlink" title="19.4序列化流和反序列化流"></a>19.4序列化流和反序列化流</h2>]]></content>
      <categories>
        <category>工作ing~</category>
      </categories>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/posts/16107.html</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>工作ing~</category>
      </categories>
      <tags>
        <tag>标签示例</tag>
      </tags>
  </entry>
  <entry>
    <title>逆水寒日常</title>
    <url>/posts/2281.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>逆水寒手游</category>
      </categories>
      <tags>
        <tag>CS</tag>
        <tag>密码币</tag>
        <tag>太极拔剑</tag>
      </tags>
  </entry>
  <entry>
    <title>暗藏玄机</title>
    <url>/posts/45351.html</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">
  <script id="hbeData" type="hbeData" data-hmacdigest="270ab4bc50c0c2d0f9ed761b1e6a2410fb75185325653c8363c034db38c4079a">b7ceb76c270f3503934243b777b7d095ad21e42370d3d1a7461ec33e7efff163</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-xray">
      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">oi!小鬼,又来视奸o.O?.</span>
      </label>
      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">
        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>
        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>
      </svg>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <tags>
        <tag>作为日记加密</tag>
      </tags>
  </entry>
  <entry>
    <title>如何解决精神上的内耗,完成自我的救赎</title>
    <url>/posts/37560.html</url>
    <content><![CDATA[<div align=center class="aspect-ratio">
    <iframe src="https://player.bilibili.com/player.html?aid=113187454193838&&page=1&as_wide=1&high_quality=1&danmaku=0" 
    scrolling="no" 
    border="0" 
    frameborder="no" 
    framespacing="0" 
    high_quality=1
    danmaku=1 
    allowfullscreen="true"> 
    </iframe>
</div>]]></content>
      <categories>
        <category>无脑发癫</category>
      </categories>
      <tags>
        <tag>颠颠的</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/js/console.js</url>
    <content><![CDATA[var now1 = new Date();

function createtime1() {
    var grt = new Date("09/30/2024 00:00:00"); //此处修改你的建站时间或者网站上线时间
    now1.setTime(now1.getTime() + 250);
    var days = (now1 - grt) / 1000 / 60 / 60 / 24;
    var dnum = Math.floor(days);

    var ascll = [
        `欢迎来到无名🥝の小家!`,
        `Future is now 🍭🍭🍭`,
        "小站已经苟活",
        dnum,
        "天啦!",
        "©2024 By wuming",
    ];

    setTimeout(
        console.log.bind(
            console,
            `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
            "color:#39c5bb",
            "",
            "color:#39c5bb",
            "color:#39c5bb",
            "",
            "color:#39c5bb",
            ""
        )
    );
}

createtime1();

function createtime2() {
    var ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为「大聪明」`, `Photo captured: `, ` 🤪 `];

    setTimeout(
        console.log.bind(
            console,
            `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}`,
            "color:white; background-color:#10bcc0",
            "",
            "",
            'background:url("") no-repeat;font-size:450%'
        )
    );

    setTimeout(console.log.bind(console, "%c WELCOME %c 欢迎光临，大聪明", "color:white; background-color:#23c682", ""));

    setTimeout(
        console.warn.bind(
            console,
            "%c ⚡ Powered by wuming🥝 %c 你正在访问无名🥝の小家",
            "color:white; background-color:#f0ad4e",
            ""
        )
    );

    setTimeout(console.log.bind(console, "%c W23-12 %c 系统监测到你已打开控制台", "color:white; background-color:#4f90d9", ""));
    setTimeout(
        console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中", "color:white; background-color:#d9534f", "")
    );
}
createtime2();

// 重写console方法
console.log = function () { };
console.error = function () { };
console.warn = function () { };]]></content>
  </entry>
  <entry>
    <title>分类</title>
    <url>/categories/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/css/custom.css</url>
    <content><![CDATA[/* 页脚与头图透明 */
#footer {
    background: transparent !important;
  }
  #page-header {
    background: transparent !important;
  }
  
  /* 白天模式遮罩透明 */
  #footer::before {
    background: transparent !important;
  }
  #page-header::before {
    background: transparent !important;
  }
  
  /* 夜间模式遮罩透明 */
  [data-theme="dark"] #footer::before {
    background: transparent !important;
  }
  [data-theme="dark"] #page-header::before {
    background: transparent !important;
  }
  /* 日间模式不生效 */
[data-theme="light"] #site-name,
[data-theme="light"] #site-title,
[data-theme="light"] #site-subtitle,
[data-theme="light"] #post-info {
  animation: none;
}
/* 夜间模式生效 */
[data-theme="dark"] #site-name,
[data-theme="dark"] #site-title {
  animation: light_15px 10s linear infinite;
}
[data-theme="dark"] #site-subtitle {
  animation: light_10px 10s linear infinite;
}
[data-theme="dark"] #post-info {
  animation: light_5px 10s linear infinite;
}
/* 关键帧描述 */
@keyframes light_15px {
  0% {
    text-shadow: #5636ed 0 0 15px;
  }
  12.5% {
    text-shadow: #11ee5e 0 0 15px;
  }
  25% {
    text-shadow: #f14747 0 0 15px;
  }
  37.5% {
    text-shadow: #f1a247 0 0 15px;
  }
  50% {
    text-shadow: #f1ee47 0 0 15px;
  }
  50% {
    text-shadow: #b347f1 0 0 15px;
  }
  62.5% {
    text-shadow: #002afa 0 0 15px;
  }
  75% {
    text-shadow: #ed709b 0 0 15px;
  }
  87.5% {
    text-shadow: #39c5bb 0 0 15px;
  }
  100% {
    text-shadow: #5636ed 0 0 15px;
  }
}

@keyframes light_10px {
  0% {
    text-shadow: #5636ed 0 0 10px;
  }
  12.5% {
    text-shadow: #11ee5e 0 0 10px;
  }
  25% {
    text-shadow: #f14747 0 0 10px;
  }
  37.5% {
    text-shadow: #f1a247 0 0 10px;
  }
  50% {
    text-shadow: #f1ee47 0 0 10px;
  }
  50% {
    text-shadow: #b347f1 0 0 10px;
  }
  62.5% {
    text-shadow: #002afa 0 0 10px;
  }
  75% {
    text-shadow: #ed709b 0 0 10px;
  }
  87.5% {
    text-shadow: #39c5bb 0 0 10px;
  }
  100% {
    text-shadow: #5636ed 0 0 10px;
  }
}

@keyframes light_5px {
  0% {
    text-shadow: #5636ed 0 0 5px;
  }
  12.5% {
    text-shadow: #11ee5e 0 0 5px;
  }
  25% {
    text-shadow: #f14747 0 0 5px;
  }
  37.5% {
    text-shadow: #f1a247 0 0 15px;
  }
  50% {
    text-shadow: #f1ee47 0 0 5px;
  }
  50% {
    text-shadow: #b347f1 0 0 5px;
  }
  62.5% {
    text-shadow: #002afa 0 0 5px;
  }
  75% {
    text-shadow: #ed709b 0 0 5px;
  }
  87.5% {
    text-shadow: #39c5bb 0 0 5px;
  }
  100% {
    text-shadow: #5636ed 0 0 5px;
  }
}

/* 背景宇宙星光  */
#universe{
    display: block;
    position: fixed;
    margin: 0;
    padding: 0;
    border: 0;
    outline: 0;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    /* 这个是调置顶的优先级的，-1在文章页下面，背景上面，个人推荐这种 */
    z-index: -1;
  }
  /* 侧边栏个人信息卡片动态渐变色 */
#aside-content > .card-widget.card-info {
  background: linear-gradient(
    -45deg,
    #e8d8b9,
    #eccec5,
    #a3e9eb,
    #bdbdf0,
    #eec1ea
  );
  box-shadow: 0 0 5px rgb(66, 68, 68);
  position: relative;
  background-size: 400% 400%;
  -webkit-animation: Gradient 10s ease infinite;
  -moz-animation: Gradient 10s ease infinite;
  animation: Gradient 10s ease infinite !important;
}
@-webkit-keyframes Gradient {
  0% {
    background-position: 0% 50%;
  }
  50% {
    background-position: 100% 50%;
  }
  100% {
    background-position: 0% 50%;
  }
}
@-moz-keyframes Gradient {
  0% {
    background-position: 0% 50%;
  }
  50% {
    background-position: 100% 50%;
  }
  100% {
    background-position: 0% 50%;
  }
}
@keyframes Gradient {
  0% {
    background-position: 0% 50%;
  }
  50% {
    background-position: 100% 50%;
  }
  100% {
    background-position: 0% 50%;
  }
}

/* 黑夜模式适配 */
[data-theme="dark"] #aside-content > .card-widget.card-info {
  background: #191919ee;
}

/* 个人信息Follow me按钮 */
#aside-content > .card-widget.card-info > #card-info-btn {
  background-color: #3eb8be;
  border-radius: 8px;
}
/* 侧边栏个人信息卡片动态渐变色 */
#aside-content > .card-widget.card-info {
    background: linear-gradient(
      -45deg,
      #e8d8b9,
      #eccec5,
      #a3e9eb,
      #bdbdf0,
      #eec1ea
    );
    box-shadow: 0 0 5px rgb(66, 68, 68);
    position: relative;
    background-size: 400% 400%;
    -webkit-animation: Gradient 10s ease infinite;
    -moz-animation: Gradient 10s ease infinite;
    animation: Gradient 10s ease infinite !important;
  }
  @-webkit-keyframes Gradient {
    0% {
      background-position: 0% 50%;
    }
    50% {
      background-position: 100% 50%;
    }
    100% {
      background-position: 0% 50%;
    }
  }
  @-moz-keyframes Gradient {
    0% {
      background-position: 0% 50%;
    }
    50% {
      background-position: 100% 50%;
    }
    100% {
      background-position: 0% 50%;
    }
  }
  @keyframes Gradient {
    0% {
      background-position: 0% 50%;
    }
    50% {
      background-position: 100% 50%;
    }
    100% {
      background-position: 0% 50%;
    }
  }
  
  /* 黑夜模式适配 */
  [data-theme="dark"] #aside-content > .card-widget.card-info {
    background: #191919ee;
  }
  
  /* 个人信息Follow me按钮 */
  #aside-content > .card-widget.card-info > #card-info-btn {
    background-color: #3eb8be;
    border-radius: 8px;
  }
  /*哔哩哔哩视频适配*/
.aspect-ratio {
  position: relative;
  width: 90%;
  height: auto;
  padding-bottom: 75%;
  margin: 3% auto;
  text-align: center;
}
.aspect-ratio iframe {
  position: absolute;
  width: 100%;
  height: 86%;
  left: 0;
  top: 0;
}

/* 头像呼吸灯 */
[data-theme="light"] .avatar-img {
  animation: huxi_light 4s ease-in-out infinite;
}
[data-theme="dark"] .avatar-img {
  animation: huxi_dark 4s ease-in-out infinite;
}
@keyframes huxi_light {
  0% {
    box-shadow: 0px 0px 1px 1px #e9f5fa;
  }
  50% {
    box-shadow: 0px 0px 5px 5px #e9f5fa;
  }
  100% {
    box-shadow: 0px 0px 1px 1px #e9f5fa;
  }
}
@keyframes huxi_dark {
  0% {
    box-shadow: 0px 0px 1px 1px #39c5bb;
  }
  50% {
    box-shadow: 0px 0px 5px 5px #39c5bb;
  }
  100% {
    box-shadow: 0px 0px 1px 1px #39c5bb;
  }
}


/* 帧率检测 */
#fps {
  position: fixed;
  /* 指定位置 */
  right: 10px;
  bottom: 10px;
  z-index: 1919810;
}
[data-theme="light"] #fps {
  background-color: rgba(255, 255, 255, 0.85);
  backdrop-filter: var(--backdrop-filter);
  padding: 4px;
  border-radius: 4px;
}
[data-theme="dark"] #fps {
  background-color: rgba(0, 0, 0, 0.72);
  backdrop-filter: var(--backdrop-filter);
  padding: 4px;
  border-radius: 4px;
}]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/js/fps.js</url>
    <content><![CDATA[if (window.localStorage.getItem("fpson") == undefined || window.localStorage.getItem("fpson") == "1") {
    var rAF = function () {
        return (
            window.requestAnimationFrame ||
            window.webkitRequestAnimationFrame ||
            function (callback) {
                window.setTimeout(callback, 1000 / 60);
            }
        );
    }();
    var frame = 0;
    var allFrameCount = 0;
    var lastTime = Date.now();
    var lastFameTime = Date.now();
    var loop = function () {
        var now = Date.now();
        var fs = (now - lastFameTime);
        var fps = Math.round(1000 / fs);

        lastFameTime = now;
        // 不置 0，在动画的开头及结尾记录此值的差值算出 FPS
        allFrameCount++;
        frame++;

        if (now > 1000 + lastTime) {
            var fps = Math.round((frame * 1000) / (now - lastTime));
            if (fps <= 5) {
                var kd = `<span style="color:#bd0000">卡成ppt🤢</span>`
            } else if (fps <= 15) {
                var kd = `<span style="color:red">电竞级帧率😖</span>`
            } else if (fps <= 25) {
                var kd = `<span style="color:orange">有点难受😨</span>`
            } else if (fps < 35) {
                var kd = `<span style="color:#9338e6">不太流畅🙄</span>`
            } else if (fps <= 45) {
                var kd = `<span style="color:#08b7e4">还不错哦😁</span>`
            } else {
                var kd = `<span style="color:#39c5bb">十分流畅🤣</span>`
            }
            document.getElementById("fps").innerHTML = `FPS:${fps} ${kd}`;
            frame = 0;
            lastTime = now;
        };

        rAF(loop);
    }

    loop();
} else {
    document.getElementById("fps").style = "display:none!important"
}]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/js/universe.js</url>
    <content><![CDATA[function dark() {window.requestAnimationFrame=window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame||window.msRequestAnimationFrame;var n,e,i,h,t=.05,s=document.getElementById("universe"),o=!0,a="180,184,240",r="226,225,142",d="226,225,224",c=[];function f(){n=window.innerWidth,e=window.innerHeight,i=.216*n,s.setAttribute("width",n),s.setAttribute("height",e)}function u(){h.clearRect(0,0,n,e);for(var t=c.length,i=0;i<t;i++){var s=c[i];s.move(),s.fadeIn(),s.fadeOut(),s.draw()}}function y(){this.reset=function(){this.giant=m(3),this.comet=!this.giant&&!o&&m(10),this.x=l(0,n-10),this.y=l(0,e),this.r=l(1.1,2.6),this.dx=l(t,6*t)+(this.comet+1-1)*t*l(50,120)+2*t,this.dy=-l(t,6*t)-(this.comet+1-1)*t*l(50,120),this.fadingOut=null,this.fadingIn=!0,this.opacity=0,this.opacityTresh=l(.2,1-.4*(this.comet+1-1)),this.do=l(5e-4,.002)+.001*(this.comet+1-1)},this.fadeIn=function(){this.fadingIn&&(this.fadingIn=!(this.opacity>this.opacityTresh),this.opacity+=this.do)},this.fadeOut=function(){this.fadingOut&&(this.fadingOut=!(this.opacity<0),this.opacity-=this.do/2,(this.x>n||this.y<0)&&(this.fadingOut=!1,this.reset()))},this.draw=function(){if(h.beginPath(),this.giant)h.fillStyle="rgba("+a+","+this.opacity+")",h.arc(this.x,this.y,2,0,2*Math.PI,!1);else if(this.comet){h.fillStyle="rgba("+d+","+this.opacity+")",h.arc(this.x,this.y,1.5,0,2*Math.PI,!1);for(var t=0;t<30;t++)h.fillStyle="rgba("+d+","+(this.opacity-this.opacity/20*t)+")",h.rect(this.x-this.dx/4*t,this.y-this.dy/4*t-2,2,2),h.fill()}else h.fillStyle="rgba("+r+","+this.opacity+")",h.rect(this.x,this.y,this.r,this.r);h.closePath(),h.fill()},this.move=function(){this.x+=this.dx,this.y+=this.dy,!1===this.fadingOut&&this.reset(),(this.x>n-n/4||this.y<0)&&(this.fadingOut=!0)},setTimeout(function(){o=!1},50)}function m(t){return Math.floor(1e3*Math.random())+1<10*t}function l(t,i){return Math.random()*(i-t)+t}f(),window.addEventListener("resize",f,!1),function(){h=s.getContext("2d");for(var t=0;t<i;t++)c[t]=new y,c[t].reset();u()}(),function t(){document.getElementsByTagName('html')[0].getAttribute('data-theme')=='dark'&&u(),window.requestAnimationFrame(t)}()};
dark()]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/js/runtime.js</url>
    <content><![CDATA[var now=new Date;function createtime(){now.setTime(now.getTime()+1e3);var e=new Date("09/30/2024 00:00:00"),t=Math.trunc(234e8+(now-e)/1e3*17),a=(t/1496e5).toFixed(6),o=new Date("10/18/2024 00:00:00"),n=(now-o)/1e3/60/60/24,r=Math.floor(n),i=(now-o)/1e3/60/60-24*r,s=Math.floor(i);1==String(s).length&&(s="0"+s);var d=(now-o)/1e3/60-1440*r-60*s,l=Math.floor(d);1==String(l).length&&(l="0"+l);var g=(now-o)/1e3-86400*r-3600*s-60*l,b=Math.round(g);1==String(b).length&&(b="0"+b);let c="";c=s<18&&s>=9?`<img class='boardsign' src='' title='什么时候能够实现财富自由呀~'><br> <div style="font-size:13px;font-weight:bold">本站居然运行了 ${r} 天 ${s} 小时 ${l} 分 ${b} 秒 <i id="heartbeat" class='fas fa-heartbeat'></i> <br> 旅行者 1 号当前距离地球 ${t} 千米，约为 ${a} 个天文单位 🚀</div>`:`<img class='boardsign' src='https://sourcebucket.s3.ladydaily.com/badge/F小屋-下班休息啦.svg' title='下班了就该开开心心地玩耍~'><br> <div style="font-size:13px;font-weight:bold">本站居然运行了 ${r} 天 ${s} 小时 ${l} 分 ${b} 秒 <i id="heartbeat" class='fas fa-heartbeat'></i> <br> 旅行者 1 号当前距离地球 ${t} 千米，约为 ${a} 个天文单位 🚀</div>`,document.getElementById("workboard")&&(document.getElementById("workboard").innerHTML=c)}setInterval((()=>{createtime()}),1e3);]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/js/title.js</url>
    <content><![CDATA[//动态标题
var OriginTitile = document.title;
var titleTime;
document.addEventListener('visibilitychange', function () {
  if (document.hidden) {
    //离开当前页面时标签显示内容
    document.title = '👀跑哪里去捏~';
    clearTimeout(titleTime);
  } else {
    //返回当前页面时标签显示内容
    document.title = '🐖抓到你啦嘻嘻～';
    //两秒后变回正常标题
    titleTime = setTimeout(function () {
      document.title = OriginTitile;
    }, 2000);
  }
});]]></content>
  </entry>
  <entry>
    <title>友情链接</title>
    <url>/link/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>説説</title>
    <url>/shuoshuo/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>文章分类</title>
    <url>/tags/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
