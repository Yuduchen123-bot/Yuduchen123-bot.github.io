<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MySql</title>
      <link href="/posts/16097.html"/>
      <url>/posts/16097.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-MySql"><a href="#1-MySql" class="headerlink" title="1.MySql"></a>1.MySql</h1><h2 id="1-1数据库的三范式是什么"><a href="#1-1数据库的三范式是什么" class="headerlink" title="1.1数据库的三范式是什么"></a>1.1<strong>数据库的三范式是什么</strong></h2><p>第一范式（1NF）：原子性（存储的数据应该具有“不可再分性”）</p><p>第二范式（2NF）：唯一性 (消除非主键部分依赖联合主键中的部分字段)</p><p>第三范式（3NF）：独立性，消除传递依赖(非主键值不依赖于另一个非主键值)</p><p>且三大范式是一级一级依赖的，第二范式建立在第一范式上，第三范式建立第一第二范式上。</p><h2 id="1-2MySql常用引擎：MYISAM、Innodb"><a href="#1-2MySql常用引擎：MYISAM、Innodb" class="headerlink" title="1.2MySql常用引擎：MYISAM、Innodb"></a>1.2MySql常用引擎：MYISAM、Innodb</h2><p>MYISAM：全表锁，拥有较高的执行速度，不支持事务，不支持外键，并发性能差，占用空间相对</p><p>较小，对事务完整性没有要求，以select、insert为主的应用基本上可以使用这引擎</p><p>Innodb:行级锁，提供了具有提交、回滚和崩溃回复能力的事务安全，支持自动增长列，支持外键</p><p>约束，并发能力强，占用空间是MYISAM的2.5倍，处理效率相对会差一些</p><h2 id="1-3InnoDB与MyISAM的区别"><a href="#1-3InnoDB与MyISAM的区别" class="headerlink" title="1.3InnoDB与MyISAM的区别"></a>1.3InnoDB与MyISAM的区别</h2><ol><li>InnoDB支持事务，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务，自动提交，</li></ol><p>这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务；</p><ol start="2"><li>InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败；</li><li>InnoDB是聚集索引，数据文件是和索引绑在一起的，必须要有主键，通过主键索引效率很高。但</li></ol><p>是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，</p><p>因为主键太大，其他索引也都会很大。而MyISAM是非聚集索引，数据文件是分离的，索引保存的</p><p>是数据文件的指针。主键索引和辅助索引是独立的。</p><ol start="4"><li>InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用一</li></ol><p>个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；</p><ol start="5"><li>Innodb不支持全文索引，而MyISAM支持全文索引，查询效率上MyISAM要高；</li></ol><h2 id="1-4如何选择引擎？"><a href="#1-4如何选择引擎？" class="headerlink" title="1.4如何选择引擎？"></a>1.4<strong>如何选择引擎？</strong></h2><p>如果没有特别的需求，使用默认的 Innodb 即可。</p><p>MyISAM：以读写插入为主的应用程序，比如博客系统、新闻门户网站。</p><p>Innodb：更新（删除）操作频率也高，或者要保证数据的完整性；并发量高，支持事务和外键。</p><h2 id="1-5数据库的事务"><a href="#1-5数据库的事务" class="headerlink" title="1.5数据库的事务"></a>1.5<strong>数据库的事务</strong></h2><p><strong>什么是事务？：</strong> 多条sql语句，要么全部成功，要么全部失败</p><p><em>数据库事务特性：原子性(Atomic)、一致性</em>(Consistency)、隔离性(Isolation)、持久性(Durabiliy),</p><p>简称ACID</p><p>原子性: 指的是一个事务中的操作要么全部成功，要么全部失败。</p><p>一致性: 指的是数据库总是从一个一致性的状态转换到另外一个一致性的状态。即数据不会被破坏。如A</p><p>转账100元给B，不管操作是否成功，A和B的账户总额是不变的。</p><p>隔离性:在并发数据操作时，不同的事务拥有各自的数据空间，它们的操作不会对彼此产生干扰</p><p>持久性: 指的是一旦事务提交，所做的修改就会永久保存到数据库中，</p><h2 id="1-6索引"><a href="#1-6索引" class="headerlink" title="1.6索引"></a>1.6索引</h2><p>索引用来快速地寻找那些具有特定值的记录。如果没有索引，一般来说执行查询时遍历整张表。</p><p><strong>索引的原理:就是把无序的数据变成有序的查询,以空间换时间(通过创建额外的数据结构来使得对数据的访问更加快速和高效)</strong><br>1.把创建了索引的列的内容进行排序<br>2.对排序结果生成倒排表<br>3.在倒排表内容上拼上数据地址链<br>4.在查询的时候，先拿到倒排表内容，再取出数据地址链，从而拿到具体数据</p><p><strong>索引的设计原则:基数较小的表,更新频繁字段,不能有效区分数据的列,等不适合创建索引,并且在已有索引的基础上尽量扩展索引,不要新建索引</strong></p><p><strong>mysql常见的索引</strong>:</p><p><strong>主键索引（PRIMARY）:数据列不允许重复，不允许为NULL，一个表只能有一个主键。</strong></p><p><strong>唯一索引（UNIQUE）:数据列不允许重复，允许为NULL值，一个表允许多个列创建唯一索引</strong></p><p>普通索引（INDEX）</p><p>全文索引（FULLTEXT）</p><h2 id="1-7SQL语句优化"><a href="#1-7SQL语句优化" class="headerlink" title="1.7SQL语句优化"></a>1.7SQL语句优化</h2><p>**1.避免使用select ***</p><p><strong>2.小表驱动大表</strong></p><ul><li><code>in</code> 适用于左边大表，右边小表。优先执行in里面的<code>子查询语句</code></li><li><code>exists</code> 适用于左边小表，右边大表。优先执行exists左边的语句（即主查询语句）</li></ul><p>不管是用in，还是exists关键字，其核心思想都是用小表驱动大表。</p><p><strong>3.尽量减少子查询，使用关联查询（left join,right join,inner join）替代</strong></p><p><strong>4、应尽量避免在 where 子句中使用!&#x3D;或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描</strong></p><p><strong>5.使用表的别名</strong></p><p><strong>6.使用预编译查询</strong></p><p><strong>7.创建索引</strong>(重要)</p><p>要尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</p><h2 id="1-8什么是视图"><a href="#1-8什么是视图" class="headerlink" title="1.8什么是视图?"></a>1.8什么是视图?</h2><p><strong>视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作</strong>，视图通常是有一</p><p>个表或者多个表的行或列的子集。<strong>对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表</strong>**</p><p><strong>查询。</strong></p><h2 id="1-9什么是内联接、左外联接、右外联接？"><a href="#1-9什么是内联接、左外联接、右外联接？" class="headerlink" title="1.9什么是内联接、左外联接、右外联接？"></a>1.9<strong>什么是内联接、左外联接、右外联接？</strong></h2><p>内联接（Inner Join）：匹配2张表中相关联的记录。</p><p>左外联接（Left Outer Join）：除了匹配2张表中相关联的记录外，还会匹配左表中剩余的记录，</p><p>右表中未匹配到的字段用NULL表示。</p><p>右外联接（Right Outer Join）：除了匹配2张表中相关联的记录外，还会匹配右表中剩余的记录，</p><p>左表中未匹配到的字段用NULL表示。在判定左表和右表时，要根据表名出现在Outer Join的左右</p><p>位置关</p><h2 id="1-10并发事务带来哪些问题-了解"><a href="#1-10并发事务带来哪些问题-了解" class="headerlink" title="1.10并发事务带来哪些问题?(了解)"></a>1.10<strong>并发事务带来哪些问题</strong>?(了解)</h2><p><strong>脏读</strong>: 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到</p><p>数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提</p><p>交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确</p><p>的。</p><p><strong>丢失修改</strong> 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那</p><p>么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结</p><p>果就被丢失，因此称为丢失修改。 例如：事务1读取某表中的数据A&#x3D;20，事务2也读取A&#x3D;20，事</p><p>务1修改A&#x3D;A-1，事务2也修改A&#x3D;A-1，最终结果A&#x3D;19，事务1的修改被丢失。</p><p><strong>不可重复读:</strong> 指在一个事务内多次读同一数据。在这个事务还没有结束</p><p>时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改</p><p>导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样</p><p>的情况，因此称为不可重复读。</p><p><strong>幻读:</strong> 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接</p><p>着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了</p><p>一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读</p><h2 id="1-11事务隔离级别有哪些-MySQL的默认隔离级别"><a href="#1-11事务隔离级别有哪些-MySQL的默认隔离级别" class="headerlink" title="1.11事务隔离级别有哪些?MySQL的默认隔离级别"></a>1.11<strong>事务隔离级别有哪些</strong>?MySQL的默认隔离级别</h2><p><strong>SQL</strong> <strong>标准定义了四个隔离级别：</strong></p><p><strong>READ-UNCOMMITTED(读取未提交)：</strong> 最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会</strong></p><p><strong>导致脏读、幻读或不可重复读</strong>。</p><p><strong>READ-COMMITTED(读取已提交)：</strong> 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻</strong></p><p><strong>读或不可重复读仍有可能发生</strong>。</p><p><strong>REPEATABLE-READ(可重复读)：</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务</p><p>自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生</strong>。</p><p>**SERIALIZABLE(可串行化)**： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执</p><p>行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻</strong></p><p><strong>读</strong>。</p><p><strong>MySQL InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读）</strong></p><h2 id="1-12大表如何优化？"><a href="#1-12大表如何优化？" class="headerlink" title="1.12大表如何优化？"></a>1.12<strong>大表如何优化？</strong></h2><p>当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：</p><p><strong>1.</strong> <strong>限定数据的范围</strong></p><p>务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以</p><p>控制在一个月的范围内；</p><p><strong>2.</strong> <strong>读写分离</strong></p><p>经典的数据库拆分方案，主库负责写，从库负责读；</p><p><strong>3.</strong> <strong>垂直分区</strong></p><p><strong>简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。</strong></p><p> <strong>4.水平分区</strong></p><p><strong>保持数据表结构不变，通过某种策略存储数据分片。</strong></p><h2 id="1-13分库分表之后-id-主键如何处理？"><a href="#1-13分库分表之后-id-主键如何处理？" class="headerlink" title="1.13分库分表之后,id 主键如何处理？"></a>1.13<strong>分库分表之后</strong>,id <strong>主键如何处理？</strong></h2><p>传统的自增主键可能会导致重复冲突。需要一个全局唯一的 id 来</p><p>支持。</p><p><strong>生成全局 id 有下面这几种方式：</strong></p><p><strong>UUID</strong>：不适合作为主键，因为太长了，并且无序不可读，查询效率低。比较适合用于生成唯一的</p><p>名字的标示比如文件的名字。</p><p><strong>数据库自增</strong> <strong>id</strong> : 两台数据库分别设置不同步长，生成不重复ID的策略来实现高可用。这种方式生成</p><p>的 id 有序，但是需要独立部署数据库实例，成本高，还会有性能瓶颈。</p><p><strong>利用</strong> <strong>redis</strong> <strong>生成</strong> <strong>id :</strong> 性能比较好，灵活方便，不依赖于数据库。但是，引入了新的组件造成系统更</p><p>加复杂，可用性降低，编码更加复杂，增加了系统成本。</p><p> <strong>Snowflake 算法</strong></p><h2 id="1-14varchar和char的区别"><a href="#1-14varchar和char的区别" class="headerlink" title="1.14varchar和char的区别"></a>1.14varchar和char的区别</h2><table><thead><tr><th>特性</th><th align="center">CHAR</th><th>VARCHAR</th></tr></thead><tbody><tr><td>存储方式</td><td align="center">固定长度</td><td>可变长度</td></tr><tr><td>空间使用</td><td align="center">总是占用指定的最大空间</td><td>根据实际内容调整空间</td></tr><tr><td>性能</td><td align="center">对于固定长度的数据，可能有更好的性能</td><td>较高的灵活性，但可能有轻微性能损失</td></tr><tr><td>适用场景</td><td align="center">数据长度固定的字段</td><td>数据长度不固定的字段</td></tr></tbody></table><h2 id="1-15DATETIME和TIMESTAMP的区别"><a href="#1-15DATETIME和TIMESTAMP的区别" class="headerlink" title="1.15DATETIME和TIMESTAMP的区别"></a>1.15DATETIME和TIMESTAMP的区别</h2><table><thead><tr><th>特性</th><th>DATETIME</th><th>TIMESTAMP</th></tr></thead><tbody><tr><td>存储方式</td><td>固定8字节，范围更大</td><td>4字节，范围受限</td></tr><tr><td>时区处理</td><td>不涉及时区</td><td>自动转换为UTC存储</td></tr><tr><td>自动初始化&#x2F;更新</td><td>默认不启用，可配置</td><td>默认自动初始化和更新，可配置</td></tr><tr><td>精度</td><td>可达秒，默认无小数秒</td><td>同样可达秒，默认无小数秒</td></tr><tr><td>适用场景</td><td>不需要时区转换，大范围日期</td><td>多时区应用，节省存储空间</td></tr></tbody></table><h2 id="1-16创建索引的三种方式"><a href="#1-16创建索引的三种方式" class="headerlink" title="1.16创建索引的三种方式"></a>1.16<strong>创建索引的三种方式</strong></h2><p>第一种方式：在执行CREATE TABLE时创建索引</p><p>第二种方式：使用ALTER TABLE命令去增加索引</p><p>第三种方式：使用CREATE INDEX命令创建</p>]]></content>
      
      
      <categories>
          
          <category> 工作ing~ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot</title>
      <link href="/posts/33757.html"/>
      <url>/posts/33757.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-SpringBoot"><a href="#1-SpringBoot" class="headerlink" title="1.SpringBoot"></a>1.SpringBoot</h1><h2 id="1-1-什么是Spring-Boot？"><a href="#1-1-什么是Spring-Boot？" class="headerlink" title="1.1 什么是Spring Boot？"></a>1.1 什么是Spring Boot？</h2><p>SpringBoot 是 Spring 开源组织下的子项目，是 Spring 组件一站式解决方案，主要是简化了使用 Spring 的难度，简省了繁重XML的配置，提供了各种启动器，在运行过程中自定配置, 开发者能快速上手。它的优势是独立运行、 简化配置、自动配置 、无代码生成和XML配置, 无需部署war文件。</p><h2 id="1-2-Spring-Boot的优点"><a href="#1-2-Spring-Boot的优点" class="headerlink" title="1.2 Spring Boot的优点"></a>1.2 Spring Boot的优点</h2><ol><li><strong>简化依赖管理</strong>：通过提供一系列的“starter”依赖（如 spring-boot-starter-web），Spring Boot 可以自动引入项目所需的所有依赖，这极大地简化了 Maven 或 Gradle 配置文件。</li><li><strong>自动配置</strong>：Spring Boot 能根据项目中引入的依赖，自动进行相应的配置，减少手动配置的工作量。例如，当你添加了对嵌入式Tomcat的支持时，它会自动为你配置好Tomcat服务器。</li><li><strong>内嵌服务器支持</strong>：Spring Boot 支持内嵌的 Tomcat、Jetty 或者 Undertow 容器，这意味着你可以使用 jar 文件直接运行应用，而不需要部署到外部的 web 服务器上。</li><li><strong>生产就绪功能</strong>：Spring Boot 提供了一些用于监控和管理应用的功能，比如指标收集、健康检查等，帮助开发者更容易地将应用部署到生产环境。</li><li><strong>易于部署</strong>：由于其支持创建独立的可执行jar包，使得部署变得非常简单。你只需要一个Java运行时环境即可运行你的应用。</li><li><strong>微服务友好</strong>：Spring Boot 非常适合构建微服务架构的应用程序，它的轻量化和快速启动特性，使它成为云原生应用的理想选择。</li><li><strong>强大的社区支持</strong>：作为一个广泛使用的开源项目，Spring Boot 拥有庞大的用户基础和活跃的社区，意味着可以很容易找到解决方案和获得帮助。</li><li><strong>与Spring生态系统无缝集成</strong>：Spring Boot 与整个Spring生态系统紧密集成，包括Spring Data, Spring Security, Spring Cloud等，能够轻松实现各种复杂的企业级应用需求。</li></ol><h2 id="1-3-什么是JavaConfig"><a href="#1-3-什么是JavaConfig" class="headerlink" title="1.3 什么是JavaConfig?"></a>1.3 什么是JavaConfig?</h2><p>Spring JavaConfig 是 Spring 社区的产品，它提供了配置Spring IoC容器的纯Java方法。因此 它有助于避免使用XML配置。使用JavaConfig的优点在于： 面向对象的配置。由于配置被定义为JavaConfig中的类，因此用户可以充分利用Java中的 面向对象功能。</p><h2 id="1-4-JavaConfig核心注解"><a href="#1-4-JavaConfig核心注解" class="headerlink" title="1.4 JavaConfig核心注解"></a>1.4 JavaConfig核心注解</h2><h3 id="1-41-Configuration"><a href="#1-41-Configuration" class="headerlink" title="1.41 @Configuration"></a>1.41 <strong>@Configuration</strong></h3><ul><li><strong>作用</strong>：标记一个类为配置类，用于替代传统的 XML 配置文件。</li><li><strong>说明</strong>：被 <code>@Configuration</code> 注解的类通常包含一个或多个 <code>@Bean</code> 方法，这些方法定义了 Spring 容器中的 Bean。</li></ul><h3 id="1-42-Bean"><a href="#1-42-Bean" class="headerlink" title="1.42 @Bean"></a>1.42 <strong>@Bean</strong></h3><ul><li><strong>作用</strong>：标记一个方法，表示该方法返回的对象将被注册为 Spring 容器中的一个 Bean。</li><li><strong>说明</strong>：<code>@Bean</code> 注解的方法通常是用来创建和初始化 Bean 的逻辑。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Bean public MyRepository myRepository() &#123;   </span><br><span class="line">return new MyRepositoryImpl(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-43-ComponentScan"><a href="#1-43-ComponentScan" class="headerlink" title="1.43 @ComponentScan"></a>1.43 <strong>@ComponentScan</strong></h3><ul><li><strong>作用</strong>：启用组件扫描功能，自动发现并注册标注了 <code>@Component</code> 及其派生注解（如 <code>@Service</code>, <code>@Controller</code>, <code>@Repository</code>）的类为 Spring Bean。</li><li><strong>说明</strong>：默认情况下，它会扫描当前包及其子包下的所有类。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(basePackages = &quot;com.example&quot;)</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-44-Import"><a href="#1-44-Import" class="headerlink" title="1.44 @Import"></a>1.44 <strong>@Import</strong></h3><ul><li><strong>作用</strong>：导入其他配置类，将多个配置类合并到一个上下文中。</li><li><strong>说明</strong>：适用于模块化配置场景，可以将不同功能的配置分开管理。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@Import(DatabaseConfig.class)</span><br><span class="line">public class AppConfig &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-5-如何重新加载Spring-Boot上的更改，而无需重新启动服务器？"><a href="#1-5-如何重新加载Spring-Boot上的更改，而无需重新启动服务器？" class="headerlink" title="1.5 如何重新加载Spring Boot上的更改，而无需重新启动服务器？"></a>1.5 <strong>如何重新加载Spring Boot上的更改，而无需重新启动服务器？</strong></h2><h3 id="1-Spring-Boot-DevTools"><a href="#1-Spring-Boot-DevTools" class="headerlink" title="1.Spring Boot DevTools"></a>1.<strong>Spring Boot DevTools</strong></h3><p><code>Spring Boot DevTools</code> 是 Spring 官方提供的一个开发者工具模块，它支持自动重启（Restart）和实时重载（LiveReload），能够快速应用代码更改。</p><h3 id="2-JRebel"><a href="#2-JRebel" class="headerlink" title="2.JRebel"></a>2.<strong>JRebel</strong></h3><p>JRebel是一个商业工具，专注于 Java 应用的热部署。它可以即时重新加载代码更改，而无需重启整个应用程序。</p><h2 id="1-6-SpringBoot-拦截器、监听器、过滤器"><a href="#1-6-SpringBoot-拦截器、监听器、过滤器" class="headerlink" title="1.6 SpringBoot 拦截器、监听器、过滤器"></a>1.6 <strong>SpringBoot 拦截器、监听器、过滤器</strong></h2><h3 id="拦截器（Interceptor）"><a href="#拦截器（Interceptor）" class="headerlink" title="拦截器（Interceptor）"></a>拦截器（Interceptor）</h3><p><strong>作用</strong>：</p><ul><li>拦截器主要用于对处理器（Handler）进行预处理和后处理工作。</li><li>它可以用来在请求到达控制器之前或之后执行一些操作，比如日志记录、权限验证等。</li></ul><p><strong>实现方式</strong>：</p><ul><li>实现 <code>HandlerInterceptor</code> 接口或者继承 <code>HandlerInterceptorAdapter</code> 类。</li><li>需要在配置类中通过 <code>WebMvcConfigurer</code> 的 <code>addInterceptors</code> 方法注册自定义的拦截器。</li></ul><p><strong>适用场景</strong>：</p><ul><li>在进入控制器之前做一些准备工作，如用户认证、参数校验等。</li><li>在控制器方法执行完毕之后做些清理工作，如资源释放等。</li></ul><h3 id="监听器（Listener）"><a href="#监听器（Listener）" class="headerlink" title="监听器（Listener）"></a>监听器（Listener）</h3><p><strong>作用</strong>：</p><ul><li>监听器主要用于监听应用上下文（ApplicationContext）的事件，如上下文启动、关闭等事件。</li><li>可以利用它来监听特定的事件并作出相应的响应。</li></ul><p><strong>实现方式</strong>：</p><ul><li>实现 <code>ApplicationListener</code> 接口，并指定要监听的事件类型。</li><li>或者使用注解 <code>@EventListener</code> 来标注一个方法作为事件监听器。</li></ul><p><strong>适用场景</strong>：</p><ul><li>监听 Spring 上下文中的各种事件，如应用启动时初始化资源、销毁前释放资源等。</li></ul><h3 id="过滤器（Filter）"><a href="#过滤器（Filter）" class="headerlink" title="过滤器（Filter）"></a>过滤器（Filter）</h3><p><strong>作用</strong>：</p><ul><li>过滤器是 Servlet 规范的一部分，主要用于对请求和响应进行处理。</li><li>可以修改请求的内容、响应的内容，甚至是重定向请求等。</li></ul><p><strong>实现方式</strong>：</p><ul><li>实现 <code>javax.servlet.Filter</code> 接口，并重写 <code>doFilter</code> 方法。</li><li>通过 <code>@Component</code> 注解将过滤器注册为 Spring Bean，或在配置类中手动注册。</li></ul><p><strong>适用场景</strong>：</p><ul><li>对所有请求进行统一处理，如字符编码设置、敏感信息过滤等。</li><li>适用于需要在请求到达控制器之前或响应返回给客户端之前进行的操作。</li></ul><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ol><li><strong>职责不同</strong>：<ul><li>拦截器主要关注于业务逻辑层面的拦截与处理。</li><li>监听器侧重于监听应用上下文的状态变化及相应事件的触发。</li><li>过滤器则更偏向于技术层面的请求&#x2F;响应处理。</li></ul></li><li><strong>工作阶段不同</strong>：<ul><li>拦截器工作在 Spring MVC 层级，在请求到达控制器之前或之后起作用。</li><li>监听器的工作范围更广，可以监听整个 Spring 应用上下文的各种事件。</li><li>过滤器位于 Servlet 层级，比拦截器更早地处理请求和响应。</li></ul></li><li><strong>配置方式不同</strong>：<ul><li>拦截器通常通过实现 <code>HandlerInterceptor</code> 接口并在配置类中注册。</li><li>监听器可以通过实现 <code>ApplicationListener</code> 接口或使用 <code>@EventListener</code> 注解。</li><li>过滤器需要实现 <code>Filter</code> 接口并通过注解或配置类注册。</li></ul></li></ol><h2 id="1-7-SpringBoot自动装配原理"><a href="#1-7-SpringBoot自动装配原理" class="headerlink" title="1.7 SpringBoot自动装配原理?"></a>1.7 SpringBoot自动装配原理?</h2><p>SpringBoot的自动装配原理就是：</p><p>①在启动类中的所在包及子包中，直接扫描注解，然后添加到IOC容器中。</p><p>②通过类加载器，去获取classpath中配置文件 META-INF&#x2F;spring.factory 和spring&#x2F;org.springframework.boot.autoconfigure.AutoConfiguration.imports两个包。</p><p>③然后筛选出以EnableAutoConfiguration.class为key的，符合条件的配置类。</p><p>④通过@Conditional注解过滤掉不需要加载到IOC容器的对象。</p><p>⑥将符合条件的配置类加载到IOC容器中。</p><h2 id="1-8-Spring-Boot-有哪些核心注解？"><a href="#1-8-Spring-Boot-有哪些核心注解？" class="headerlink" title="1.8 Spring Boot 有哪些核心注解？"></a>1.8 <strong>Spring Boot 有哪些核心注解？</strong></h2><p>Spring Boot的核心注解主要包括以下几个：</p><p>1.@SpringBootApplication：标识一个类作为Spring Boot项目的启动类。实际上，这个注解是@SpringBootConfiguration、@EnableAutoConfiguration和@ComponentScan这三个注解的组合。</p><p>2.@SpringBootConfiguration：这个注解表示该类是一个Spring Boot配置类，用于定义bean。实际上是一个特殊的@Configuration注解，用于加载Spring Boot项目的配置。</p><p>3.@EnableAutoConfiguration：这个注解用于启用Spring Boot的自动化配置功能。通过添加此注解，Spring Boot可以自动引入相关的配置，减少开发人员的配置成本。</p><p>4.@ComponentScan：这个注解用于定义Spring扫描包的路径，用于发现应用程序中的bean、组件、配置类和服务等。可以自动扫描并注册包路径下的带有@Component、@Service等注解的类。</p><h2 id="1-9-bootstrap-properties-和-application-properties-有何区别-？"><a href="#1-9-bootstrap-properties-和-application-properties-有何区别-？" class="headerlink" title="1.9 bootstrap.properties 和 application.properties 有何区别 ？"></a>1.9 <strong>bootstrap.properties 和 application.properties 有何区别 ？</strong></h2><p>答：1.加载顺序和优先级：</p><p>bootstrap.properties（或bootstrap.yml）是Spring Boot应用程序启动时最先加载的配置文件。<br>application.properties（或application.yml）是在bootstrap.properties之后加载。</p><p>2.配置范围：</p><p>bootstrap.properties的作用范围是全局的，会被该项目下所有的Spring应用程序共享。<br>application.properties主要关注应用程序本身的配置属性，比如数据库连接、端口设置、日志级别、缓存配置等。</p><h2 id="1-10-Spring-Boot-有哪些-starter-？"><a href="#1-10-Spring-Boot-有哪些-starter-？" class="headerlink" title="1.10 Spring Boot 有哪些 starter ？"></a>1.10 <strong>Spring Boot 有哪些 starter ？</strong></h2><p>答：1.spring-boot-starter-web：用于构建 Web 应用程序的 Starter，包括 Spring MVC 和 Tomcat 服务器。<br>2.spring-boot-starter-data-jpa：用于与关系型数据库进行交互的 Starter，用于简化数据库访问层的开发。<br>3.spring-boot-starter-data-redis：用于与 Redis 数据库进行交互的 Starter。<br>4.spring-boot-starter-actuator：用于监控和管理 Spring Boot 应用的 Starter。<br>5.mybatis-spring-boot-starter：用于在 Spring Boot 应用中集成 MyBatis 。</p><h2 id="1-11-SpringBoot-中如何解决跨域问题-？"><a href="#1-11-SpringBoot-中如何解决跨域问题-？" class="headerlink" title="1.11 SpringBoot 中如何解决跨域问题 ？"></a>1.11 <strong>SpringBoot 中如何解决跨域问题 ？</strong></h2><p>实现WebMvcConfigurer接口然后重写addCorsMappings方法解决跨域问题。</p><h2 id="1-12-SpringBoot打成的jar和普通jar有什么区别？"><a href="#1-12-SpringBoot打成的jar和普通jar有什么区别？" class="headerlink" title="1.12 SpringBoot打成的jar和普通jar有什么区别？"></a>1.12 <strong>SpringBoot打成的jar和普通jar有什么区别？</strong></h2><p>Spring Boot 项目最终打包成的 jar 是可执行 jar ，这种 jar 可以直接通过 java -jar xxx.jar 命令来运行,这种 jar 不可以作为普通的 jar 被其他项目依赖，即使依赖了也无法使用其中的类。</p><p>如果非要引用，可以在 pom.xml 文件中增加配置，将 Spring Boot 项目打包成两个 jar ，一个可执行，一个可引用。</p><h2 id="1-13-SpringBoot中如何实现定时任务？"><a href="#1-13-SpringBoot中如何实现定时任务？" class="headerlink" title="1.13 SpringBoot中如何实现定时任务？"></a>1.13 <strong>SpringBoot中如何实现定时任务？</strong></h2><p>Spring Boot 中对于定时任务的支持主要还是来自 Spring 框架。</p><p>在 Spring Boot 中使用定时任务主要有两种不同的方式，</p><ul><li>一个就是使用 Spring 中的 @Scheduled 注解，用cron规则进行定时</li><li>另一个则是使用第三方框架 Quartz,定义 Job 和 Trigger 即可。</li></ul><h2 id="1-14-Spring-Boot-中如何处理事务？使用的任何注释？"><a href="#1-14-Spring-Boot-中如何处理事务？使用的任何注释？" class="headerlink" title="1.14 Spring Boot 中如何处理事务？使用的任何注释？"></a>1.14 <strong>Spring Boot 中如何处理事务？使用的任何注释？</strong></h2><p>在Spring Boot中处理事务通常使用<code>@Transactional</code>注解。这个注解可以被标注在方法上或者类上。当标注在方法上时，仅该方法拥有事务性行为。而当标注在类上时，该类中的所有公共方法默认都有事务行为。</p><p>使用<code>@Transactional</code>注解时，你可以配置事务的隔离级别、传播行为、超时设置以及事务的回滚规则等。</p>]]></content>
      
      
      <categories>
          
          <category> 工作ing~ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>es初级入门</title>
      <link href="/posts/10672.html"/>
      <url>/posts/10672.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-Elasticsearch-快速入门版本"><a href="#1-Elasticsearch-快速入门版本" class="headerlink" title="1.Elasticsearch(快速入门版本)"></a>1.Elasticsearch(快速入门版本)</h1><h2 id="1-1初识elasticsearch"><a href="#1-1初识elasticsearch" class="headerlink" title="1.1初识elasticsearch"></a>1.1初识elasticsearch</h2><h3 id="1-1-1倒排索引"><a href="#1-1-1倒排索引" class="headerlink" title="1.1.1倒排索引"></a>1.1.1倒排索引</h3><p>倒排索引中有两个非常重要的概念：</p><ul><li><p>文档（<code>Document</code>）：用来搜索的数据，其中的每一条数据就是一个文档。例如一个网页、一个商品信息</p></li><li><p>词条（<code>Term</code>）：对文档数据或用户搜索数据，利用某种算法分词，得到的具备含义的词语就是词条。例如：我是中国人，就可以分为：我、是、中国人、中国、国人这样的几个词条</p></li></ul><p><strong>创建倒排索引</strong>是对正向索引的一种特殊处理和应用，流程如下：</p><ul><li>将每一个文档的数据利用<strong>分词算法</strong>根据语义拆分，得到一个个词条</li><li>创建表，每行数据包括词条、词条所在文档id、位置等信息</li><li>因为词条唯一性，可以给词条创建<strong>正向</strong>索引</li></ul><p>此时形成的这张以词条为索引的表，就是倒排索引表，两者对比如下：</p><p><img src="https://pic.imgdb.cn/item/673d8c4ed29ded1a8cb3326e.png" alt="es-1"></p><h3 id="1-1-2基础概念"><a href="#1-1-2基础概念" class="headerlink" title="1.1.2基础概念"></a>1.1.2基础概念</h3><p>elasticsearch是面向<strong>文档（Document）</strong>存储的，可以是数据库中的一条商品数据，一个订单信息。文档数据会被序列化为<code>json</code>格式后存储在<code>elasticsearch</code>中：</p><p><img src="https://pic.imgdb.cn/item/673d8c4ed29ded1a8cb3326e.png" alt="es-2"></p><h3 id="1-1-3Mysql与es对比来了解es基础概念"><a href="#1-1-3Mysql与es对比来了解es基础概念" class="headerlink" title="1.1.3Mysql与es对比来了解es基础概念"></a>1.1.3Mysql与es对比来了解es基础概念</h3><p><img src="https://pic.imgdb.cn/item/673d8c4fd29ded1a8cb3331a.png" alt="es-3"></p><p><img src="https://pic.imgdb.cn/item/673d8c4fd29ded1a8cb333b7.png" alt="es-4"></p><ul><li>Mysql：擅长事务类型操作，可以确保数据的安全和一致性 </li><li>Elasticsearch：擅长海量数据的搜索、分析、计算</li></ul><p>因此在企业中，往往是两者结合使用：</p><ul><li>对安全性要求较高的写操作，使用mysql实现</li><li>对查询性能要求较高的搜索需求，使用elasticsearch实现</li><li>两者再基于某种方式，实现数据的同步，保证一致性</li></ul><h2 id="1-2IK分词器"><a href="#1-2IK分词器" class="headerlink" title="1.2IK分词器"></a>1.2IK分词器</h2><p>IK分词器包含两种模式：</p><ul><li><code>ik_smart</code>：智能语义切分 </li><li><code>ik_max_word</code>：最细粒度切分</li></ul><p>所以要想正确分词，IK分词器的词库也需要不断的更新，IK分词器提供了扩展词汇的功能。</p><h3 id="1-2-1拓展词典"><a href="#1-2-1拓展词典" class="headerlink" title="1.2.1拓展词典"></a>1.2.1拓展词典</h3><p>1.打开IK分词器config目录：</p><p>2.在IKAnalyzer.cfg.xml配置文件内容添加：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">properties</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;http://java.sun.com/dtd/properties.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">comment</span>&gt;</span>IK Analyzer 扩展配置<span class="tag">&lt;/<span class="name">comment</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--用户可以在这里配置自己的扩展字典 *** 添加扩展词典--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;ext_dict&quot;</span>&gt;</span>ext.dic<span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3.在IK分词器的config目录新建一个 <code>ext.dic</code>，可以参考config目录下复制一个配置文件进行修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">鸡你太美</span><br><span class="line">泰裤辣</span><br></pre></td></tr></table></figure><p>4.重启elasticsearch</p><h2 id="1-3Mapping映射属性"><a href="#1-3Mapping映射属性" class="headerlink" title="1.3Mapping映射属性"></a>1.3Mapping映射属性</h2><p>Mapping是对索引库中文档的约束，常见的Mapping属性包括：</p><p>type：字段数据类型，常见的简单类型有： </p><p>   字符串：text（可分词的文本）、keyword（精确值，例如：品牌、国家、ip地址）</p><p>   数值：long、integer、short、byte、double、float、</p><p>   布尔：boolean</p><p>   日期：date</p><p>   对象：object</p><p>index：是否创建索引，默认为true</p><p>analyzer：使用哪种分词器</p><p>properties：该字段的子字段</p><h2 id="1-4索引库的CRUD"><a href="#1-4索引库的CRUD" class="headerlink" title="1.4索引库的CRUD"></a>1.4索引库的CRUD</h2><p>由于Elasticsearch采用的是Restful风格的API，因此其请求方式和路径相对都比较规范，而且请求参数也都采用JSON风格。</p><h3 id="1-4-1-创建索引库和映射"><a href="#1-4-1-创建索引库和映射" class="headerlink" title="1.4.1.创建索引库和映射"></a>1.4.1.创建索引库和映射</h3><p><strong>基本语法</strong>：</p><ul><li>请求方式：<code>PUT</code></li><li>请求路径：<code>/索引库名</code>，可以自定义</li><li>请求参数：<code>mapping</code>映射</li></ul><p>格式:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">PUT /索引库名称</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;字段名&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_smart&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;字段名2&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;false&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;字段名3&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;子字段&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="comment">// ...略</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>示例:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># PUT /query</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;info&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_smart&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;email&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="string">&quot;false&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;firstName&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="1-4-2查询索引库"><a href="#1-4-2查询索引库" class="headerlink" title="1.4.2查询索引库"></a>1.4.2查询索引库</h3><p><strong>基本语法</strong>：</p><ul><li>请求方式：GET </li><li>请求路径：&#x2F;索引库名 </li><li>请求参数：无</li></ul><p><strong>格式</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /索引库名</span><br></pre></td></tr></table></figure><p><strong>示例</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /query</span><br></pre></td></tr></table></figure><h3 id="1-4-3修改索引库"><a href="#1-4-3修改索引库" class="headerlink" title="1.4.3修改索引库"></a>1.4.3修改索引库</h3><p>倒排索引结构虽然不复杂，但是一旦数据结构改变（比如改变了分词器），就需要重新创建倒排索引，这简直是灾难。因此索引库<strong>一旦创建，无法修改mapping</strong>。</p><p>虽然无法修改mapping中已有的字段，但是却允许添加新的字段到mapping中，因为不会对倒排索引产生影响。因此修改索引库能做的就是向索引库中添加新字段，或者更新索引库的基础属性。</p><p><strong>语法说明</strong>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PUT /索引库名/_mapping</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;新字段名&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;integer&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>示例</strong>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PUT /query/_mapping</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;integer&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="1-4-4删除索引库"><a href="#1-4-4删除索引库" class="headerlink" title="1.4.4删除索引库"></a>1.4.4删除索引库</h3><p><strong>语法：</strong></p><ul><li>请求方式：DELETE </li><li>请求路径：&#x2F;索引库名 </li><li>请求参数：无</li></ul><p><strong>格式：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE /索引库名</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE /query</span><br></pre></td></tr></table></figure><h3 id="1-4-4总结"><a href="#1-4-4总结" class="headerlink" title="1.4.4总结"></a>1.4.4总结</h3><ul><li>创建索引库：PUT &#x2F;索引库名</li><li>查询索引库：GET &#x2F;索引库名</li><li>删除索引库：DELETE &#x2F;索引库名</li><li>修改索引库，添加字段：PUT &#x2F;索引库名&#x2F;_mapping</li></ul><h2 id="1-5文档操作CRUD"><a href="#1-5文档操作CRUD" class="headerlink" title="1.5文档操作CRUD"></a>1.5文档操作CRUD</h2><h3 id="1-5-1新增文档"><a href="#1-5-1新增文档" class="headerlink" title="1.5.1新增文档"></a>1.5.1新增文档</h3><p><strong>语法：</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">POST /索引库名/_doc/文档id</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;字段1&quot;</span><span class="punctuation">:</span> <span class="string">&quot;值1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;字段2&quot;</span><span class="punctuation">:</span> <span class="string">&quot;值2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;字段3&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;子属性1&quot;</span><span class="punctuation">:</span> <span class="string">&quot;值3&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;子属性2&quot;</span><span class="punctuation">:</span> <span class="string">&quot;值4&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">POST /query/_doc/<span class="number">1</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;info&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Java&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;email&quot;</span><span class="punctuation">:</span> <span class="string">&quot;zzz@123.cn&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;firstName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;张&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;lastName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;三&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="1-5-2-查询文档"><a href="#1-5-2-查询文档" class="headerlink" title="1.5.2.查询文档"></a>1.5.2.查询文档</h3><p><strong>语法：</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /<span class="punctuation">&#123;</span>索引库名称<span class="punctuation">&#125;</span>/_doc/<span class="punctuation">&#123;</span>id<span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="1-5-3删除文档"><a href="#1-5-3删除文档" class="headerlink" title="1.5.3删除文档"></a>1.5.3删除文档</h3><p><strong>语法：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">DELETE</span> /&#123;索引库名&#125;/_doc/id值</span><br></pre></td></tr></table></figure><h3 id="1-5-4修改文档"><a href="#1-5-4修改文档" class="headerlink" title="1.5.4修改文档"></a>1.5.4修改文档</h3><p>修改有两种方式：</p><ul><li>全量修改：直接覆盖原来的文档</li><li>局部修改：修改文档中的部分字段</li></ul><h4 id="1-全量修改"><a href="#1-全量修改" class="headerlink" title="1.全量修改"></a>1.全量修改</h4><p>全量修改是覆盖原来的文档，其本质是两步操作：</p><ul><li>根据指定的id删除文档</li><li>新增一个相同id的文档</li></ul><p><strong>注意</strong>：如果根据id删除时，id不存在，第二步的新增也会执行，也就从修改变成了新增操作了。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PUT /<span class="punctuation">&#123;</span>索引库名<span class="punctuation">&#125;</span>/_doc/文档id</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;字段1&quot;</span><span class="punctuation">:</span> <span class="string">&quot;值1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;字段2&quot;</span><span class="punctuation">:</span> <span class="string">&quot;值2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// ... 略</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>示例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">POST /query/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">    &quot;info&quot;: &quot;Java&quot;,</span><br><span class="line">    &quot;email&quot;: &quot;zzz@123.cn&quot;,</span><br><span class="line">    &quot;name&quot;: &#123;</span><br><span class="line">        &quot;firstName&quot;: &quot;张&quot;,</span><br><span class="line">        &quot;lastName&quot;: &quot;三&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-局部修改"><a href="#2-局部修改" class="headerlink" title="2.局部修改"></a>2.局部修改</h4><p>局部修改是只修改指定id匹配的文档中的部分字段。</p><p><strong>语法：</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /<span class="punctuation">&#123;</span>索引库名<span class="punctuation">&#125;</span>/_update/文档id</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;doc&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">         <span class="attr">&quot;字段名&quot;</span><span class="punctuation">:</span> <span class="string">&quot;新的值&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>示例:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /query/_update/<span class="number">1</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;doc&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;email&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ZhangSan@123.cn&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="1-5-5批处理"><a href="#1-5-5批处理" class="headerlink" title="1.5.5批处理"></a>1.5.5批处理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST _bulk</span><br><span class="line">&#123; <span class="string">&quot;index&quot;</span> : &#123; <span class="string">&quot;_index&quot;</span> : <span class="string">&quot;test&quot;</span>, <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;1&quot;</span> &#125; &#125;</span><br><span class="line">&#123; <span class="string">&quot;field1&quot;</span> : <span class="string">&quot;value1&quot;</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;delete&quot;</span> : &#123; <span class="string">&quot;_index&quot;</span> : <span class="string">&quot;test&quot;</span>, <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;2&quot;</span> &#125; &#125;</span><br><span class="line">&#123; <span class="string">&quot;create&quot;</span> : &#123; <span class="string">&quot;_index&quot;</span> : <span class="string">&quot;test&quot;</span>, <span class="string">&quot;_id&quot;</span> : <span class="string">&quot;3&quot;</span> &#125; &#125;</span><br><span class="line">&#123; <span class="string">&quot;field1&quot;</span> : <span class="string">&quot;value3&quot;</span> &#125;</span><br><span class="line">&#123; <span class="string">&quot;update&quot;</span> : &#123;<span class="string">&quot;_id&quot;</span> : <span class="string">&quot;1&quot;</span>, <span class="string">&quot;_index&quot;</span> : <span class="string">&quot;test&quot;</span>&#125; &#125;</span><br><span class="line">&#123; <span class="string">&quot;doc&quot;</span> : &#123;<span class="string">&quot;field2&quot;</span> : <span class="string">&quot;value2&quot;</span>&#125; &#125;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>index</code>代表新增操作<ul><li><code>_index</code>：指定索引库名</li><li><code>_id</code>指定要操作的文档id</li><li><code>&#123; &quot;field1&quot; : &quot;value1&quot; &#125;</code>：则是要新增的文档内容</li></ul></li><li><code>delete</code>代表删除操作<ul><li><code>_index</code>：指定索引库名</li><li><code>_id</code>指定要操作的文档id</li></ul></li><li><code>update</code>代表更新操作<ul><li><code>_index</code>：指定索引库名</li><li><code>_id</code>指定要操作的文档id</li><li><code>&#123; &quot;doc&quot; : &#123;&quot;field2&quot; : &quot;value2&quot;&#125; &#125;</code>：要更新的文档字段</li></ul></li></ul><p>示例，批量新增：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST /_bulk</span><br><span class="line">&#123;<span class="string">&quot;index&quot;</span>: &#123;<span class="string">&quot;_index&quot;</span>:<span class="string">&quot;query&quot;</span>, <span class="string">&quot;_id&quot;</span>: <span class="string">&quot;3&quot;</span>&#125;&#125;</span><br><span class="line">&#123;<span class="string">&quot;info&quot;</span>: <span class="string">&quot;程序员C++讲师&quot;</span>, <span class="string">&quot;email&quot;</span>: <span class="string">&quot;ww@123.cn&quot;</span>, <span class="string">&quot;name&quot;</span>:&#123;<span class="string">&quot;firstName&quot;</span>: <span class="string">&quot;五&quot;</span>, <span class="string">&quot;lastName&quot;</span>:<span class="string">&quot;王&quot;</span>&#125;&#125;</span><br><span class="line">&#123;<span class="string">&quot;index&quot;</span>: &#123;<span class="string">&quot;_index&quot;</span>:<span class="string">&quot;query&quot;</span>, <span class="string">&quot;_id&quot;</span>: <span class="string">&quot;4&quot;</span>&#125;&#125;</span><br><span class="line">&#123;<span class="string">&quot;info&quot;</span>: <span class="string">&quot;程序员前端讲师&quot;</span>, <span class="string">&quot;email&quot;</span>: <span class="string">&quot;zhangsan@123.cn&quot;</span>, <span class="string">&quot;name&quot;</span>:&#123;<span class="string">&quot;firstName&quot;</span>: <span class="string">&quot;三&quot;</span>, <span class="string">&quot;lastName&quot;</span>:<span class="string">&quot;张&quot;</span>&#125;&#125;</span><br></pre></td></tr></table></figure><p>批量删除：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POST /_bulk</span><br><span class="line">&#123;<span class="string">&quot;delete&quot;</span>:&#123;<span class="string">&quot;_index&quot;</span>:<span class="string">&quot;query&quot;</span>, <span class="string">&quot;_id&quot;</span>: <span class="string">&quot;3&quot;</span>&#125;&#125;</span><br><span class="line">&#123;<span class="string">&quot;delete&quot;</span>:&#123;<span class="string">&quot;_index&quot;</span>:<span class="string">&quot;query&quot;</span>, <span class="string">&quot;_id&quot;</span>: <span class="string">&quot;4&quot;</span>&#125;&#125;</span><br></pre></td></tr></table></figure><h2 id="1-6RestAPI-7-12版本"><a href="#1-6RestAPI-7-12版本" class="headerlink" title="1.6RestAPI(7.12版本)"></a>1.6RestAPI(7.12版本)</h2><h3 id="1-6-1初始化RestClient"><a href="#1-6-1初始化RestClient" class="headerlink" title="1.6.1初始化RestClient"></a>1.6.1初始化RestClient</h3><p>在elasticsearch提供的API中，与elasticsearch一切交互都封装在一个名为<code>RestHighLevelClient</code>的类中，必须先完成这个对象的初始化，建立与elasticsearch的连接。</p><p>1.分为三步：在<code>item-service</code>模块中引入<code>es</code>的<code>RestHighLevelClient</code>依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch-rest-high-level-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.因为SpringBoot默认的ES版本是<code>7.17.10</code>，所以我们需要覆盖默认的ES版本：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">elasticsearch.version</span>&gt;</span>7.12.1<span class="tag">&lt;/<span class="name">elasticsearch.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3.初始化RestHighLevelClient：</p><p>初始化的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RestHighLevelClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestHighLevelClient</span>(RestClient.builder(</span><br><span class="line">        HttpHost.create(<span class="string">&quot;http://192.168.150.101:9200&quot;</span>)</span><br><span class="line">));</span><br></pre></td></tr></table></figure><p>示例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package com.hmall.item.es;</span><br><span class="line"></span><br><span class="line">import org.apache.http.HttpHost;</span><br><span class="line">import org.elasticsearch.client.RestClient;</span><br><span class="line">import org.elasticsearch.client.RestHighLevelClient;</span><br><span class="line">import org.junit.jupiter.api.AfterEach;</span><br><span class="line">import org.junit.jupiter.api.BeforeEach;</span><br><span class="line">import org.junit.jupiter.api.Test;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class IndexTest &#123;</span><br><span class="line"></span><br><span class="line">    private RestHighLevelClient client;</span><br><span class="line"></span><br><span class="line">    @BeforeEach</span><br><span class="line">    void setUp() &#123;</span><br><span class="line">        this.client = new RestHighLevelClient(RestClient.builder(</span><br><span class="line">                HttpHost.create(&quot;http://192.168.150.101:9200&quot;)</span><br><span class="line">        ));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    void testConnect() &#123;</span><br><span class="line">        System.out.println(client);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @AfterEach</span><br><span class="line">    void tearDown() throws IOException &#123;</span><br><span class="line">        this.client.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-6-2-重点-创建索引库"><a href="#1-6-2-重点-创建索引库" class="headerlink" title="1.6.2*(重点).创建索引库"></a>1.6.2*(重点).创建索引库</h3><p>由于要实现对商品搜索，所以我们需要将商品添加到Elasticsearch中，不过需要根据搜索业务的需求来设定索引库结构，而不是一股脑的把MySQL数据写入Elasticsearch.</p><h4 id="1-Mapping映射"><a href="#1-Mapping映射" class="headerlink" title="1.Mapping映射"></a>1.Mapping映射</h4><p>对应的商品表结构如下，索引库无关字段已经划掉：</p><p><img src="https://pic.imgdb.cn/item/673d8c4fd29ded1a8cb3341d.png" alt="es-5"></p><p>结合数据库表结构，以上字段对应的mapping映射属性如下：</p><table><thead><tr><th><strong>字段名</strong></th><th><strong>字段类型</strong></th><th><strong>类型说明</strong></th><th>是否参与搜索</th><th>是否参与分词</th><th><strong>分词器</strong></th></tr></thead><tbody><tr><td>id</td><td><code>long</code></td><td>长整数</td><td>是</td><td></td><td>——</td></tr><tr><td>name</td><td><code>text</code></td><td>字符串，参与分词搜索</td><td>是</td><td>是</td><td>IK</td></tr><tr><td>price</td><td><code>integer</code></td><td>以分为单位，所以是整数</td><td>是</td><td></td><td>——</td></tr><tr><td>stock</td><td><code>integer</code></td><td>字符串，但需要分词</td><td>是</td><td></td><td>——</td></tr><tr><td>image</td><td><code>keyword</code></td><td>字符串，但是不分词</td><td></td><td></td><td>——</td></tr><tr><td>category</td><td><code>keyword</code></td><td>字符串，但是不分词</td><td>是</td><td></td><td>——</td></tr><tr><td>brand</td><td><code>keyword</code></td><td>字符串，但是不分词</td><td>是</td><td></td><td>——</td></tr><tr><td>sold</td><td><code>integer</code></td><td>销量，整数</td><td>是</td><td></td><td>——</td></tr><tr><td>commentCount</td><td><code>integer</code></td><td>评价，整数</td><td></td><td></td><td>——</td></tr><tr><td>isAD</td><td><code>boolean</code></td><td>布尔类型</td><td>是</td><td></td><td>——</td></tr><tr><td>updateTime</td><td><code>Date</code></td><td>更新时间</td><td>是</td><td></td><td>——</td></tr></tbody></table><p>因此，最终我们的索引库文档结构应该是这样：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">PUT /items</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;mappings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_max_word&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;integer&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;stock&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;integer&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;image&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;category&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;brand&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;sold&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;integer&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;commentCount&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;integer&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;isAD&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;boolean&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;updateTime&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;date&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="2-创建索引"><a href="#2-创建索引" class="headerlink" title="2.创建索引"></a>2.创建索引</h4><p>创建索引库的API如下：</p><p>代码分为三步：</p><ul><li>1）创建Request对象。<ul><li>因为是创建索引库的操作，因此Request是<code>CreateIndexRequest</code>。</li></ul></li><li>2）添加请求参数<ul><li>其实就是Json格式的Mapping映射参数。因为json字符串很长，这里是定义了静态字符串常量<code>MAPPING_TEMPLATE</code>，让代码看起来更加优雅。</li></ul></li><li>3）发送请求<ul><li>client.indices()方法的返回值是IndicesClient类型，封装了所有与索引库操作有关的方法。例如创建索引、删除索引、判断索引是否存在等</li></ul></li></ul><p>代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testCreateIndex</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.创建Request对象</span></span><br><span class="line">    <span class="type">CreateIndexRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CreateIndexRequest</span>(<span class="string">&quot;items&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.准备请求参数</span></span><br><span class="line">    request.source(MAPPING_TEMPLATE, XContentType.JSON);</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    client.indices().create(request, RequestOptions.DEFAULT);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">MAPPING_TEMPLATE</span> <span class="operator">=</span> <span class="string">&quot;&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;  \&quot;mappings\&quot;: &#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;    \&quot;properties\&quot;: &#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;id\&quot;: &#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;keyword\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;name\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;text\&quot;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;analyzer\&quot;: \&quot;ik_max_word\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;price\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;integer\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;stock\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;integer\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;image\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;keyword\&quot;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;index\&quot;: false\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;category\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;keyword\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;brand\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;keyword\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;sold\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;integer\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;commentCount\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;integer\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;isAD\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;boolean\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;,\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      \&quot;updateTime\&quot;:&#123;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;        \&quot;type\&quot;: \&quot;date\&quot;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      &#125;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;    &#125;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;  &#125;\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;&#125;&quot;</span>;</span><br></pre></td></tr></table></figure><h4 id="3-删除索引库"><a href="#3-删除索引库" class="headerlink" title="3.删除索引库"></a>3.删除索引库</h4><ul><li>1）创建Request对象。这次是DeleteIndexRequest对象</li><li>2）准备参数。这里是无参，因此省略</li><li>3）发送请求。改用delete方法</li></ul><p>示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testDeleteIndex</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.创建Request对象</span></span><br><span class="line">    <span class="type">DeleteIndexRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeleteIndexRequest</span>(<span class="string">&quot;items&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.发送请求</span></span><br><span class="line">    client.indices().delete(request, RequestOptions.DEFAULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-判断索引库是否存在"><a href="#4-判断索引库是否存在" class="headerlink" title="4.判断索引库是否存在"></a>4.判断索引库是否存在</h4><p>判断索引库是否存在，本质就是查询，对应的请求语句是：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /hotel</span><br></pre></td></tr></table></figure><p>因此与删除的Java代码流程是类似的，流程如下：</p><ul><li>1）创建Request对象。这次是GetIndexRequest对象</li><li>2）准备参数。这里是无参，直接省略</li><li>3）发送请求。改用exists方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testExistsIndex</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.创建Request对象</span></span><br><span class="line">    <span class="type">GetIndexRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GetIndexRequest</span>(<span class="string">&quot;items&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.发送请求</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">exists</span> <span class="operator">=</span> client.indices().exists(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 3.输出</span></span><br><span class="line">    System.err.println(exists ? <span class="string">&quot;索引库已经存在！&quot;</span> : <span class="string">&quot;索引库不存在！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-7文档CRUD-RestClient"><a href="#1-7文档CRUD-RestClient" class="headerlink" title="1.7文档CRUD(RestClient)"></a>1.7文档CRUD(RestClient)</h2><h3 id="1-新增文档"><a href="#1-新增文档" class="headerlink" title="1.新增文档"></a>1.新增文档</h3><p>我们需要将数据库中的商品信息导入elasticsearch中，而不是造假数据了。</p><h4 id="1-1实体类"><a href="#1-1实体类" class="headerlink" title="1.1实体类"></a>1.1实体类</h4><p>索引库结构与数据库结构还存在一些差异，因此我们要定义一个索引库结构对应的实体。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hmall.item.domain.po;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiModel;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiModelProperty;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ApiModel(description = &quot;索引库实体&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ItemDoc</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;商品id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;商品名称&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;价格（分）&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer price;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;商品图片&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String image;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;类目名称&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String category;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;品牌名称&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String brand;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;销量&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer sold;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;评论数&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer commentCount;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;是否是推广广告，true/false&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Boolean isAD;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;更新时间&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime updateTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2API语法"><a href="#1-2API语法" class="headerlink" title="1.2API语法"></a>1.2API语法</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST /<span class="punctuation">&#123;</span>索引库名<span class="punctuation">&#125;</span>/_doc/<span class="number">1</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Jack&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">21</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>与索引库操作的API非常类似，同样是三步走：</p><ul><li>1）创建Request对象，这里是<code>IndexRequest</code>，因为添加文档就是创建倒排索引的过程</li><li>2）准备请求参数，本例中就是Json文档</li><li>3）发送请求</li><li>变化的地方在于，这里直接使用<code>client.xxx()</code>的API，不再需要<code>client.indices()</code>了。</li></ul><p><img src="https://pic.imgdb.cn/item/673d8c5ad29ded1a8cb34199.png" alt="es-6"></p><h4 id="1-3完整代码"><a href="#1-3完整代码" class="headerlink" title="1.3完整代码"></a>1.3完整代码</h4><p>我们导入商品数据，除了参考API模板“三步走”以外，还需要做几点准备工作：</p><ul><li>商品数据来自于数据库，我们需要先查询出来，得到<code>Item</code>对象</li><li><code>Item</code>对象需要转为<code>ItemDoc</code>对象</li><li><code>ItemDTO</code>需要序列化为<code>json</code>格式</li></ul><p>因此，代码整体步骤如下：</p><ul><li>1）根据id查询商品数据<code>Item</code></li><li>2）将<code>Item</code>封装为<code>ItemDoc</code></li><li>3）将<code>ItemDoc</code>序列化为JSON</li><li>4）创建IndexRequest，指定索引库名和id</li><li>5）准备请求参数，也就是JSON文档</li><li>6）发送请求</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">void testAddDocument() throws IOException &#123;</span><br><span class="line">    // 1.根据id查询商品数据</span><br><span class="line">    Item item = itemService.getById(100002644680L);</span><br><span class="line">    // 2.转换为文档类型</span><br><span class="line">    ItemDoc itemDoc = BeanUtil.copyProperties(item, ItemDoc.class);</span><br><span class="line">    // 3.将ItemDTO转json</span><br><span class="line">    String doc = JSONUtil.toJsonStr(itemDoc);</span><br><span class="line"></span><br><span class="line">    // 1.准备Request对象</span><br><span class="line">    IndexRequest request = new IndexRequest(&quot;items&quot;).id(itemDoc.getId());</span><br><span class="line">    // 2.准备Json文档</span><br><span class="line">    request.source(doc, XContentType.JSON);</span><br><span class="line">    // 3.发送请求</span><br><span class="line">    client.index(request, RequestOptions.DEFAULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-查询文档"><a href="#2-查询文档" class="headerlink" title="2.查询文档"></a>2.查询文档</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /<span class="punctuation">&#123;</span>索引库名<span class="punctuation">&#125;</span>/_doc/<span class="punctuation">&#123;</span>id<span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="2-1完整代码"><a href="#2-1完整代码" class="headerlink" title="2.1完整代码"></a>2.1完整代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testGetDocumentById</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.准备Request对象</span></span><br><span class="line">    <span class="type">GetRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GetRequest</span>(<span class="string">&quot;items&quot;</span>).id(<span class="string">&quot;100002644680&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.发送请求</span></span><br><span class="line">    <span class="type">GetResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.get(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 3.获取响应结果中的source</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> response.getSourceAsString();</span><br><span class="line">    </span><br><span class="line">    <span class="type">ItemDoc</span> <span class="variable">itemDoc</span> <span class="operator">=</span> JSONUtil.toBean(json, ItemDoc.class);</span><br><span class="line">    System.out.println(<span class="string">&quot;itemDoc= &quot;</span> + ItemDoc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-删除文档"><a href="#3-删除文档" class="headerlink" title="3.删除文档"></a>3.删除文档</h3><p>删除的请求语句如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE /hotel/_doc/<span class="punctuation">&#123;</span>id<span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testDeleteDocument</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.准备Request，两个参数，第一个是索引库名，第二个是文档id</span></span><br><span class="line">    <span class="type">DeleteRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeleteRequest</span>(<span class="string">&quot;item&quot;</span>, <span class="string">&quot;100002644680&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.发送请求</span></span><br><span class="line">    client.delete(request, RequestOptions.DEFAULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-修改文档"><a href="#4-修改文档" class="headerlink" title="4.修改文档"></a>4.修改文档</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testUpdateDocument</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.准备Request</span></span><br><span class="line">    <span class="type">UpdateRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UpdateRequest</span>(<span class="string">&quot;items&quot;</span>, <span class="string">&quot;100002644680&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.准备请求参数</span></span><br><span class="line">    request.doc(</span><br><span class="line">            <span class="string">&quot;price&quot;</span>, <span class="number">58800</span>,</span><br><span class="line">            <span class="string">&quot;commentCount&quot;</span>, <span class="number">1</span></span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    client.update(request, RequestOptions.DEFAULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-批量导入文档-重点"><a href="#5-批量导入文档-重点" class="headerlink" title="5.批量导入文档(*重点)"></a>5.批量导入文档(*重点)</h3><ul><li>利用JavaAPI批量导入<ul><li>需要编码，但基于JavaAPI，学习成本低</li><li>更加灵活，可以任意对数据做再加工处理后写入索引库</li></ul></li></ul><p>批处理与前面讲的文档的CRUD步骤基本一致：</p><ul><li>创建Request，但这次用的是<code>BulkRequest</code></li><li>准备请求参数</li><li>发送请求，这次要用到<code>client.bulk()</code>方法</li></ul><p>可以看到，能添加的请求有：</p><ul><li><code>IndexRequest</code>，也就是新增</li><li><code>UpdateRequest</code>，也就是修改</li><li><code>DeleteRequest</code>，也就是删除</li></ul><p>批量新增功能示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testBulk</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.创建Request</span></span><br><span class="line">    <span class="type">BulkRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BulkRequest</span>();</span><br><span class="line">    <span class="comment">// 2.准备请求参数</span></span><br><span class="line">    request.add(<span class="keyword">new</span> <span class="title class_">IndexRequest</span>(<span class="string">&quot;items&quot;</span>).id(<span class="string">&quot;1&quot;</span>).source(<span class="string">&quot;json doc1&quot;</span>, XContentType.JSON));</span><br><span class="line">    request.add(<span class="keyword">new</span> <span class="title class_">IndexRequest</span>(<span class="string">&quot;items&quot;</span>).id(<span class="string">&quot;2&quot;</span>).source(<span class="string">&quot;json doc2&quot;</span>, XContentType.JSON));</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    client.bulk(request, RequestOptions.DEFAULT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-1完整代码"><a href="#5-1完整代码" class="headerlink" title="5.1完整代码"></a>5.1完整代码</h4><p>当我们要导入商品数据时，由于商品数量达到数十万，因此不可能一次性全部导入。建议采用循环遍历方式，每次导入1000条左右的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testLoadItemDocs</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 分页查询商品数据</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">pageNo</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        Page&lt;Item&gt; page = itemService.lambdaQuery().eq(Item::getStatus, <span class="number">1</span>).page(<span class="keyword">new</span> <span class="title class_">Page</span>&lt;Item&gt;(pageNo, size));</span><br><span class="line">        <span class="comment">// 非空校验</span></span><br><span class="line">        List&lt;Item&gt; items = page.getRecords();</span><br><span class="line">        <span class="keyword">if</span> (CollUtils.isEmpty(items)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;加载第&#123;&#125;页数据，共&#123;&#125;条&quot;</span>, pageNo, items.size());</span><br><span class="line">        <span class="comment">// 1.创建Request</span></span><br><span class="line">        <span class="type">BulkRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BulkRequest</span>(<span class="string">&quot;items&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.准备参数，添加多个新增的Request</span></span><br><span class="line">        <span class="keyword">for</span> (Item item : items) &#123;</span><br><span class="line">            <span class="comment">// 2.1.转换为文档类型ItemDTO</span></span><br><span class="line">            <span class="type">ItemDoc</span> <span class="variable">itemDoc</span> <span class="operator">=</span> BeanUtil.copyProperties(item, ItemDoc.class);</span><br><span class="line">            <span class="comment">// 2.2.创建新增文档的Request对象</span></span><br><span class="line">            request.add(<span class="keyword">new</span> <span class="title class_">IndexRequest</span>()</span><br><span class="line">                            .id(itemDoc.getId())</span><br><span class="line">                            .source(JSONUtil.toJsonStr(itemDoc), XContentType.JSON));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.发送请求</span></span><br><span class="line">        client.bulk(request, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 翻页</span></span><br><span class="line">        pageNo++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-Elasticsearch-进阶版本"><a href="#2-Elasticsearch-进阶版本" class="headerlink" title="2.Elasticsearch(进阶版本)"></a>2.Elasticsearch(进阶版本)</h1><h2 id="2-1DSL查询"><a href="#2-1DSL查询" class="headerlink" title="2.1DSL查询"></a>2.1DSL查询</h2><p>elasticsearch的数据搜索功能。Elasticsearch提供了基于JSON的DSL（<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.12/query-dsl.html">Domain Specific Language</a>）语句来定义查询条件，其JavaAPI就是在组织DSL条件。</p><p>Elasticsearch的查询可以分为两大类：</p><ul><li><strong>叶子查询（Leaf</strong> <strong>query</strong> <strong>clauses）</strong>：一般是在特定的字段里查询特定值，属于简单查询，很少单独使用。</li><li><strong>复合查询（Compound</strong> <strong>query</strong> <strong>clauses）</strong>：以逻辑方式组合多个叶子查询或者更改叶子查询的行为方式。</li></ul><h2 id="2-2RestClient查询"><a href="#2-2RestClient查询" class="headerlink" title="2.2RestClient查询"></a>2.2RestClient查询</h2><p>文档的查询依然使用昨天学习的 <code>RestHighLevelClient</code>对象，查询的基本步骤如下：</p><ul><li>1）创建<code>request</code>对象，这次是搜索，所以是<code>SearchRequest</code></li><li>2）准备请求参数，也就是查询DSL对应的JSON参数</li><li>3）发起请求</li><li>4）解析响应，响应结果相对复杂，需要逐层解析</li></ul><p>由于Elasticsearch对外暴露的接口都是Restful风格的接口，因此JavaAPI调用就是在发送Http请求。而我们核心要做的就是利用<strong>利用Java代码组织请求参数</strong>，<strong>解析响应结果</strong>。</p><h3 id="2-2-1发送请求"><a href="#2-2-1发送请求" class="headerlink" title="2.2.1发送请求"></a>2.2.1发送请求</h3><p>首先以<code>match_all</code>查询为例，其DSL和JavaAPI的对比如图：</p><p><img src="https://pic.imgdb.cn/item/673d8c5ad29ded1a8cb34224.png" alt="es-7"></p><p>代码解读：</p><ul><li>第一步，创建<code>SearchRequest</code>对象，指定索引库名 </li><li>第二步，利用<code>request.source()</code>构建DSL，DSL中可以包含查询、分页、排序、高亮等 </li><li><code>query()</code>：代表查询条件，利用<code>QueryBuilders.matchAllQuery()</code>构建一个<code>match_all</code>查询的DSL</li><li>第三步，利用<code>client.search()</code>发送请求，得到响应</li></ul><p>这里关键的API有两个，一个是<code>request.source()</code>，它构建的就是DSL中的完整JSON参数。其中包含了<code>query</code>、<code>sort</code>、<code>from</code>、<code>size</code>、<code>highlight</code>等所有功能：</p><p><img src="https://pic.imgdb.cn/item/673d8c5bd29ded1a8cb3429a.png" alt="es-8"></p><p>另一个是<code>QueryBuilders</code>，其中包含了我们学习过的各种<strong>叶子查询</strong>、<strong>复合查询</strong>等：</p><p><img src="https://pic.imgdb.cn/item/673d8c5bd29ded1a8cb342f9.png" alt="es-9"></p><h3 id="2-2-2解析响应结果"><a href="#2-2-2解析响应结果" class="headerlink" title="2.2.2解析响应结果"></a>2.2.2解析响应结果</h3><p>在发送请求以后，得到了响应结果<code>SearchResponse</code>，这个类的结构与我们在kibana中看到的响应结果JSON结构完全一致：</p><p><img src="https://pic.imgdb.cn/item/673d8c5ad29ded1a8cb34133.png" alt="es-10"></p><p><strong>代码解读</strong>：</p><p>elasticsearch返回的结果是一个JSON字符串，结构包含：</p><ul><li><code>hits</code>：命中的结果 <ul><li><code>total</code>：总条数，其中的value是具体的总条数值</li><li><code>max_score</code>：所有结果中得分最高的文档的相关性算分</li><li><code>hits</code>：搜索结果的文档数组，其中的每个文档都是一个json对象 <ul><li><code>_source</code>：文档中的原始数据，也是json对象</li></ul></li></ul></li></ul><p>因此，我们解析响应结果，就是逐层解析JSON字符串，流程如下：</p><ul><li><code>SearchHits</code>：通过<code>response.getHits()</code>获取，就是JSON中的最外层的<code>hits</code>，代表命中的结果 <ul><li><code>SearchHits#getTotalHits().value</code>：获取总条数信息</li><li><code>SearchHits#getHits()</code>：获取<code>SearchHit</code>数组，也就是文档数组 <ul><li><code>SearchHit#getSourceAsString()</code>：获取文档结果中的<code>_source</code>，也就是原始的<code>json</code>文档数据</li></ul></li></ul></li></ul><h3 id="2-2-3总结"><a href="#2-2-3总结" class="headerlink" title="2.2.3总结"></a>2.2.3总结</h3><p>文档搜索的基本步骤是：</p><ol><li>创建<code>SearchRequest</code>对象</li><li>准备<code>request.source()</code>，也就是DSL。<ol><li><code>QueryBuilders</code>来构建查询条件</li><li>传入<code>request.source()</code> 的<code>query()</code>方法</li></ol></li><li>发送请求，得到结果</li><li>解析结果（参考JSON结果，从外到内，逐层解析）</li></ol><h3 id="2-2-4完整代码"><a href="#2-2-4完整代码" class="headerlink" title="2.2.4完整代码"></a>2.2.4完整代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testMatchAll</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.创建Request</span></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;items&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.组织请求参数</span></span><br><span class="line">    request.source().query(QueryBuilders.matchAllQuery());</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    handleResponse(response);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleResponse</span><span class="params">(SearchResponse response)</span> &#123;</span><br><span class="line">    <span class="type">SearchHits</span> <span class="variable">searchHits</span> <span class="operator">=</span> response.getHits();</span><br><span class="line">    <span class="comment">// 1.获取总条数</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">total</span> <span class="operator">=</span> searchHits.getTotalHits().value;</span><br><span class="line">    System.out.println(<span class="string">&quot;共搜索到&quot;</span> + total + <span class="string">&quot;条数据&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.遍历结果数组</span></span><br><span class="line">    SearchHit[] hits = searchHits.getHits();</span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : hits) &#123;</span><br><span class="line">        <span class="comment">// 3.得到_source，也就是原始json文档</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">source</span> <span class="operator">=</span> hit.getSourceAsString();</span><br><span class="line">        <span class="comment">// 4.反序列化并打印</span></span><br><span class="line">        <span class="type">ItemDoc</span> <span class="variable">item</span> <span class="operator">=</span> JSONUtil.toBean(source, ItemDoc.class);</span><br><span class="line">        System.out.println(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3叶子查询"><a href="#2-3叶子查询" class="headerlink" title="2.3叶子查询"></a>2.3叶子查询</h2><h3 id="2-3-1全文检索查询"><a href="#2-3-1全文检索查询" class="headerlink" title="2.3.1全文检索查询"></a>2.3.1全文检索查询</h3><ul><li>利用分词器对用户输入搜索条件先分词，得到词条，然后再利用倒排索引搜索词条。例如：<ul><li><code>match</code>：</li><li><code>multi_match</code></li></ul></li></ul><p>以全文检索中的<code>match</code>为例，语法如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /<span class="punctuation">&#123;</span>索引库名<span class="punctuation">&#125;</span>/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;字段名&quot;</span><span class="punctuation">:</span> <span class="string">&quot;搜索条件&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>与<code>match</code>类似的还有<code>multi_match</code>，区别在于可以同时对多个字段搜索，而且多个字段都要满足，语法示例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET /<span class="punctuation">&#123;</span>索引库名<span class="punctuation">&#125;</span>/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;multi_match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="string">&quot;搜索条件&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;fields&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;字段1&quot;</span><span class="punctuation">,</span> <span class="string">&quot;字段2&quot;</span><span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="2-3-2精确查询"><a href="#2-3-2精确查询" class="headerlink" title="2.3.2精确查询"></a>2.3.2精确查询</h3><ul><li><p>不对用户输入搜索条件分词，根据字段内容精确值匹配。但只能查找keyword、数值、日期、boolean类型的字段。例如：</p><ul><li><code>ids</code></li><li><code>term</code></li><li><code>range</code></li></ul></li></ul><p>所有的查询条件都是由QueryBuilders来构建的，叶子查询也不例外。因此整套代码中变化的部分仅仅是query条件构造的方式，其它不动。</p><p>例如<code>match</code>查询：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testMatch</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.创建Request</span></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;items&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.组织请求参数</span></span><br><span class="line">    request.source().query(QueryBuilders.matchQuery(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;脱脂牛奶&quot;</span>));</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    handleResponse(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再比如<code>multi_match</code>查询：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testMultiMatch</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.创建Request</span></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;items&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.组织请求参数</span></span><br><span class="line">    request.source().query(QueryBuilders.multiMatchQuery(<span class="string">&quot;脱脂牛奶&quot;</span>, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;category&quot;</span>));</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    handleResponse(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有<code>range</code>查询：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testRange</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.创建Request</span></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;items&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.组织请求参数</span></span><br><span class="line">    request.source().query(QueryBuilders.rangeQuery(<span class="string">&quot;price&quot;</span>).gte(<span class="number">10000</span>).lte(<span class="number">30000</span>));</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    handleResponse(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有<code>term</code>查询：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testTerm</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.创建Request</span></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;items&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.组织请求参数</span></span><br><span class="line">    request.source().query(QueryBuilders.termQuery(<span class="string">&quot;brand&quot;</span>, <span class="string">&quot;华为&quot;</span>));</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    handleResponse(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4复合查询"><a href="#2-4复合查询" class="headerlink" title="2.4复合查询"></a>2.4复合查询</h2><h3 id="2-4-1bool查询"><a href="#2-4-1bool查询" class="headerlink" title="2.4.1bool查询"></a>2.4.1bool查询</h3><p>bool查询，即布尔查询。就是利用逻辑运算来组合一个或多个查询子句的组合。bool查询支持的逻辑运算有：</p><ul><li>must：必须匹配每个子查询，类似“与”</li><li>should：选择性匹配子查询，类似“或”</li><li>must_not：必须不匹配，<strong>不参与算分</strong>，类似“非”</li><li>filter：必须匹配，<strong>不参与算分</strong></li></ul><p>bool查询的语法如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">GET /items/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;bool&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;must&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;手机&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;should&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;term&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;brand&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vivo&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;term&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;brand&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;小米&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;must_not&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;range&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;gte&quot;</span><span class="punctuation">:</span> <span class="number">2500</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;filter&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;range&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;lte&quot;</span><span class="punctuation">:</span> <span class="number">1000</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>出于性能考虑，与搜索关键字无关的查询尽量采用must_not或filter逻辑运算，避免参与相关性算分。</p><p>例如该**商城的搜索页面：</p><p><img src="https://pic.imgdb.cn/item/673d8c62d29ded1a8cb34b88.png" alt="es-11"></p><p>其中输入框的搜索条件肯定要参与相关性算分，可以采用match。但是价格范围过滤、品牌过滤、分类过滤等尽量采用filter，不要参与相关性算分。</p><p>比如，我们要搜索<code>手机</code>，但品牌必须是<code>华为</code>，价格必须是<code>900~1599</code>，那么可以这样写：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">GET /items/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;bool&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;must&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;手机&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;filter&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;term&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;brand&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;华为&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span><span class="attr">&quot;range&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;gte&quot;</span><span class="punctuation">:</span> <span class="number">90000</span><span class="punctuation">,</span> <span class="attr">&quot;lt&quot;</span><span class="punctuation">:</span> <span class="number">159900</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>复合查询也是由<code>QueryBuilders</code>来构建，我们以<code>bool</code>查询为例，DSL和JavaAPI的对比如图：</p><p><img src="https://pic.imgdb.cn/item/673d8c63d29ded1a8cb34bfd.png" alt="es-12"></p><p>完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testBool</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.创建Request</span></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;items&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.组织请求参数</span></span><br><span class="line">    <span class="comment">// 2.1.准备bool查询</span></span><br><span class="line">    <span class="type">BoolQueryBuilder</span> <span class="variable">bool</span> <span class="operator">=</span> QueryBuilders.boolQuery();</span><br><span class="line">    <span class="comment">// 2.2.关键字搜索</span></span><br><span class="line">    bool.must(QueryBuilders.matchQuery(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;脱脂牛奶&quot;</span>));</span><br><span class="line">    <span class="comment">// 2.3.品牌过滤</span></span><br><span class="line">    bool.filter(QueryBuilders.termQuery(<span class="string">&quot;brand&quot;</span>, <span class="string">&quot;德亚&quot;</span>));</span><br><span class="line">    <span class="comment">// 2.4.价格过滤</span></span><br><span class="line">    bool.filter(QueryBuilders.rangeQuery(<span class="string">&quot;price&quot;</span>).lte(<span class="number">30000</span>));</span><br><span class="line">    request.source().query(bool);</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    handleResponse(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-5排序和分页"><a href="#2-5排序和分页" class="headerlink" title="2.5排序和分页"></a>2.5排序和分页</h2><h3 id="1-排序"><a href="#1-排序" class="headerlink" title="1.排序"></a>1.排序</h3><p>elasticsearch默认是根据相关度算分（<code>_score</code>）来排序，但是也支持自定义方式对搜索结果排序。不过分词字段无法排序，能参与排序字段类型有：<code>keyword</code>类型、数值类型、地理坐标类型、日期类型等。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GET /indexName/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;排序字段&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;order&quot;</span><span class="punctuation">:</span> <span class="string">&quot;排序方式asc和desc&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="2-基础分页"><a href="#2-基础分页" class="headerlink" title="2.基础分页"></a>2.基础分页</h3><p>elasticsearch中通过修改<code>from</code>、<code>size</code>参数来控制要返回的分页结果：</p><ul><li><code>from</code>：从第几个文档开始</li><li><code>size</code>：总共查询几个文档</li></ul><p>类似于mysql中的<code>limit ?, ?</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">GET /items/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match_all&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;from&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span> <span class="comment">// 分页开始的位置，默认为0</span></span><br><span class="line">  <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span>  <span class="comment">// 每页文档数量，默认10</span></span><br><span class="line">  <span class="attr">&quot;sort&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;order&quot;</span><span class="punctuation">:</span> <span class="string">&quot;desc&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="3-深度分页"><a href="#3-深度分页" class="headerlink" title="3.深度分页"></a>3.深度分页</h3><p>elasticsearch会禁止<code>from+ size </code>超过10000的请求。</p><p>针对深度分页，elasticsearch提供了两种解决方案：</p><ul><li><code>search after</code>：分页时需要排序，原理是从上一次的排序值开始，查询下一页数据。官方推荐使用的方式。</li><li><code>scroll</code>：原理将排序后的文档id形成快照，保存下来，基于快照做分页。官方已经不推荐使用。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">总结：</span><br><span class="line">大多数情况下，我们采用普通分页就可以了。查看百度、京东等网站，会发现其分页都有限制。例如百度最多支持77页，每页不足20条。京东最多100页，每页最多60条。</span><br><span class="line">因此，一般我们采用限制分页深度的方式即可，无需实现深度分页。</span><br></pre></td></tr></table></figure><h3 id="4-完整代码"><a href="#4-完整代码" class="headerlink" title="4.完整代码"></a>4.完整代码</h3><p>之前说过，<code>requeset.source()</code>就是整个请求JSON参数，所以排序、分页都是基于这个来设置，其DSL和JavaAPI的对比如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testPageAndSort</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pageNo</span> <span class="operator">=</span> <span class="number">1</span>, pageSize = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建Request</span></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;items&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.组织请求参数</span></span><br><span class="line">    <span class="comment">// 2.1.搜索条件参数</span></span><br><span class="line">    request.source().query(QueryBuilders.matchQuery(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;脱脂牛奶&quot;</span>));</span><br><span class="line">    <span class="comment">// 2.2.排序参数</span></span><br><span class="line">    request.source().sort(<span class="string">&quot;price&quot;</span>, SortOrder.ASC);</span><br><span class="line">    <span class="comment">// 2.3.分页参数</span></span><br><span class="line">    request.source().from((pageNo - <span class="number">1</span>) * pageSize).size(pageSize);</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    handleResponse(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-6高亮展示"><a href="#2-6高亮展示" class="headerlink" title="2.6高亮展示"></a>2.6高亮展示</h2><p>elasticsearch已经提供了给搜索关键字加标签的语法，无需我们自己编码。</p><p>基本语法如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">GET /<span class="punctuation">&#123;</span>索引库名<span class="punctuation">&#125;</span>/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;match&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;搜索字段&quot;</span><span class="punctuation">:</span> <span class="string">&quot;搜索关键字&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;highlight&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;fields&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;高亮字段名称&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;pre_tags&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;em&gt;&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;post_tags&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&lt;/em&gt;&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><ul><li>搜索必须有查询条件，而且是全文检索类型的查询条件，例如<code>match</code></li><li>参与高亮的字段必须是<code>text</code>类型的字段</li><li>默认情况下参与高亮的字段要与搜索字段一致，除非添加：<code>required_field_match=false</code></li></ul><p>高亮查询与前面的查询有两点不同：</p><ul><li>条件同样是在<code>request.source()</code>中指定，只不过高亮条件要基于<code>HighlightBuilder</code>来构造</li><li>高亮响应结果与搜索的文档结果不在一起，需要单独解析</li></ul><p>首先来看高亮条件构造，其DSL和JavaAPI的对比如图：</p><p><img src="https://pic.imgdb.cn/item/673d8c63d29ded1a8cb34ca1.png" alt="es-13"></p><p>示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testHighlight</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.创建Request</span></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;items&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.组织请求参数</span></span><br><span class="line">    <span class="comment">// 2.1.query条件</span></span><br><span class="line">    request.source().query(QueryBuilders.matchQuery(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;脱脂牛奶&quot;</span>));</span><br><span class="line">    <span class="comment">// 2.2.高亮条件</span></span><br><span class="line">    request.source().highlighter(</span><br><span class="line">            SearchSourceBuilder.highlight()</span><br><span class="line">                    .field(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">                    .preTags(<span class="string">&quot;&lt;em&gt;&quot;</span>)</span><br><span class="line">                    .postTags(<span class="string">&quot;&lt;/em&gt;&quot;</span>)</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    handleResponse(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleResponse</span><span class="params">(SearchResponse response)</span> &#123;</span><br><span class="line">    <span class="type">SearchHits</span> <span class="variable">searchHits</span> <span class="operator">=</span> response.getHits();</span><br><span class="line">    <span class="comment">// 1.获取总条数</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">total</span> <span class="operator">=</span> searchHits.getTotalHits().value;</span><br><span class="line">    System.out.println(<span class="string">&quot;共搜索到&quot;</span> + total + <span class="string">&quot;条数据&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.遍历结果数组</span></span><br><span class="line">    SearchHit[] hits = searchHits.getHits();</span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : hits) &#123;</span><br><span class="line">        <span class="comment">// 3.得到_source，也就是原始json文档</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">source</span> <span class="operator">=</span> hit.getSourceAsString();</span><br><span class="line">        <span class="comment">// 4.反序列化</span></span><br><span class="line">        <span class="type">ItemDoc</span> <span class="variable">item</span> <span class="operator">=</span> JSONUtil.toBean(source, ItemDoc.class);</span><br><span class="line">        <span class="comment">// 5.获取高亮结果</span></span><br><span class="line">        Map&lt;String, HighlightField&gt; hfs = hit.getHighlightFields();</span><br><span class="line">        <span class="keyword">if</span> (CollUtils.isNotEmpty(hfs)) &#123;</span><br><span class="line">            <span class="comment">// 5.1.有高亮结果，获取name的高亮结果</span></span><br><span class="line">            <span class="type">HighlightField</span> <span class="variable">hf</span> <span class="operator">=</span> hfs.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (hf != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 5.2.获取第一个高亮结果片段，就是商品名称的高亮值</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">hfName</span> <span class="operator">=</span> hf.getFragments()[<span class="number">0</span>].string();</span><br><span class="line">                item.setName(hfName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-7数据聚合"><a href="#2-7数据聚合" class="headerlink" title="2.7数据聚合"></a>2.7数据聚合</h2><p>聚合（<code>aggregations</code>）可以让我们极其方便的实现对数据的统计、分析、运算。例如：</p><ul><li>什么品牌的手机最受欢迎？</li><li>这些手机的平均价格、最高价格、最低价格？</li><li>这些手机每月的销售情况如何？</li></ul><p>实现这些统计功能的比数据库的sql要方便的多，而且查询速度非常快，可以实现近实时搜索效果。</p><p>聚合常见的有三类：</p><p>桶（Bucket）聚合：用来对文档做分组 TermAggregation：按照文档字段值分组，例如按照品牌值分组、按照国家分组Date Histogram：按照日期阶梯分组，例如一周为一组，或者一月为一组</p><p>度量（Metric）聚合：用以计算一些值，比如：最大值、最小值、平均值等 Avg：求平均值Max：求最大值Min：求最小值Stats：同时求max、min、avg、sum等</p><p>管道（pipeline）聚合：其它聚合的结果为基础做进一步运算 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意：参加聚合的字段必须是keyword、日期、数值、布尔类型</span><br></pre></td></tr></table></figure><h3 id="2-7-1Bucket聚合"><a href="#2-7-1Bucket聚合" class="headerlink" title="2.7.1Bucket聚合"></a>2.7.1Bucket聚合</h3><p>例如我们要统计所有商品中共有哪些商品分类，其实就是以分类（category）字段对数据分组。category值一样的放在同一组，属于<code>Bucket</code>聚合中的<code>Term</code>聚合。</p><p>基本语法如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">GET /items/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span> </span><br><span class="line">  <span class="attr">&quot;aggs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;category_agg&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;terms&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;category&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">20</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>语法说明：</p><ul><li><code>size</code>：设置<code>size</code>为0，就是每页查0条，则结果中就不包含文档，只包含聚合</li><li><code>aggs</code>：定义聚合<ul><li><code>category_agg</code>：聚合名称，自定义，但不能重复<ul><li><code>terms</code>：聚合的类型，按分类聚合，所以用<code>term</code><ul><li><code>field</code>：参与聚合的字段名称</li><li><code>size</code>：希望返回的聚合结果的最大数量</li></ul></li></ul></li></ul></li></ul><p><img src="https://pic.imgdb.cn/item/673d8c63d29ded1a8cb34cf0.png" alt="es-14"></p><h3 id="2-7-2带条件聚合"><a href="#2-7-2带条件聚合" class="headerlink" title="2.7.2带条件聚合"></a>2.7.2带条件聚合</h3><p>默认情况下，Bucket聚合是对索引库的所有文档做聚合，例如我们统计商品中所有的品牌，结果如下：</p><p><img src="https://pic.imgdb.cn/item/673d8c64d29ded1a8cb34d5e.png" alt="es-15"></p><p>可以看到统计出的品牌非常多。</p><p>但真实场景下，用户会输入搜索条件，因此聚合必须是对搜索结果聚合。那么聚合必须添加限定条件。</p><p>例如，我想知道价格高于3000元的手机品牌有哪些，该怎么统计呢？</p><p>我们需要从需求中分析出搜索查询的条件和聚合的目标：</p><ul><li>搜索查询条件：<ul><li>价格高于3000</li><li>必须是手机</li></ul></li><li>聚合目标：统计的是品牌，肯定是对brand字段做term聚合</li></ul><p>语法如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">GET /items/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;bool&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;filter&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;term&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;category&quot;</span><span class="punctuation">:</span> <span class="string">&quot;手机&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;range&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">              <span class="attr">&quot;gte&quot;</span><span class="punctuation">:</span> <span class="number">300000</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">  <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span> </span><br><span class="line">  <span class="attr">&quot;aggs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;brand_agg&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;terms&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;brand&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">20</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>聚合结果如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;took&quot;</span> <span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;timed_out&quot;</span> <span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;hits&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;total&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;value&quot;</span> <span class="punctuation">:</span> <span class="number">13</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;relation&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;eq&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;max_score&quot;</span> <span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;hits&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span> <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;aggregations&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;brand_agg&quot;</span> <span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;doc_count_error_upper_bound&quot;</span> <span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;sum_other_doc_count&quot;</span> <span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;buckets&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;key&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;华为&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;doc_count&quot;</span> <span class="punctuation">:</span> <span class="number">7</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;key&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;Apple&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;doc_count&quot;</span> <span class="punctuation">:</span> <span class="number">5</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;key&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;小米&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;doc_count&quot;</span> <span class="punctuation">:</span> <span class="number">1</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>可以看到，结果中只剩下3个品牌了。</p><h3 id="2-7-3Metric聚合"><a href="#2-7-3Metric聚合" class="headerlink" title="2.7.3Metric聚合"></a>2.7.3Metric聚合</h3><p>我们统计了价格高于3000的手机品牌，形成了一个个桶。现在我们需要对桶内的商品做运算，获取每个品牌价格的最小值、最大值、平均值。</p><p>这就要用到<code>Metric</code>聚合了，例如<code>stat</code>聚合，就可以同时获取<code>min</code>、<code>max</code>、<code>avg</code>等结果。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">GET /items/_search</span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;query&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;bool&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;filter&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;term&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;category&quot;</span><span class="punctuation">:</span> <span class="string">&quot;手机&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;range&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">              <span class="attr">&quot;gte&quot;</span><span class="punctuation">:</span> <span class="number">300000</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span> </span><br><span class="line">  <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span> </span><br><span class="line">  <span class="attr">&quot;aggs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;brand_agg&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;terms&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;brand&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="number">20</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;aggs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;stats_meric&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;stats&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;field&quot;</span><span class="punctuation">:</span> <span class="string">&quot;price&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><code>query</code>部分就不说了，我们重点解读聚合部分语法。</p><p>可以看到我们在<code>brand_agg</code>聚合的内部，我们新加了一个<code>aggs</code>参数。这个聚合就是<code>brand_agg</code>的子聚合，会对<code>brand_agg</code>形成的每个桶中的文档分别统计。</p><ul><li><code>stats_meric</code>：聚合名称<ul><li><code>stats</code>：聚合类型，stats是<code>metric</code>聚合的一种<ul><li><code>field</code>：聚合字段，这里选择<code>price</code>，统计价格</li></ul></li></ul></li></ul><p>由于stats是对brand_agg形成的每个品牌桶内文档分别做统计，因此每个品牌都会统计出自己的价格最小、最大、平均值。</p><p>结果如下：</p><p><img src="https://pic.imgdb.cn/item/673d8c6bd29ded1a8cb35578.png" alt="es-16"></p><p>另外，我们还可以让聚合按照每个品牌的价格平均值排序：</p><p><img src="https://pic.imgdb.cn/item/673d8c6bd29ded1a8cb355d8.png" alt="es-17"></p><h3 id="2-7-4总结"><a href="#2-7-4总结" class="headerlink" title="2.7.4总结"></a>2.7.4总结</h3><p>aggs代表聚合，与query同级，此时query的作用:</p><ul><li>限定聚合的的文档范围</li></ul><p>聚合必须的三要素：</p><ul><li>聚合名称</li><li>聚合类型</li><li>聚合字段</li></ul><p>聚合可配置属性有：</p><ul><li>size：指定聚合结果数量</li><li>order：指定聚合结果排序方式</li><li>field：指定聚合字段</li></ul><h3 id="2-7-5RestClient实现聚合"><a href="#2-7-5RestClient实现聚合" class="headerlink" title="2.7.5RestClient实现聚合"></a>2.7.5RestClient实现聚合</h3><p>DSL中，<code>aggs</code>聚合条件与<code>query</code>条件是同一级别，都属于查询JSON参数。因此依然是利用<code>request.source()</code>方法来设置。</p><p>不过聚合条件的要利用<code>AggregationBuilders</code>这个工具类来构造。DSL与JavaAPI的语法对比如下：</p><p><img src="https://pic.imgdb.cn/item/673d8c6bd29ded1a8cb35637.png" alt="es-18"></p><p>聚合结果与搜索文档同一级别，因此需要单独获取和解析。具体解析语法如下：</p><p><img src="https://pic.imgdb.cn/item/673d8c6cd29ded1a8cb3572b.png" alt="es-19"></p><p>完整代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testAgg</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.创建Request</span></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">&quot;items&quot;</span>);</span><br><span class="line">    <span class="comment">// 2.准备请求参数</span></span><br><span class="line">    <span class="type">BoolQueryBuilder</span> <span class="variable">bool</span> <span class="operator">=</span> QueryBuilders.boolQuery()</span><br><span class="line">            .filter(QueryBuilders.termQuery(<span class="string">&quot;category&quot;</span>, <span class="string">&quot;手机&quot;</span>))</span><br><span class="line">            .filter(QueryBuilders.rangeQuery(<span class="string">&quot;price&quot;</span>).gte(<span class="number">300000</span>));</span><br><span class="line">    request.source().query(bool).size(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 3.聚合参数</span></span><br><span class="line">    request.source().aggregation(</span><br><span class="line">            AggregationBuilders.terms(<span class="string">&quot;brand_agg&quot;</span>).field(<span class="string">&quot;brand&quot;</span>).size(<span class="number">5</span>)</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 4.发送请求</span></span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 5.解析聚合结果</span></span><br><span class="line">    <span class="type">Aggregations</span> <span class="variable">aggregations</span> <span class="operator">=</span> response.getAggregations();</span><br><span class="line">    <span class="comment">// 5.1.获取品牌聚合</span></span><br><span class="line">    <span class="type">Terms</span> <span class="variable">brandTerms</span> <span class="operator">=</span> aggregations.get(<span class="string">&quot;brand_agg&quot;</span>);</span><br><span class="line">    <span class="comment">// 5.2.获取聚合中的桶</span></span><br><span class="line">    List&lt;? <span class="keyword">extends</span> <span class="title class_">Terms</span>.Bucket&gt; buckets = brandTerms.getBuckets();</span><br><span class="line">    <span class="comment">// 5.3.遍历桶内数据</span></span><br><span class="line">    <span class="keyword">for</span> (Terms.Bucket bucket : buckets) &#123;</span><br><span class="line">        <span class="comment">// 5.4.获取桶内key</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">brand</span> <span class="operator">=</span> bucket.getKeyAsString();</span><br><span class="line">        System.out.print(<span class="string">&quot;brand = &quot;</span> + brand);</span><br><span class="line">        <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> bucket.getDocCount();</span><br><span class="line">        System.out.println(<span class="string">&quot;; count = &quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工作ing~ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础</title>
      <link href="/posts/38943.html"/>
      <url>/posts/38943.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-Java基础-面试"><a href="#1-Java基础-面试" class="headerlink" title="1.Java基础:(面试)"></a>1.Java基础:(面试)</h1><h2 id="1-1基本数据类型"><a href="#1-1基本数据类型" class="headerlink" title="1.1基本数据类型"></a>1.1基本数据类型</h2><p><img src="https://pic.imgdb.cn/item/672b3adcd29ded1a8cd66e83.png" alt="1"></p><p>注意:byte取值范围 -128 - 127</p><p><img src="https://pic.imgdb.cn/item/672b3b52d29ded1a8cd6df09.png" alt="2"></p><p>2.引用数据类型</p><p>除了基本数据类型其他全是引用数据类型</p><h2 id="1-2顶级学习网址"><a href="#1-2顶级学习网址" class="headerlink" title="1.2顶级学习网址"></a>1.2顶级学习网址</h2><p><a href="https://www.cnblogs.com/zhangzhixi/tag/SpringMVC/">https://www.cnblogs.com/zhangzhixi/tag/SpringMVC/</a></p><h1 id="2-java内存分配"><a href="#2-java内存分配" class="headerlink" title="2.java内存分配"></a>2.java内存分配</h1><p><img src="https://pic.imgdb.cn/item/672b3b6ad29ded1a8cd6f2c4.png" alt="4"></p><p>单例模式:JavaBean</p><h2 id="2-1成员变量和局部变量的区别"><a href="#2-1成员变量和局部变量的区别" class="headerlink" title="2.1成员变量和局部变量的区别"></a>2.1成员变量和局部变量的区别</h2><p><img src="https://pic.imgdb.cn/item/672b3b93d29ded1a8cd72391.png" alt="5"></p><h1 id="3-Java设计模式之工厂方法模式详解"><a href="#3-Java设计模式之工厂方法模式详解" class="headerlink" title="3.Java设计模式之工厂方法模式详解"></a>3.Java设计模式之工厂方法模式详解</h1><h2 id="3-1什么是工厂方法模式？-创建型"><a href="#3-1什么是工厂方法模式？-创建型" class="headerlink" title="3.1什么是工厂方法模式？(创建型)"></a>3.1什么是工厂方法模式？(创建型)</h2><p>  工厂方法模式是一种创建型设计模式，其主要目的是定义一个用于创建对象的接口，让子类决定实例化哪个类。工厂方法使一个类的实例化延迟到其子类。这种模式在创建对象的超类(父类)中有一个创建对象的接口，让子类决定将哪个类实例化。</p><p>  具体设计模式分为:创建型模式,结构型模式,行为型模式</p><p>  设计模式——设计模式三大分类以及六大原则:<a href="https://cloud.tencent.com/developer/article/1764387">https://cloud.tencent.com/developer/article/1764387</a></p><h2 id="3-2工厂方法模式的优势"><a href="#3-2工厂方法模式的优势" class="headerlink" title="3.2工厂方法模式的优势"></a>3.2工厂方法模式的优势</h2><ul><li><strong>降低耦合性：</strong> 将产品的实例化过程与使用过程解耦，客户端不需要知道具体产品的类名，只需知道具体工厂即可。</li><li><strong>增加扩展性：</strong> 添加新的产品类时，只需要添加相应的具体产品类和对应的具体工厂类，无需修改已有代码。</li><li><strong>符合开闭原则：</strong> 对扩展开放，对修改关闭。</li></ul><h2 id="3-3简单工厂模式（静态工厂方法）"><a href="#3-3简单工厂模式（静态工厂方法）" class="headerlink" title="3.3简单工厂模式（静态工厂方法）"></a>3.3简单工厂模式（静态工厂方法）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public interface Product &#123;</span><br><span class="line">    void produce();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteProductA implements Product &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void produce() &#123;</span><br><span class="line">        System.out.println(&quot;生产产品A&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteProductB implements Product &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void produce() &#123;</span><br><span class="line">        System.out.println(&quot;生产产品B&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class SimpleFactory &#123;</span><br><span class="line">    public static Product createProduct(String type) &#123;</span><br><span class="line">        if (&quot;A&quot;.equals(type)) &#123;</span><br><span class="line">            return new ConcreteProductA();</span><br><span class="line">        &#125; else if (&quot;B&quot;.equals(type)) &#123;</span><br><span class="line">            return new ConcreteProductB();</span><br><span class="line">        &#125;</span><br><span class="line">        throw new IllegalArgumentException(&quot;Invalid product type&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-4工厂方法模式"><a href="#3-4工厂方法模式" class="headerlink" title="3.4工厂方法模式"></a>3.4工厂方法模式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public interface Factory &#123;</span><br><span class="line">    Product createProduct();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteFactoryA implements Factory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Product createProduct() &#123;</span><br><span class="line">        return new ConcreteProductA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteFactoryB implements Factory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Product createProduct() &#123;</span><br><span class="line">        return new ConcreteProductB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-5工厂方法模式的实际应用技巧-灵活扩展产品族"><a href="#3-5工厂方法模式的实际应用技巧-灵活扩展产品族" class="headerlink" title="3.5工厂方法模式的实际应用技巧(灵活扩展产品族)"></a>3.5工厂方法模式的实际应用技巧(灵活扩展产品族)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public interface Factory &#123;</span><br><span class="line">    Product createProduct();</span><br><span class="line">    // 扩展新的产品族</span><br><span class="line">    Product createSpecialProduct();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteFactoryA implements Factory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Product createProduct() &#123;</span><br><span class="line">        return new ConcreteProductA();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Product createSpecialProduct() &#123;</span><br><span class="line">        return new SpecialProductA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteFactoryB implements Factory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Product createProduct() &#123;</span><br><span class="line">        return new ConcreteProductB();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Product createSpecialProduct() &#123;</span><br><span class="line">        return new SpecialProductB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-6使用抽象工厂模式"><a href="#3-6使用抽象工厂模式" class="headerlink" title="3.6使用抽象工厂模式"></a>3.6使用抽象工厂模式</h2><p>抽象工厂模式是工厂方法模式的一种变种，它在创建产品族时更加灵活，可以创建多个不同产品的产品族。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public interface AbstractFactory &#123;</span><br><span class="line">    Product createProduct();</span><br><span class="line">    SpecialProduct createSpecialProduct();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteFactoryA implements AbstractFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Product createProduct() &#123;</span><br><span class="line">        return new ConcreteProductA();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public SpecialProduct createSpecialProduct() &#123;</span><br><span class="line">        return new SpecialProductA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ConcreteFactoryB implements AbstractFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Product createProduct() &#123;</span><br><span class="line">        return new ConcreteProductB();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public SpecialProduct createSpecialProduct() &#123;</span><br><span class="line">        return new SpecialProductB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-7工厂方法模式的典型应用场景"><a href="#3-7工厂方法模式的典型应用场景" class="headerlink" title="3.7工厂方法模式的典型应用场景"></a>3.7工厂方法模式的典型应用场景</h2><h3 id="1-日志记录器"><a href="#1-日志记录器" class="headerlink" title="1.日志记录器"></a>1.日志记录器</h3><p>在日志记录器中，不同类型的日志记录器可以由不同的日志记录器工厂负责创建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public interface LoggerFactory &#123;</span><br><span class="line">    Logger createLogger();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class FileLoggerFactory implements LoggerFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Logger createLogger() &#123;</span><br><span class="line">        return new FileLogger();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class DatabaseLoggerFactory implements LoggerFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Logger createLogger() &#123;</span><br><span class="line">        return new DatabaseLogger();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-数据库连接池"><a href="#2-数据库连接池" class="headerlink" title="2.数据库连接池"></a>2.数据库连接池</h3><p>在数据库连接池中，可以由不同的连接池工厂负责创建不同类型的数据库连接池</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public interface ConnectionPoolFactory &#123;</span><br><span class="line">    ConnectionPool createConnectionPool();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class OracleConnectionPoolFactory implements ConnectionPoolFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public ConnectionPool createConnectionPool() &#123;</span><br><span class="line">        return new OracleConnectionPool();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MySQLConnectionPoolFactory implements ConnectionPoolFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public ConnectionPool createConnectionPool() &#123;</span><br><span class="line">        return new MySQLConnectionPool();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-UI控件库"><a href="#3-UI控件库" class="headerlink" title="3.UI控件库"></a>3.UI控件库</h3><p>在UI控件库中，可以由不同的控件工厂负责创建不同类型的UI控件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public interface UIControlFactory &#123;</span><br><span class="line">    Button createButton();</span><br><span class="line">    TextBox createTextBox();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class WindowsUIControlFactory implements UIControlFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Button createButton() &#123;</span><br><span class="line">        return new WindowsButton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public TextBox createTextBox() &#123;</span><br><span class="line">        return new WindowsTextBox();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class LinuxUIControlFactory implements UIControlFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Button createButton() &#123;</span><br><span class="line">        return new LinuxButton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public TextBox createTextBox() &#123;</span><br><span class="line">        return new LinuxTextBox();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="4-Java设计模式详解—-单例模式"><a href="#4-Java设计模式详解—-单例模式" class="headerlink" title="4.Java设计模式详解—-单例模式"></a>4.Java设计模式详解—-单例模式</h1><p><img src="https://pic.imgdb.cn/item/672b3bb6d29ded1a8cd754c9.jpg" alt="3"></p><h2 id="4-1：什么是单例模式"><a href="#4-1：什么是单例模式" class="headerlink" title="4.1：什么是单例模式"></a>4.1：什么是单例模式</h2><p>保证一个类只有一个实例，并且提供一个访问该全局访问点</p><h2 id="4-2单例模式的优缺点"><a href="#4-2单例模式的优缺点" class="headerlink" title="4.2单例模式的优缺点"></a>4.2单例模式的优缺点</h2><p>优点:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 在单例模式中，活动的单例只有一个实例，对单例类的所有实例化得到的都是相同的一个实例。这样就防止其它对象对自己的实例化，确保所有的对象都访问一个实例</span><br><span class="line">2. 单例模式具有一定的伸缩性，类自己来控制实例化进程，类就在改变实例化进程上有相应的伸缩性。</span><br><span class="line">3. 提供了对唯一实例的受控访问。</span><br><span class="line">4. 由于在系统内存中只存在一个对象，因此可以节约系统资源，当需要频繁创建和销毁的对象时单例模式无疑可以提高系统的性能。</span><br><span class="line">5. 允许可变数目的实例。</span><br><span class="line">6. 避免对共享资源的多重占用。</span><br></pre></td></tr></table></figure><p>缺点:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 不适用于变化的对象，如果同一类型的对象总是要在不同的用例场景发生变化，单例就会引起数据的错误，不能保存彼此的状态。</span><br><span class="line">2. 由于单利模式中没有抽象层，因此单例类的扩展有很大的困难。</span><br><span class="line">3. 单例类的职责过重，在一定程度上违背了 “ 单一职责原则 ” 。</span><br><span class="line">4. 滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；如果实例化的对象长时间不被利用，系统会认为是垃圾而被回收，这将导致对象状态的丢失。</span><br></pre></td></tr></table></figure><h2 id="4-3单例模式的应用场景"><a href="#4-3单例模式的应用场景" class="headerlink" title="4.3单例模式的应用场景"></a>4.3单例模式的应用场景</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 网站的计数器，一般也是采用单例模式实现，否则难以同步。</span><br><span class="line">2. 应用程序的日志应用，一般都是单例模式实现，只有一个实例去操作才好，否则内容不好追加显示。</span><br><span class="line">3. 多线程的线程池的设计一般也是采用单例模式，因为线程池要方便对池中的线程进行控制</span><br><span class="line">4. Windows 的（任务管理器）就是很典型的单例模式，他不能打开俩个</span><br><span class="line">5. windows 的（回收站）也是典型的单例应用。在整个系统运行过程中，回收站只维护一个实例。</span><br></pre></td></tr></table></figure><h2 id="4-4单例模式的分类"><a href="#4-4单例模式的分类" class="headerlink" title="4.4单例模式的分类"></a>4.4单例模式的分类</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 饿汉式: 类初始化时 , 会立即加载该对象，线程天生安全 , 调用效率高。</span><br><span class="line">2. 懒汉式 : 类初始化时 , 不会初始化该对象 , 真正需要使用的时候才会创建该对象 , 具备懒加载功能。</span><br><span class="line">3. 静态内部方式 : 结合了懒汉式和饿汉式各自的优点，真正需要对象的时候才会加载，加载类是线程安全的。</span><br><span class="line">4. 枚举单例 : 使用枚举实现单例模式 优点 : 实现简单、调用效率高，枚举本身就是单例，由 jvm 从根本上提供保障! 避免通过反射和反序列化的漏洞， 缺点没有延迟加载。</span><br><span class="line">5. 双重检测锁方式 ( 因为 JVM 本质重排序的原因，可能会初始化多次，不推荐使用 )</span><br></pre></td></tr></table></figure><h3 id="4-4-1饿汉式"><a href="#4-4-1饿汉式" class="headerlink" title="4.4.1饿汉式"></a>4.4.1饿汉式</h3><p>饿汉式 : 类初始化时 , 会立即加载该对象，线程天生安全 , 调用效率高。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @author: dlwlrma</span><br><span class="line"> * @data 2024年10月26日 19:50</span><br><span class="line"> * @Description: TODO:单例模式之饿汉式</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">public class Demo1 &#123;</span><br><span class="line">    //饿汉式，类初始化时，会立即创建对象，调用效率高，但可能会造成内存的浪费</span><br><span class="line">    private static Demo1 demo1=new Demo1();</span><br><span class="line">    private Demo1()&#123;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    public static Demo1 getInstance()&#123;</span><br><span class="line">        return demo1;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Demo1 demo11=Demo1.getInstance();</span><br><span class="line">        Demo1 demo12=Demo1.getInstance();</span><br><span class="line">        System.out.println(demo11==demo12);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-2懒汉式"><a href="#4-4-2懒汉式" class="headerlink" title="4.4.2懒汉式"></a>4.4.2懒汉式</h3><p>懒汉式 : 类初始化时 , 不会初始化该对象 , 真正需要使用的时候才会创建该对象 , 具备懒加载功能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @author: dlwlrma</span><br><span class="line"> * @data 2024年10月26日 19:52</span><br><span class="line"> * @Description: TODO:单例模式之懒汉式</span><br><span class="line"> */</span><br><span class="line">//懒汉式</span><br><span class="line">public class Demo2 &#123;</span><br><span class="line">    //类初始化时，不会初始化该对象，真正需要使用的时候才会创建该对象。</span><br><span class="line">    private static Demo2 demo2;</span><br><span class="line">    private Demo2() &#123;</span><br><span class="line">        System.out.println(&quot;私有Demo2构造参数初始化&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public synchronized static Demo2 getInstance() &#123;</span><br><span class="line">        if (demo2 == null) &#123;</span><br><span class="line">            demo2 = new Demo2();</span><br><span class="line">        &#125;</span><br><span class="line">        return demo2;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Demo2 s1 = Demo2.getInstance();</span><br><span class="line">        Demo2 s2 = Demo2.getInstance();</span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-3静态内部式"><a href="#4-4-3静态内部式" class="headerlink" title="4.4.3静态内部式"></a>4.4.3静态内部式</h3><p>静态内部方式 : 结合了懒汉式和饿汉式各自的优点，真正需要对象的时候才会加载，加载类是线程安全的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 静态内部类方式</span><br><span class="line"> * @author dlwlrma</span><br><span class="line"> * @date 2024/10/26 19:56</span><br><span class="line"> * @return null</span><br><span class="line"> */</span><br><span class="line">public class Demo3 &#123;</span><br><span class="line">    private Demo3() &#123;</span><br><span class="line">        System.out.println(&quot;私有Demo3构造参数初始化&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static class SingletonClassInstance &#123;</span><br><span class="line">        private static final Demo3 DEMO_3 = new Demo3();</span><br><span class="line">    &#125;</span><br><span class="line">    // 方法没有同步</span><br><span class="line">    public static Demo3 getInstance() &#123;</span><br><span class="line">        return SingletonClassInstance.DEMO_3;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Demo3 s1 = Demo3.getInstance();</span><br><span class="line">        Demo3 s2 = Demo3.getInstance();</span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特别注意的是:private static final Demo3 DEMO_3 &#x3D; new Demo3();</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">不可变性：DEMO_3 引用被声明为 final，这意味着一旦 DEMO_3 被初始化指向了某个 Demo3 类型的对象之后，就不能再改变指向其他对象了。这有助于确保对象引用的不可变性，对于多线程环境下的编程特别有用，因为不可变对象是线程安全的。</span><br><span class="line"></span><br><span class="line">静态上下文：由于 DEMO_3 同时被声明为 static，这意味着它是属于类级别的，而不是实例级别的。所有该类的实例将共享同一个 DEMO_3 对象。此外，当类首次被加载时，静态成员就会被初始化。</span><br><span class="line"></span><br><span class="line">私有访问控制：private 关键字限制了对 DEMO_3 的访问权限，只有定义它的类中的代码能够直接访问它。这有助于封装数据，保护对象不受外部干扰。</span><br></pre></td></tr></table></figure><h3 id="4-4-4双重检测锁式"><a href="#4-4-4双重检测锁式" class="headerlink" title="4.4.4双重检测锁式"></a>4.4.4双重检测锁式</h3><p>双重检测锁方式 ( 因为 JVM 本质重排序的原因，可能会初始化多次，不推荐使用 )</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @author: dlwlrma</span><br><span class="line"> * @data 2024年10月26日 19:59</span><br><span class="line"> * @Description: TODO:双重检测锁方式</span><br><span class="line"> */</span><br><span class="line">//双重检测锁方式</span><br><span class="line">public class Demo5 &#123;</span><br><span class="line">    private static Demo5 demo5;</span><br><span class="line">    private Demo5() &#123;</span><br><span class="line">        System.out.println(&quot;私有Demo4构造参数初始化&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public static Demo5 getInstance() &#123;</span><br><span class="line">        if (demo5 == null) &#123;</span><br><span class="line">            synchronized (Demo5.class) &#123;</span><br><span class="line">                if (demo5 == null) &#123;</span><br><span class="line">                    demo5 = new Demo5();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return demo5;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Demo5 s1 = Demo5.getInstance();</span><br><span class="line">        Demo5 s2 = Demo5.getInstance();</span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-5枚举单例式"><a href="#4-4-5枚举单例式" class="headerlink" title="4.4.5枚举单例式"></a>4.4.5枚举单例式</h3><p>枚举单例 : 使用枚举实现单例模式 优点 : 实现简单、调用效率高，枚举本身就是单例，由 jvm 从根本上提供保障! 避免通过反射和反序列化的漏洞， 缺点没有延迟加载。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @author: dlwlrma</span><br><span class="line"> * @data 2024年10月26日 19:57</span><br><span class="line"> * @Description: TODO: 使用枚举实现单例模式 优点:实现简单、枚举本身就是单例，由jvm从根本上提供 </span><br><span class="line">                       保障!避免通过反射和反序列化的漏洞 缺点没有延迟加载</span><br><span class="line"> */</span><br><span class="line">public class Demo4 &#123;</span><br><span class="line">    public static Demo4 getInstance() &#123;</span><br><span class="line">        return Demo.INSTANCE.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Demo4 s1 = Demo4.getInstance();</span><br><span class="line">        Demo4 s2 = Demo4.getInstance();</span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">    &#125;</span><br><span class="line">    //定义枚举</span><br><span class="line">    private static enum Demo &#123;</span><br><span class="line">        INSTANCE;</span><br><span class="line">        // 枚举元素为单例</span><br><span class="line">        private Demo4 demo4;</span><br><span class="line">        private Demo() &#123;</span><br><span class="line">            System.out.println(&quot;枚举Demo私有构造参数&quot;);</span><br><span class="line">            demo4 = new Demo4();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        public Demo4 getInstance() &#123;</span><br><span class="line">            return demo4;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-集合"><a href="#5-集合" class="headerlink" title="5.集合"></a>5.集合</h1><h2 id="5-1ArrayList集合"><a href="#5-1ArrayList集合" class="headerlink" title="5.1ArrayList集合"></a>5.1ArrayList集合</h2><h3 id="5-1-1ArrayList集合成员方法"><a href="#5-1-1ArrayList集合成员方法" class="headerlink" title="5.1.1ArrayList集合成员方法"></a>5.1.1ArrayList集合成员方法</h3><p><img src="https://pic.imgdb.cn/item/672b3bdcd29ded1a8cd77d35.png" alt="6"></p><h3 id="5-1-2Arrays-asList集合类的集合转换方法的坑！！！"><a href="#5-1-2Arrays-asList集合类的集合转换方法的坑！！！" class="headerlink" title="5.1.2Arrays.asList集合类的集合转换方法的坑！！！"></a>5.1.2Arrays.asList集合类的集合转换方法的坑！！！</h3><p>不支持的操作异常：UnsupportedOperationException)</p><p><a href="https://www.cnblogs.com/zhangzhixi/p/14766636.html">https://www.cnblogs.com/zhangzhixi/p/14766636.html</a></p><h2 id="5-2顶级父类集合collection"><a href="#5-2顶级父类集合collection" class="headerlink" title="5.2顶级父类集合collection"></a>5.2顶级父类集合collection</h2><p>集合主要分为两类:</p><ul><li>单列集合</li><li>双列集合</li></ul><h3 id="5-2-1单列体系结构"><a href="#5-2-1单列体系结构" class="headerlink" title="5.2.1单列体系结构"></a>5.2.1单列体系结构</h3><p><img src="https://pic.imgdb.cn/item/672b3bf5d29ded1a8cd791cb.png" alt="10"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list系列集合：添加的元素是有序、可重复、有索引的。</span><br><span class="line">有序：指的是存和取的顺序是一致的</span><br><span class="line">set系列集合：添加的元素是无序、不可重复、无索引的</span><br></pre></td></tr></table></figure><h3 id="5-2-2Collection"><a href="#5-2-2Collection" class="headerlink" title="5.2.2Collection"></a>5.2.2Collection</h3><ul><li>collection：collection是一个接口，是单列集合的最顶层接口，它的功能是全部单列集合都可以继承使用。</li><li>collection：常见的方法：</li></ul><p><img src="https://pic.imgdb.cn/item/672b3bf5d29ded1a8cd791da.png" alt="11"></p><h2 id="5-3单列集合的遍历方式"><a href="#5-3单列集合的遍历方式" class="headerlink" title="5.3单列集合的遍历方式"></a>5.3单列集合的遍历方式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Collection集合主要有三种遍历方式：迭代器遍历、增强for遍历、Lambda表达式遍历。</span><br><span class="line">以上三种遍历方式是单列集合通用的遍历方式</span><br></pre></td></tr></table></figure><h3 id="5-3-1迭代器遍历"><a href="#5-3-1迭代器遍历" class="headerlink" title="5.3.1迭代器遍历"></a>5.3.1迭代器遍历</h3><p>​    用迭代器进行遍历，不依赖索引，它是集合专用的遍历方式，在 Java 中其类名写作 Iterator。<br>​    使用 Collection 集合获取迭代器，默认指向当前集合的 0 索引处。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p> 然后利用集合中的两个方法来获取和遍历集合中的元素。</p><table><thead><tr><th>常用方法</th><th>说明</th></tr></thead><tbody><tr><td>boolean hasNext()</td><td>判断当前位置是否有元素，有元素返回true，没有元素返回false</td></tr><tr><td>E next()</td><td>获取当前位置的元素，并将迭代器对象移向下一个位置</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package Colletcion;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Collection;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line"></span><br><span class="line">public class Iterators &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Collection&lt;String&gt; coll = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        coll.add(&quot;三&quot;);</span><br><span class="line">        coll.add(&quot;连&quot;);</span><br><span class="line">        coll.add(&quot;外&quot;);</span><br><span class="line">        coll.add(&quot;加&quot;);</span><br><span class="line">        coll.add(&quot;转&quot;);</span><br><span class="line">        coll.add(&quot;发&quot;);</span><br><span class="line">        coll.add(&quot;了&quot;);</span><br><span class="line">        coll.add(&quot;吗&quot;);</span><br><span class="line">        coll.add(&quot;?&quot;);</span><br><span class="line">        coll.add(&quot;?&quot;);</span><br><span class="line"></span><br><span class="line">        Iterator&lt;String&gt; it = coll.iterator();</span><br><span class="line">        //hasNext()表示获取当前位置是否有元素，可作为循环的判断依据</span><br><span class="line">        while(it.hasNext())&#123;</span><br><span class="line">                String str = it.next();</span><br><span class="line">                System.out.print(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>    使用迭代器遍历时，要注意以下几点：</code></pre><p>如果迭代器已经指向空，再调用 next 方法会报错：NoSuchElementException。</p><p>迭代器遍历完毕后，指针不会复位。</p><p>循环中只能用一次 next 方法。</p><p>迭代器遍历时，不能用集合的方法进行增加或删除，否则可能会发生指针异常。</p><p>想要继续第二次遍历集合，只能再次获取一个新的迭代器对象</p><h3 id="5-3-2增强for遍历"><a href="#5-3-2增强for遍历" class="headerlink" title="5.3.2增强for遍历"></a>5.3.2增强for遍历</h3><p>增强 for 的底层其实就是迭代器，它是为了简化迭代器的代码书写而诞生的。它在JDK5之后出现，其内部原理是一个 Iterator 迭代器。</p><p>注意，所有的<strong>单列集合</strong>和<strong>数组</strong>才能用增强 for 进行遍历。<br>格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (元素的数据类型 变量名:数组或集合)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-3Lambda表达式遍历"><a href="#5-3-3Lambda表达式遍历" class="headerlink" title="5.3.3Lambda表达式遍历"></a>5.3.3Lambda表达式遍历</h3><p>实现 Consumer 接口重写 accept 方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package Colletcion;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Collection;</span><br><span class="line">import java.util.function.Consumer;</span><br><span class="line"></span><br><span class="line">public class LambdaTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //1.创建集合并添加元素</span><br><span class="line">        Collection&lt;String&gt; coll = new ArrayList&lt;&gt;();</span><br><span class="line">        coll.add(&quot;zhangsan&quot;);</span><br><span class="line">        coll.add(&quot;lisi&quot;);</span><br><span class="line">        coll.add(&quot;wangwu&quot;);</span><br><span class="line">        //2.利用匿名内部类的形式</span><br><span class="line">        //forEach底层其实也会自己遍历集合，依次得到每一个元素</span><br><span class="line">        //s就是记录每一个元素的遍历，传递给accept方法</span><br><span class="line">        /*coll.forEach(new Consumer&lt;String&gt;()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            //s依次表示集合中的每一个数据</span><br><span class="line">            public void accept(String s) &#123;</span><br><span class="line">                System.out.println(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);*/</span><br><span class="line">        </span><br><span class="line">        //lambda表达式</span><br><span class="line">        //() -&gt; &#123;&#125;</span><br><span class="line">        coll.forEach(s -&gt; System.out.println(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-4List集合"><a href="#5-4List集合" class="headerlink" title="5.4List集合"></a>5.4List集合</h2><h3 id="5-4-1List集合基本方法"><a href="#5-4-1List集合基本方法" class="headerlink" title="5.4.1List集合基本方法"></a>5.4.1List集合基本方法</h3><p>List 集合是 Collection 下的一种旁支，它的特点是：有序、有索引、可重复。Collection 中的方法，List 都有继承，而 List 集合加入了索引相关的方法，我们只需要再学习索引相关操作即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">方法名称说明</span><br><span class="line">void add(int index, E element)在此集合中的指定位置插入指定的元素</span><br><span class="line">E remove(int index)删除指定索引处的元素，返回被删除的元素</span><br><span class="line">E set(int index, E element)修改指定索引处的元素，返回被修改的元素</span><br><span class="line">E get(int index)返回指定索引处的元素</span><br></pre></td></tr></table></figure><h3 id="5-4-2遍历方式"><a href="#5-4-2遍历方式" class="headerlink" title="5.4.2遍历方式"></a>5.4.2遍历方式</h3><ul><li>迭代器遍历</li><li>列表迭代器遍历(List独有,Set不行)</li><li>增强 for 遍历</li><li>Lambda 表达式遍历</li><li>基本 for 循环遍历(List独有,Set不行)</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">package Colletcion;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.ListIterator;</span><br><span class="line">import java.util.function.Consumer;</span><br><span class="line"></span><br><span class="line">public class ListTest2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //创建集合并添加元素</span><br><span class="line">        List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        list.add(&quot;aaa&quot;);</span><br><span class="line">        list.add(&quot;bbb&quot;);</span><br><span class="line">        list.add(&quot;ccc&quot;);</span><br><span class="line"></span><br><span class="line">        //1.迭代器方式</span><br><span class="line">        Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line">        while(it.hasNext()) &#123;</span><br><span class="line">            String str = it.next();</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //2.增强for</span><br><span class="line">        for (String s : list) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //3.lambda表达式</span><br><span class="line">/*list.forEach(new Consumer&lt;String&gt;()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void accept(String s)&#123;</span><br><span class="line">                System.out.println(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);*/</span><br><span class="line"></span><br><span class="line">        list.forEach(s -&gt; System.out.println(s));</span><br><span class="line"></span><br><span class="line">        //4.简单for循环</span><br><span class="line">        for(int i = 0; i &lt; list.size(); i++) &#123;</span><br><span class="line">            System.out.println(list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //5.列表迭代器</span><br><span class="line">        //列表迭代器是一个接口，不能直接创建对象</span><br><span class="line">        //hasNext() next() hasPrevious() previous() add()</span><br><span class="line">        //获取一个列表迭代器的对象用listIterator()方法</span><br><span class="line">        ListIterator&lt;String&gt; itr = list.listIterator();</span><br><span class="line">        while(itr.hasNext()) &#123;</span><br><span class="line">            String str = itr.next();</span><br><span class="line">            //list迭代器额外添加了一个方法：在遍历过程中，可以添加元素</span><br><span class="line">            //下面的代码在“bbb”元素后添加了一个“QQQ”元素，调用迭代器本身的add()方法</span><br><span class="line">            if(&quot;bbb&quot;.equals(str))&#123;</span><br><span class="line">                itr.add(&quot;QQQ&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(list);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code> 这五种遍历方式可以说是有不同的用途：</code></pre><p>在遍历过程中，如果要删除元素，请使用迭代器遍历。<br>在遍历过程中，如果要添加元素，请使用列表迭代器遍历。<br>如果仅仅想遍历，那么使用增强 for 或 Lambda 表达式即可。<br>如果在遍历时想对索引进行操作，可以使用普通 for 循环进行遍历。</p><h2 id="5-5Set集合"><a href="#5-5Set集合" class="headerlink" title="5.5Set集合"></a>5.5Set集合</h2><pre><code>Set 集合系列是单列集合体系结构的另一条分支，有别于 List 集合的有序、可重复、有索引，Set 集合的特征是无序、不重复、无索引。</code></pre><p>无序：存取顺序不一致。<br>不重复：可以去除重复数据。<br>无索引：没有带索引的方法，所以不能使用普通 for 循环遍历，也不能通过索引来获取元素。<br>Set 集合有三个实现类，它们分别是：</p><p>HashSet：无序、不重复、无索引。<br>LinkedHashSet：有序、不重复、无索引。<br>TreeSet：可排序、不重复、无索引。</p><p>Set 本身是一个接口，它里面的方法基本上和 Collection 的 API 一致。</p><h3 id="5-5-1Set-集合的遍历"><a href="#5-5-1Set-集合的遍历" class="headerlink" title="5.5.1Set 集合的遍历"></a>5.5.1Set 集合的遍历</h3><p>Set 集合也可以用常用的那三种方式遍历，即：[迭代器]  、增强 for 、Lambda 表达式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">package Set;</span><br><span class="line"></span><br><span class="line">import java.util.HashSet;</span><br><span class="line">import java.util.Iterator;</span><br><span class="line">import java.util.Set;</span><br><span class="line">import java.util.function.Consumer;</span><br><span class="line"></span><br><span class="line">public class SetDemo1 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        /*</span><br><span class="line">        遍历Set</span><br><span class="line">         */</span><br><span class="line"></span><br><span class="line">        //1.创建一个Set集合的对象</span><br><span class="line">        //由于Set是一个接口，所以只能创建其实现类对象，可以利用多态实现调用Set中的方法</span><br><span class="line">        Set&lt;String&gt; s = new HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        //2.添加元素</span><br><span class="line">        //add方法的返回值是一个布尔类型，用于判断元素是否添加成功</span><br><span class="line">        //如果已经有重复元素，添加就会失败</span><br><span class="line">        s.add(&quot;aaa&quot;);</span><br><span class="line">        s.add(&quot;bbb&quot;);</span><br><span class="line">        System.out.println(s.add(&quot;bbb&quot;));</span><br><span class="line">        s.add(&quot;ccc&quot;);</span><br><span class="line"></span><br><span class="line">        //3.打印集合</span><br><span class="line">        System.out.println(s);</span><br><span class="line"></span><br><span class="line">        //迭代器遍历</span><br><span class="line">        Iterator&lt;String&gt; it = s.iterator();</span><br><span class="line">        while(it.hasNext()) &#123;</span><br><span class="line">            System.out.println(it.next());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //增强for</span><br><span class="line">        for (String str : s) &#123;</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //lambda表达式</span><br><span class="line">        s.forEach(str -&gt; System.out.println(str));</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-5-2HashSet"><a href="#5-5-2HashSet" class="headerlink" title="5.5.2HashSet"></a>5.5.2HashSet</h3><h4 id="1-哈希值"><a href="#1-哈希值" class="headerlink" title="1.哈希值"></a>1.哈希值</h4><p>HashSet 集合在底层采取<strong>哈希表</strong>存储数据。<br>    哈希表是一种对于增删改查数据性能都良好的结构。<br>    在 JDK8 以前，哈希表的底层是数组+链表；在 JDK8 以后，哈希表的底层是数组+链表+红黑树。</p><p>哈希值是对象的<strong>整数</strong>表现形式。<br>哈希表在底层是有一个数组存在的，这个数组存储数据时，存储在哪个位置上的索引，是有公式要求的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int index = (数组长度 - 1) &amp; 哈希值;</span><br></pre></td></tr></table></figure><p> 公式中的这个哈希值，是 Java 根据 hashCode() 方法计算出来的 int 类型的整数，这个方法定义在 Object 类中，所以所有对象都可以调用，默认使用对象的地址值进行计算。<br>但是，一般情况下，我们在使用时会改写 hashCode 方法，利用对象内部的属性值来计算哈希值。因此：</p><p>如果没有重写 hashCode() 方法，不同对象计算出的哈希值一定是不同的。<br>如果已经重写 hashCode() 方法，不同的对象只要属性值相同，计算出的哈希值就是相同的。<br>小概率事件（哈希碰撞）：不同的属性值或者不同的地址值计算出来的哈希值出现了一样的情况。</p><h4 id="2-HashSet-存储底层原理"><a href="#2-HashSet-存储底层原理" class="headerlink" title="2.HashSet 存储底层原理"></a>2.HashSet 存储底层原理</h4><p><img src="https://pic.imgdb.cn/item/672b3bffd29ded1a8cd79a99.png" alt="12"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组长度 × 加载因子 = 数组存储元素个数上限</span><br></pre></td></tr></table></figure><p>​        默认16 × 0.75 &#x3D; 12，当存储12个元素时，数组会扩容成原来的两倍。<br>​        而当链表长度大于8且数组长度大于等于64时，当前链表就会自动转化为红黑树，从而提高了查找效率。</p><p>两个注意点：<br>1.JDK8 以后，当链表长度超过8，而且数组长度大于等于64时，自动把链表转换为红黑树。<br>2.如果集合中存储的是自定义对象，必须要重写 hashCode 和 equals 方法。</p><h4 id="3-HashSet-集合的特点"><a href="#3-HashSet-集合的特点" class="headerlink" title="3.HashSet 集合的特点"></a>3.HashSet 集合的特点</h4><p>1.HashSet 存和取的顺序不一样。</p><p>   HashSet 在读数据时，从数组0索引开始，一条链表一条链表地遍历，这和我们添加元素时的顺序不一样，因此 HashSet 存和取的顺序是不一样的。</p><p>2.HashSet 没有索引。</p><p>​    HashSet 在底层是数组+链表+红黑树组成，没有办法用一个索引值来找寻一个元素。</p><p>3.HashSet 为什么能数据去重？</p><p>​    HashSet 就是利用 hashCode() 方法和 equals() 方法来去重的。在添加元素前，先用 hashCode() 方法算出元素应该存到数组的哪个位置，如果这个位置上有元素了，再调用 equals() 方法，判断这个元素和要添加的元素是不是完全一样，如果一样，就不用添加了。因此完成了数据去重。</p><p>注意：如果集合里要放的是自定义对象，那就必须重写 hashCode() 和 equals() 方法；但是如果你要放的是 String 或者 Integer 这样本来就有的类，就不需要重写那两个方法了，Java 已经自动帮我们重写好了。</p><h3 id="5-5-3LinkedHashSet"><a href="#5-5-3LinkedHashSet" class="headerlink" title="5.5.3LinkedHashSet"></a>5.5.3LinkedHashSet</h3><p><img src="https://pic.imgdb.cn/item/672b3bffd29ded1a8cd79ab2.png" alt="13"></p><h3 id="5-5-4TreeSet"><a href="#5-5-4TreeSet" class="headerlink" title="5.5.4TreeSet"></a>5.5.4TreeSet</h3><p>​    TreeSet 是 Set 体系中的一种集合类。它的特点是：不重复、无索引、可排序。<br>​    TreeSet 可排序，且按照元素的默认规则（由小到大）排序。它的底层是基于红黑树的数据结构实现排序的，增删改查性能都较好。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TreeSet 集合对于数值类型：Integer，Double，默认都是按照从小到大排列的。</span><br><span class="line">        而对于字符、字符串类型：按照字符在 ASCII 码表中的数字升序进行排序。比如 “a” 是 97，“A” 是 65。</span><br><span class="line">        如果字符串内容比较多，它会从首字母开始挨个比较，此时和字符串的长度没有任何关系。比如：“aaa” 就大于 “ab” ，因为第一个字母一样，比较第二个字母，“a” &gt; “b” ，已经可以确定大小关系，因此不再比较后面的字母</span><br></pre></td></tr></table></figure><ul><li>其一是默认排序 &#x2F; 自然排序：利用 Javabean 类实现 Comparable 接口指定比较规则。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//在Student类中重写Comparable接口中的抽象方法</span><br><span class="line">    @Override</span><br><span class="line">    public int compareTo(Student o) &#123;</span><br><span class="line">        //指定排序规则</span><br><span class="line">        //只看年龄，按照年龄升序排列</span><br><span class="line">        //TreeSet内部是红黑树结构，Student不需要重写其equals和hashCode方法</span><br><span class="line">        //this：表示当前要添加的元素</span><br><span class="line">        //o：表示已经在红黑树存在的元素</span><br><span class="line">        //返回值：负数：认为当前要添加的元素是小的，就要存左边</span><br><span class="line">        //正数：认为要添加的元素是大的，就要存右边</span><br><span class="line">        //0：认为当前要添加的元素已经存在，舍弃不存</span><br><span class="line">        System.out.println(&quot;-------------------------&quot;);</span><br><span class="line">        System.out.println(&quot;this:&quot; + this);</span><br><span class="line">        System.out.println(&quot;o:&quot; + o);</span><br><span class="line">        return this.getAge() - o.getAge();</span><br></pre></td></tr></table></figure><ul><li><p>其二是比较器排序：在创建 TreeSet 对象的时候，传递比较器 Comparator 指定规则（参数是一个 Comparator 接口的匿名实现类）。传递 Comparator 接口的匿名实现类（可以用Lambda表达式），然后在内部重写 compare 方法，指定比较规则。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">package Set;</span><br><span class="line"></span><br><span class="line">import java.util.Comparator;</span><br><span class="line">import java.util.TreeSet;</span><br><span class="line"></span><br><span class="line">public class TreeSetDemo3 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        /*</span><br><span class="line">        存入四个字符串，&quot;c&quot;，&quot;ab&quot;，&quot;df&quot;，&quot;qwer&quot; 按照长度排序，如果一样长就按照首字母排序</span><br><span class="line"></span><br><span class="line">        比较器排序：创建集合时传入一个比较器对象</span><br><span class="line">         */</span><br><span class="line"></span><br><span class="line">        //1.创建集合</span><br><span class="line">        //参数传递一个Comparator的匿名实现类，重写compare方法</span><br><span class="line">/*        TreeSet&lt;String&gt; ts = new TreeSet&lt;&gt;(new Comparator&lt;String&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public int compare(String o1, String o2) &#123;</span><br><span class="line">                //按照长度排序</span><br><span class="line">                int i = o1.length() - o2.length();</span><br><span class="line">                //如果一样长就按照首字母排序，否则按照长度排序</span><br><span class="line">                i = i == 0 ? o1.compareTo(o2) : i;</span><br><span class="line">                return i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);*/</span><br><span class="line"></span><br><span class="line">        //改写为Lambda表达式</span><br><span class="line">                TreeSet&lt;String&gt; ts = new TreeSet&lt;&gt;((o1, o2) -&gt; &#123;</span><br><span class="line">                //按照长度排序</span><br><span class="line">                int i = o1.length() - o2.length();</span><br><span class="line">                //如果一样长就按照首字母排序，否则按照长度排序</span><br><span class="line">                //compareTo默认是按照字符串首字母排序的</span><br><span class="line">                i = i == 0 ? o1.compareTo(o2) : i;</span><br><span class="line">                return i;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">        </span><br><span class="line">        //2.添加元素</span><br><span class="line">        ts.add(&quot;c&quot;);</span><br><span class="line">        ts.add(&quot;ab&quot;);</span><br><span class="line">        ts.add(&quot;df&quot;);</span><br><span class="line">        ts.add(&quot;qwer&quot;);</span><br><span class="line"></span><br><span class="line">        System.out.println(ts);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="5-6List和Set集合总结"><a href="#5-6List和Set集合总结" class="headerlink" title="5.6List和Set集合总结"></a>5.6List和Set集合总结</h2><p><img src="https://pic.imgdb.cn/item/672b3bffd29ded1a8cd79ae6.png" alt="14"></p><h1 id="6-static-静态变量"><a href="#6-static-静态变量" class="headerlink" title="6.static-静态变量"></a>6.static-静态变量</h1><h2 id="6-1static-修饰成员变量"><a href="#6-1static-修饰成员变量" class="headerlink" title="6.1static 修饰成员变量"></a>6.1static 修饰成员变量</h2><p>成员变量一旦被 static修饰之后，这个成员变量就叫做静态变量。</p><p>静态变量 的特点：</p><ul><li><p>被这个类所有对象共享</p></li><li><p>不属于对象，属于类</p></li><li><p>随着类的加载而加载，优先于对象存在</p><p>而对象一定要等 new 关键字执行了，它才在内存中出现</p></li></ul><h2 id="6-2static修饰成员方法"><a href="#6-2static修饰成员方法" class="headerlink" title="6.2static修饰成员方法"></a>6.2static修饰成员方法</h2><p>被static修饰的成员方法被称之为静态成员方法，是类的方法，不是某个对象所特有的，静态成员一般通过类名进行访问</p><h3 id="6-21工具类"><a href="#6-21工具类" class="headerlink" title="6.21工具类"></a>6.21工具类</h3><p>1：类名见名知意</p><p>2：私有化构造方法</p><p>3：方法定义为静态</p><h2 id="6-3静态代码块（重点）"><a href="#6-3静态代码块（重点）" class="headerlink" title="6.3静态代码块（重点）"></a>6.3静态代码块（重点）</h2><p>使用static修饰的{ }，称之为静态代码块，一般用于初始化静态成员变量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private String name;</span><br><span class="line">private int age;</span><br><span class="line">public static String classRoom;</span><br><span class="line"></span><br><span class="line">static &#123;</span><br><span class="line">    classRoom = &quot;405班&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>  静态代码块在整个工程中，随着类的加载而加载，并且自动触发，只会调用一次，无论实例化多少个对象，静态代码块只会在第一次实例化对象的时候调用。</p><p>使用场景：在类加载的时候，做一些数据初始化的时候使用</p><h2 id="6-4构造代码块（了解一下）"><a href="#6-4构造代码块（了解一下）" class="headerlink" title="6.4构造代码块（了解一下）"></a>6.4构造代码块（了解一下）</h2><p>构造代码块：定义在类中的代码块，同样是没有任何关键字修饰，只有{ }包围的代码，构造代码块也被称之为实例代码块。<br>    与普通代码块不同的是，构造代码块是定义在类中的，并且一般用于初始化成员变量，普通代码块不一定是在类中定义的，只能说普通代码块里面包含有构造代码块。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  name = &quot;梨花&quot;;</span><br><span class="line">  age = 20;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是：构造代码块先执行，然后才会执行构造方法，构造代码块实际上可以理解为一种默认的初始化， 因为当我们使用了构造代码块的时候，构造代码块里面的成员变量就已经固定了，除非我们更改代码，否则在调用默认无参构造方法的情况下，每次实例化对象，对象的数据都是构造代码块的数据，此时我们想要定义不同数据的代码块时，就可以通过构造方法，在重载构造方法的情况下调用含参的构造方法，从而达到实例化不同数据的对象的目的。</p><p>作用：可以把多个构造方法中重复的代码抽取出来</p><h2 id="6-5总结"><a href="#6-5总结" class="headerlink" title="6.5总结"></a>6.5总结</h2><p>​        1、静态代码块不管生成多少个对象，其都只会实行一次<br>    2、静态成员变量是类的属性，因此是在JVM加载类时开辟空间并初始化的<br>    3、如果一个类中包含有多个静态代码块或者构造代码块，在编译代码的时候，编译器会按照定义的顺序依次执行。 因为类中定义的静态代码块相当于同一等级到代码，没有执行的先后顺序，编译器就会按照定义的顺序依次执行，构造代码块也是如此。<br>    4、实例代码块只有在实例化对象时才会执行。 当通过类创建类类型的引用时，如果没有通过new关键字实例化对象，那么构造代码块一样不会执行<br>    5、先执行静态代码块，然后执行构造代码块，最后执行构造方法。</p><h1 id="7-final"><a href="#7-final" class="headerlink" title="7.final"></a>7.final</h1><h2 id="7-1修饰类"><a href="#7-1修饰类" class="headerlink" title="7.1修饰类"></a>7.1修饰类</h2><p>当某个类的整体定义为 final 时，就表明了你不打算继承该类，而且也不允许别人这么做。即这个类是不能有子类的。</p><h2 id="7-2修饰方法"><a href="#7-2修饰方法" class="headerlink" title="7.2修饰方法"></a>7.2修饰方法</h2><p>被 final 修饰的方法称为常量方法，该方法可以被重载，也可以被子类继承，但却不能被重写。当一个方法的功能已经可以满足当前要求，不需要进行扩展，我们就不用任何子类来重写该方法，防止该方法的内容被修改。比如 Object 类中，就有一个 final 修饰的 getClass() 方法，Object 的任何子类都不能重写这个方法。</p><h2 id="7-3修饰变量"><a href="#7-3修饰变量" class="headerlink" title="7.3修饰变量"></a>7.3修饰变量</h2><p>根据修饰变量的数据类型，比如在修饰基本类型和引用类型的变量时，final 也有不同的特性：</p><ol><li>final修饰基本类型的变量时，不能把基本类型的值重新赋值，因此基本类型的变量值不能被改变。</li><li>final修饰引用类型的变量时，final 只会保证引用类型的变量所引用的地址不会改变，即保证该变量会一直引用同一个对象。因为引用类型的变量保存的仅仅是一个引用地址，所以 final 修饰引用类型的变量时，该变量会一直引用同一个对象，但这个对象本身的成员和数据是完全可以发生改变的</li></ol><h2 id="7-4static-final"><a href="#7-4static-final" class="headerlink" title="7.4static final"></a>7.4static final</h2><p>一个既是 static 又是 final 的字段只占据一段不能改变的存储空间，它必须在定义的时候进行赋值，否则编译器将不予通过。</p><h2 id="7-5private-final"><a href="#7-5private-final" class="headerlink" title="7.5private final"></a>7.5private final</h2><p>private final byte[] value；字符串底层</p><p>由于value是private的，且没有提供setValue等公共方法来修改这个value值，所以在String类的外部是无法修改value值的，也就是说一旦初始化就不能被修改。此外，value变量是final的， 也就是说在String类内部，一旦这个值初始化了，value这个变量所引用的地址就不会改变了，即一直引用同一个对象。正是基于这一层，所以说String对象是不可变的对象</p><p>注意：但其实value所引用对象的内容完全可以发生改变，我们可以利用 [反射来消除String类对象的不可变特性]</p><h1 id="8权限修饰符"><a href="#8权限修饰符" class="headerlink" title="8权限修饰符"></a>8权限修饰符</h1><p><img src="https://pic.imgdb.cn/item/672b3bf5d29ded1a8cd79191.png" alt="7"></p><h1 id="9-接口"><a href="#9-接口" class="headerlink" title="9.接口"></a>9.接口</h1><h2 id="9-1接口概述"><a href="#9-1接口概述" class="headerlink" title="9.1接口概述"></a>9.1接口概述</h2><p>interface：[引用数据类型]：类、数组、接口</p><p>接口是对Java单继承的补充。Java只支持单继承（亲爹唯一），如果在开发过程中想额外增强类的功能，可以借助接口实现（可以拜师，拜多个师傅也可以）。</p><p>接口是Java中一种重要的抽象机制，它提供了一种定义行为规范和实现多态性的方式。通过合理使用接口，可以提高代码的可扩展性、可维护性和灵活性。</p><p>接口是除了类和数组之外，另外一种<strong>引用数据类型</strong>，需要使用 <code>interface</code> 关键字来定义，接口最终也会被编译成<code>.class文件</code>，但一定要明确接口并不是类，而是另外一种引用数据类型。</p><h2 id="9-2接口基础定义格式"><a href="#9-2接口基础定义格式" class="headerlink" title="9.2接口基础定义格式"></a>9.2接口基础定义格式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] interface 接口名 &#123;</span><br><span class="line">    //数据成员，可以定义多个</span><br><span class="line">    [public static final] 数据类型 数据成员 = 值;</span><br><span class="line"></span><br><span class="line">    //抽象方法：可以定义多个</span><br><span class="line">    [public abstract] 返回值类型 方法名(形参列表);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>案例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package com.briup.chap07.test;</span><br><span class="line"></span><br><span class="line">//使用interface关键字来定义接口</span><br><span class="line">interface IAction &#123;</span><br><span class="line">//数据成员,下面2行效果一样</span><br><span class="line">//public static final int NUM = 10;</span><br><span class="line">int NUM = 10;</span><br><span class="line"></span><br><span class="line">//成员方法,下面2行效果一样</span><br><span class="line">//public abstract void start();</span><br><span class="line">void start();</span><br><span class="line"></span><br><span class="line">public abstract void end();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Test021_Basic &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">//接口不可以实例化对象</span><br><span class="line">        //IAction ac = new IAction(); error</span><br><span class="line">        </span><br><span class="line">        System.out.println(IAction.NUM);</span><br><span class="line">        </span><br><span class="line">        //接口中数据成员默认 public static final，故而下行编译报错</span><br><span class="line">        //IAction.NUM = 20;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意1， 定义类使用关键字<code>class</code>，定义接口使用关键字<code>interface</code></p><p>注意2，接口中的数据成员，默认<code>public static final</code>修饰，是常量，名称全大写（符合命名规范）</p><p>注意3，接口中的方法，默认<code>public abstract</code>修饰，是抽象方法</p><ul><li><strong>JDK8</strong>中，还允许在接口中编写<strong>静态方法</strong>和<strong>默认方法</strong></li><li><strong>JDK9</strong>中，还允许在接口中编写<strong>私有方法</strong></li></ul><h2 id="9-3-接口实现"><a href="#9-3-接口实现" class="headerlink" title="9.3 接口实现"></a>9.3 接口实现</h2><p>Java中类和类之间的关系是继承，且只能是单继承</p><p>类和接口是实现关系，通过implements关键字表示，可以是单实现，也可以是多实现</p><p>子类还可以在继承一个父类的同时实现多个接口</p><p><strong>接口的实现类书写格式</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//一个类可以同时实现多个接口</span><br><span class="line">[修饰符] class 类名 implements 接口名1,接口名2,... &#123;</span><br><span class="line">重写所有抽象方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-4JDK8新特性"><a href="#9-4JDK8新特性" class="headerlink" title="9.4JDK8新特性"></a>9.4JDK8新特性</h2><p>JDK8新特性：接口可以包含静态方法和默认方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">package com.briup.chap07.test;</span><br><span class="line"></span><br><span class="line">//JDK8中接口 可以添加默认方法和static方法</span><br><span class="line">interface JDK8Action &#123;</span><br><span class="line">// 接口中静态常量</span><br><span class="line">String OPS_MODE = &quot;auto&quot;;</span><br><span class="line"></span><br><span class="line">// 接口中抽象方法</span><br><span class="line">void start();</span><br><span class="line">void stop();</span><br><span class="line">  </span><br><span class="line">    //下面是JDK8新特性</span><br><span class="line">//默认方法</span><br><span class="line">public default void dFun() &#123;</span><br><span class="line">System.out.println(&quot;in default fun() ...&quot;);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">//静态方法</span><br><span class="line">public static void sFun() &#123;</span><br><span class="line">System.out.println(&quot;in static fun() ...&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Demo01 implements JDK8Action &#123;</span><br><span class="line">@Override</span><br><span class="line">public void start() &#123;</span><br><span class="line">System.out.println(&quot;重写start() ...&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@Override</span><br><span class="line">public void stop() &#123;</span><br><span class="line">System.out.println(&quot;重写stop() ...&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Test026_JDK8 &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">//1.接口引用指向实现类对象</span><br><span class="line">JDK8Action a = new Demo01();</span><br><span class="line"></span><br><span class="line">//2.调用实现类重写方法</span><br><span class="line">a.start();</span><br><span class="line">a.stop();</span><br><span class="line"></span><br><span class="line">//3.调用default方法</span><br><span class="line">a.dFun();</span><br><span class="line"></span><br><span class="line">//4.JDK8中接口可以定义static方法，只能通过接口名调用，但不能通过接口引用调用，也不能通过实现类名调用</span><br><span class="line">//a.sFun();编译报错</span><br><span class="line">        //Demo01.sFun(); 编译报错</span><br><span class="line">JDK8Action.sFun();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-5JDK9新特性"><a href="#9-5JDK9新特性" class="headerlink" title="9.5JDK9新特性"></a>9.5JDK9新特性</h2><p>接口可以包含私有方法:分为普通的私有方法和静态的私有方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">package com.briup.chap07.test;</span><br><span class="line"></span><br><span class="line">//使用interface关键字来定义接口</span><br><span class="line">interface JDK9Action &#123;</span><br><span class="line">// 接口中的静态常量</span><br><span class="line">String OPS_MODE = &quot;auto&quot;;</span><br><span class="line"></span><br><span class="line">// 接口中的抽象方法</span><br><span class="line">void start();</span><br><span class="line"></span><br><span class="line">    //私有方法 jdk9以下报错</span><br><span class="line">private void run() &#123;</span><br><span class="line">    System.out.println(&quot;private run() ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Demo02 implements JDK8Action &#123;</span><br><span class="line">@Override</span><br><span class="line">public void start() &#123;</span><br><span class="line">System.out.println(&quot;重写start() ...&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//测试类</span><br><span class="line">public class Test026_JDK9 &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    //1.接口引用指向实现类对象</span><br><span class="line">JDK9Action a = new Demo02();</span><br><span class="line">        </span><br><span class="line">        //2.调用实现类重写的抽象方法</span><br><span class="line">        a.start();</span><br><span class="line">        </span><br><span class="line">        //3.调用接口private方法</span><br><span class="line">        a.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-6常见面试题"><a href="#9-6常见面试题" class="headerlink" title="9.6常见面试题"></a>9.6常见面试题</h2><p>接口和抽象类有什么区别？如何选择？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">定义方式：抽象类通过使用 abstract 关键字来定义，而接口使用 interface 关键字来定义</span><br><span class="line">数据成员：抽象类可以包含普通数据成员和static数据成员，而接口只能包含 static final 修饰的数据成员</span><br><span class="line">成员方法：抽象类可以包含具体的方法实现，而接口只能包含抽象方法，即没有方法体的方法声明</span><br><span class="line">构造函数：抽象类可以有构造函数，而接口不能有构造函数</span><br><span class="line">实现方式：一个类可以继承（extends）一个抽象类，而一个类可以实现（implements）多个接口</span><br><span class="line">多继承：Java不支持多继承，一个类只能继承一个抽象类，但可以实现多个接口</span><br></pre></td></tr></table></figure><h1 id="10-适配器设计模式"><a href="#10-适配器设计模式" class="headerlink" title="10.适配器设计模式"></a>10.适配器设计模式</h1><h2 id="10-1设计模式"><a href="#10-1设计模式" class="headerlink" title="10.1设计模式"></a>10.1设计模式</h2><p>设计模式是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。</p><p>使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性、程序的重用性。</p><h2 id="10-2适配器设计模式-结构型"><a href="#10-2适配器设计模式-结构型" class="headerlink" title="10.2适配器设计模式(结构型)"></a>10.2适配器设计模式(结构型)</h2><p>目的:，它可以来解决接口与接口实现类之间的矛盾问题。</p><p>案例:在这个接口中定义了10个抽象方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package com.itheima.a09interfacedemo9;</span><br><span class="line"></span><br><span class="line">public interface Inter &#123;</span><br><span class="line">    public abstract void method1();</span><br><span class="line">    public abstract void method2();</span><br><span class="line">    public abstract void method3();</span><br><span class="line">    public abstract void method4();</span><br><span class="line">    public abstract void method5();</span><br><span class="line">    public abstract void method6();</span><br><span class="line">    public abstract void method7();</span><br><span class="line">    public abstract void method8();</span><br><span class="line">    public abstract void method9();</span><br><span class="line">    public abstract void method10();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需求：我现在想要使用到这个接口的第5个抽象方法。</p><p>按照我们以前所学，先写一个实现类去实现 <code>Inter接口</code>。</p><p>实现一个接口，就需要重写里面所有的抽象方法。但是现在有一个问题：除了 method5() 方法外的其他9个抽象方法，都用不到！</p><p>在以前，由于接口的语法特点，其他的这些方法，我不得不重写，这样就会导致代码在书写起来的时候，或者后期在阅读的时候太麻烦了，不能让我一下子看到这个 method5()！<br>解决方法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">当一个接口中抽象方法过多，但是我只要使用其中一部分方法时候，就可以使用适配器设计模式去简化代码</span><br><span class="line"></span><br><span class="line">它的使用方式有以下几步</span><br><span class="line"></span><br><span class="line">编写一个中间类，中间类的名字为：XXXAdapter，其中 XXX 是接口名，后面再加一个 Adapter 即可，表示它是一个中间适配器类。然后让它去实现对应的接口。</span><br><span class="line">让 XXXAdapter 对接口中所有的抽象方法进行空实现。</span><br><span class="line">让真正的实现类继承中间类 XXXAdapter ，并重写需要用的方法</span><br><span class="line">为了避免其他类去创建中间适配器类的对象，中间的适配器类需要使用 abstract 来进行修饰</span><br></pre></td></tr></table></figure><p>细节:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果实现类还有其他的父类该怎么办呢？但是在Java中又不能多继承。</span><br><span class="line"></span><br><span class="line">此时我们就可以让中间的适配器去继承你想要的类就行了，Java不能多继承但是可以间接继承。</span><br></pre></td></tr></table></figure><h1 id="11-API"><a href="#11-API" class="headerlink" title="11.API"></a>11.API</h1><h2 id="11-1LocalDate"><a href="#11-1LocalDate" class="headerlink" title="11.1LocalDate"></a>11.1LocalDate</h2><p><a href="https://www.cnblogs.com/zhangzhixi/p/16455137.html">https://www.cnblogs.com/zhangzhixi/p/16455137.html</a></p><h3 id="11-1-1LocalDateTime"><a href="#11-1-1LocalDateTime" class="headerlink" title="11.1.1LocalDateTime"></a>11.1.1LocalDateTime</h3><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>static LocalDateTime now()</td><td>获取默认时区的当前日期时间</td></tr><tr><td>static LocalDateTime now(Clock clock)</td><td>从指定时钟获取当前日期时间</td></tr><tr><td>static LocalDateTime now(ZoneId zone)</td><td>获取指定时区的当前日期时间</td></tr><tr><td>static LocalDateTime of(LocalDate date, LocalTime time)</td><td>根据日期和时间对象获取LocalDateTime 实例</td></tr><tr><td>static LocalDateTime of(int year, Month month, int dayOfMonth, int hour, int minute, int second)</td><td>second) 根据指定的年、月、日、时、分、秒获取LocalDateTime 实例</td></tr><tr><td>getYear</td><td>获取年份</td></tr><tr><td>getMonth</td><td>使用月份枚举类获取月份</td></tr><tr><td>getDayOfMonth</td><td>获取日期在该月是第几天</td></tr><tr><td>getDayOfWeek</td><td>获取日期是星期几</td></tr><tr><td>getDayOfYear</td><td>获取日期在该年是第几天</td></tr><tr><td>getHour</td><td>获取小时</td></tr><tr><td>getMinute</td><td>获取分钟</td></tr><tr><td>getSecond</td><td>获取秒</td></tr><tr><td>getNano</td><td>获取纳秒</td></tr><tr><td>plusYears</td><td>增加年</td></tr><tr><td>plusMonths</td><td>增加月</td></tr><tr><td>plusWeeks</td><td>增加周</td></tr><tr><td>plusDays</td><td>增加天</td></tr><tr><td>plusHours</td><td>增加小时</td></tr><tr><td>plusMinutes</td><td>增加分</td></tr><tr><td>plusSeconds</td><td>增加秒</td></tr><tr><td>plusNanos</td><td>增加纳秒</td></tr><tr><td>minusYears</td><td>减少年</td></tr><tr><td>minusMonths</td><td>减少月</td></tr><tr><td>meminusWeeks</td><td>减少周</td></tr><tr><td>minusDays</td><td>减少天</td></tr><tr><td>minusHours</td><td>减少小时</td></tr><tr><td>minusMinutes</td><td>减少分</td></tr><tr><td>minusSeconds</td><td>减少秒</td></tr><tr><td>minusNanos</td><td>减少纳秒</td></tr><tr><td>isEqual</td><td>判断日期时间是否相等</td></tr><tr><td>isBefore</td><td>检查是否在指定日期时间之前</td></tr><tr><td>isAfter</td><td>检查是否在指定日期时间之后</td></tr></tbody></table><h2 id="11-2常见算法API-Arrays"><a href="#11-2常见算法API-Arrays" class="headerlink" title="11.2常见算法API-Arrays"></a>11.2常见算法API-Arrays</h2><p>Arrays:数组类</p><h3 id="11-2-1常用方法"><a href="#11-2-1常用方法" class="headerlink" title="11.2.1常用方法:"></a>11.2.1常用方法:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static String toString(数组)                           把数组拼接成一个字符串</span><br><span class="line">public static int binarySearch (数组，查找的元素)               二分查找法查找元素</span><br><span class="line">public static int[] copyOf(原数组，新数组长度)                  拷贝数组</span><br><span class="line">public static int[] copyOfRange(原数组，起始索引，结束索引)       拷贝数组(指定范围)</span><br><span class="line">public static void fill(数组，元素)                            填充数组</span><br><span class="line">public static void sort(数组)                                 按照默认方式进行数组排序</span><br><span class="line">public static void sort(数组，排序规则)                        按照指定的规则排序</span><br></pre></td></tr></table></figure><p>示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//把数组拼接成一个字符串</span><br><span class="line">        int[] arr = &#123;1,2,3,4,5,6,7,8,9,10&#125;;</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">        //二分查找法查找元素,返回索引</span><br><span class="line">        System.out.println(Arrays.binarySearch(arr, 1));</span><br><span class="line"></span><br><span class="line">        //拷贝数组</span><br><span class="line">        int[] ints = Arrays.copyOf(arr, 12);</span><br><span class="line">        System.out.println(Arrays.toString(ints));</span><br><span class="line"></span><br><span class="line">        //拷贝数组(指定范围):包头不包尾</span><br><span class="line">        int[] ints1 = Arrays.copyOfRange(arr, 0, 9);</span><br><span class="line">        System.out.println(Arrays.toString(ints1));</span><br><span class="line"></span><br><span class="line">        //填充数组</span><br><span class="line">//        Arrays.fill(arr,1);</span><br><span class="line">//        System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">        //按照默认方式进行数组排序:升序</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="11-2-2常用方法排序规则"><a href="#11-2-2常用方法排序规则" class="headerlink" title="11.2.2常用方法排序规则"></a>11.2.2常用方法排序规则</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Integer[] arr = &#123;1,2,3,4,5,6,7,8,9,10&#125;;</span><br><span class="line">Arrays.sort(arr, new Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int compare(Integer o1, Integer o2) &#123;</span><br><span class="line">        return o2 - o1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Lambda表达式:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//匿名内部类:</span><br><span class="line">Arrays.sort(arr, new Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public int compare(Integer o1, Integer o2) &#123;</span><br><span class="line">                return o1 - o2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">============================================================================================================  //Lambda表达式(标准格式):</span><br><span class="line">    Arrays.sort(arr, (Integer o1, Integer o2)-&gt;&#123;</span><br><span class="line">                return o1 - o2;</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br></pre></td></tr></table></figure><h1 id="12双列集合-—-Map-系列"><a href="#12双列集合-—-Map-系列" class="headerlink" title="12双列集合 — Map 系列"></a>12双列集合 — Map 系列</h1><h2 id="12-1-双列集合体系结构"><a href="#12-1-双列集合体系结构" class="headerlink" title="12.1.双列集合体系结构"></a>12.1.双列集合体系结构</h2><p><img src="https://pic.imgdb.cn/item/672b3bffd29ded1a8cd79af6.png" alt="15"></p><p>Map 集合定义了很多方法，如下表。</p><p><img src="https://pic.imgdb.cn/item/672b3bfed29ded1a8cd79a74.png" alt="16"></p><h2 id="12-2Map-的遍历方式"><a href="#12-2Map-的遍历方式" class="headerlink" title="12.2Map 的遍历方式"></a>12.2Map 的遍历方式</h2><p> Map 集合有三种遍历方式，键找值、依次键值对、Lambda 表达式遍历。</p><h3 id="1-键找值-三种方式"><a href="#1-键找值-三种方式" class="headerlink" title="1.键找值(三种方式)"></a>1.键找值(三种方式)</h3><p> 可以创建一个键的单列集合，通过每一个元素调用 get 方法来找对应的值。</p><p>案例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">package Maps;</span><br><span class="line"></span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">public class MapDemo2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //遍历方式1</span><br><span class="line">        //1.创建Map集合对象</span><br><span class="line">        Map&lt;String, String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        //2.添加元素</span><br><span class="line">        map.put(&quot;喜羊羊&quot;,&quot;美羊羊&quot;);</span><br><span class="line">        map.put(&quot;大大怪&quot;,&quot;小小怪&quot;);</span><br><span class="line">        map.put(&quot;虹猫&quot;,&quot;蓝兔&quot;);</span><br><span class="line"></span><br><span class="line">        //3.通过键找值</span><br><span class="line">        //3.1 把键获取放入单列集合</span><br><span class="line">        Set&lt;String&gt; keys = map.keySet();</span><br><span class="line">        //3.2 遍历单列集合得到每一个键,增强for</span><br><span class="line">           -------------------------------------------------------------------</span><br><span class="line">        for (String key : keys) &#123;</span><br><span class="line">            //System.out.println(key);</span><br><span class="line">            //3.3 利用键获取每一个值</span><br><span class="line">            String value = map.get(key);</span><br><span class="line">            System.out.println(key + &quot; = &quot; + value);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">           -------------------------------------------------------------------</span><br><span class="line">        //lambda表达式遍历单列集合keys :匿名内部类</span><br><span class="line">       keys.forEach(new Consumer&lt;String&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void accept(String s) &#123;</span><br><span class="line">                System.out.println(s + &quot; = &quot; + map.get(s));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        //lambda表达式简化</span><br><span class="line">       keys.forEach(s -&gt; System.out.println(s + &quot; = &quot; + map.get(s)));</span><br><span class="line">       </span><br><span class="line">     -------------------------------------------------------------------  </span><br><span class="line">       //迭代器的形式遍历</span><br><span class="line">               Iterator&lt;String&gt; it = keys.iterator();</span><br><span class="line">        while (it.hasNext()) &#123;</span><br><span class="line">            String key =  it.next();</span><br><span class="line">            System.out.println(key + &quot; = &quot; + map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-键值对遍历"><a href="#2-键值对遍历" class="headerlink" title="2.键值对遍历"></a>2.键值对遍历</h3><p>获取每一对键值对，然后调用 get 方法获取键和值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">package Maps;</span><br><span class="line"></span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">public class MapDemo3 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //遍历方式2</span><br><span class="line">        //1.创建Map集合对象</span><br><span class="line">        Map&lt;String, String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        //2.添加元素</span><br><span class="line">        map.put(&quot;喜羊羊&quot;,&quot;美羊羊&quot;);</span><br><span class="line">        map.put(&quot;大大怪&quot;,&quot;小小怪&quot;);</span><br><span class="line">        map.put(&quot;虹猫&quot;,&quot;蓝兔&quot;);</span><br><span class="line"></span><br><span class="line">        //3.通过键值对对象遍历</span><br><span class="line">        //3.1 通过一个方法获取所有键值对对象，返回一个set集合</span><br><span class="line">        Set&lt;Map.Entry&lt;String, String&gt;&gt; entries = map.entrySet();</span><br><span class="line">        //3.2 遍历entries集合找到所有键值对对象</span><br><span class="line">        for (Map.Entry&lt;String, String&gt; entry : entries) &#123;</span><br><span class="line">            String key = entry.getKey();</span><br><span class="line">            String value = entry.getValue();</span><br><span class="line">            System.out.println(key + &quot; = &quot; + value);</span><br><span class="line">        &#125;</span><br><span class="line">        //3.3迭代器遍历</span><br><span class="line">Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator = entries.iterator();</span><br><span class="line">        while (iterator.hasNext()) &#123;</span><br><span class="line">            Map.Entry&lt;String, String&gt; entry = iterator.next();</span><br><span class="line">            String key = entry.getKey();</span><br><span class="line">            String value = entry.getValue();</span><br><span class="line">            System.out.println(key + &quot; = &quot; + value);</span><br><span class="line">        &#125;</span><br><span class="line">        //3.4lambda遍历</span><br><span class="line">        entries.forEach(new Consumer&lt;Map.Entry&lt;String, String&gt;&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void accept(Map.Entry&lt;String, String&gt; stringStringEntry) &#123;</span><br><span class="line">                String key = stringStringEntry.getKey();</span><br><span class="line">                String value = stringStringEntry.getValue();</span><br><span class="line">                System.out.println(key + &quot; = &quot; + value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        //3.4简化</span><br><span class="line">        -------------------------------------------------------------------</span><br><span class="line">        entries.forEach(stringStringEntry -&gt; &#123;</span><br><span class="line">            String key = stringStringEntry.getKey();</span><br><span class="line">            String value = stringStringEntry.getValue();</span><br><span class="line">            System.out.println(key + &quot; = &quot; + value);</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-Lambda-表达式遍历键值对-底层第二种遍历"><a href="#3-Lambda-表达式遍历键值对-底层第二种遍历" class="headerlink" title="3. Lambda 表达式遍历键值对(底层第二种遍历)"></a>3. Lambda 表达式遍历键值对(底层第二种遍历)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package Maps;</span><br><span class="line"></span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line">import java.util.function.BiConsumer;</span><br><span class="line"></span><br><span class="line">public class MapDemo4 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //遍历方式3</span><br><span class="line">        //1.创建Map集合对象</span><br><span class="line">        Map&lt;String, String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        //2.添加元素</span><br><span class="line">        map.put(&quot;鲁迅&quot;,&quot;这句话是我说的&quot;);</span><br><span class="line">        map.put(&quot;曹操&quot;,&quot;不可能，绝对不可能&quot;);</span><br><span class="line">        map.put(&quot;刘备&quot;,&quot;接着奏乐，接着舞&quot;);</span><br><span class="line">        map.put(&quot;张飞&quot;,&quot;我一枪挑了大哥！&quot;);</span><br><span class="line"></span><br><span class="line">        //3.利用lambda表达式进行遍历</span><br><span class="line">/*  map.forEach(new BiConsumer&lt;String, String&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void accept(String key, String value) &#123;</span><br><span class="line">                System.out.println(key + &quot;=&quot; + value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);*/</span><br><span class="line">        map.forEach((key, value) -&gt; System.out.println(key + &quot;=&quot; + value));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-3HashMap"><a href="#12-3HashMap" class="headerlink" title="12.3HashMap"></a>12.3HashMap</h2><h3 id="1-HashMap的创建"><a href="#1-HashMap的创建" class="headerlink" title="1.HashMap的创建"></a>1.HashMap的创建</h3><pre><code>    HashMap 是 Map 的一个实现类。    HashMap 中无额外方法，直接使用 Map 中的方法即可。    HashMap 的特点由键决定：无序、不重复、无索引。    HashMap 和 HashSet 在底层都是哈希表实现的：数组 + 链表 + 红黑树。</code></pre><p> 1.在存入数据时，HashMap 是以键为准的，和值无关。它会利用键计算出哈希值，存入哈希表中。</p><p> 2.如果碰到已经存放元素的位置，还是根据键的属性值来判断。</p><p> 3.如果新元素的键和旧元素一模一样，直接覆盖之。</p><p>4.如果新元素的键和旧的不一样，直接挂在旧元素下面，形成链表。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当链表的长度超过8 &amp; 数组长度&gt;=64时，链表自动转成红黑树。</span><br><span class="line"></span><br><span class="line">        根据底层结构可知，HashMap 底层存储和值没有任何关系，其依赖 hashCode() 方法和 equals() 方法保证键的唯一，如果键存储的是自定义对象，一定要重写这两个方法；但如果值存储的是自定义对象，那就不需要重写，存储和值无关。</span><br></pre></td></tr></table></figure><h2 id="12-4LinkedHashMap"><a href="#12-4LinkedHashMap" class="headerlink" title="12.4LinkedHashMap"></a>12.4LinkedHashMap</h2><p><img src="https://pic.imgdb.cn/item/672b3c08d29ded1a8cd7a24f.png" alt="17"></p><h2 id="12-5TreeMap"><a href="#12-5TreeMap" class="headerlink" title="12.5TreeMap"></a>12.5TreeMap</h2><h3 id="1-TreeMap特点"><a href="#1-TreeMap特点" class="headerlink" title="1.TreeMap特点"></a>1.TreeMap特点</h3><p>TreeMap 和 TreeSet 底层原理一样，都是红黑树结构的。<br>        TreeMap 的特性由键决定：不重复、无索引、可排序。<br>        TreeMap 的排序是对键的排序，默认按照键的从小到大排序（字符串就是字典顺序），也可以按照自己规定的排序规则排序，规定方式和 TreeSet 别无二致。</p><h3 id="2-TreeMap集合排序两种方式"><a href="#2-TreeMap集合排序两种方式" class="headerlink" title="2.TreeMap集合排序两种方式"></a>2.TreeMap集合排序两种方式</h3><p>实现 Comparable 接口，指定比较规则。<br>创建集合时传入 Comparator 比较器对象，指定比较规则。</p><h3 id="3-两种方式比较"><a href="#3-两种方式比较" class="headerlink" title="3.两种方式比较:"></a>3.两种方式比较:</h3><p>适用场景不同：<br>Comparable 适用于当你拥有键类型的源码并且希望该类型总是遵循相同的排序规则时。<br>Comparator 更灵活，适合于你需要为同一个类型提供多种排序规则，或者你无法修改键类型源码的情况。<br>实现复杂度：<br>实现 Comparable 要求修改或创建新的类文件。<br>使用 Comparator 可以在创建 TreeMap 的时候直接指定，不需要改变现有类的结构。<br>可读性和维护性：<br>如果排序逻辑非常简单且通用，实现 Comparable 可能会使代码更加清晰。<br>复杂的排序逻辑或者多样的排序需求更适合用 Comparator，因为它可以更好地封装和复用这些逻辑</p><h1 id="13-Collections"><a href="#13-Collections" class="headerlink" title="13.Collections"></a>13.Collections</h1><p>Collections 是集合的工具类</p><p>下面前两个是常用API:</p><p><img src="https://pic.imgdb.cn/item/672b3c08d29ded1a8cd7a26d.png" alt="18"></p><h1 id="14-Stream流的思想"><a href="#14-Stream流的思想" class="headerlink" title="14.Stream流的思想"></a>14.Stream流的思想</h1><p><img src="https://pic.imgdb.cn/item/672b3c08d29ded1a8cd7a29b.png" alt="19"></p><h2 id="14-1-概述"><a href="#14-1-概述" class="headerlink" title="14.1 概述"></a>14.1 概述</h2><p>Stream流可以让你通过链式操作对集合中的元素进行过滤、映射、排序、组合等操作，这些操作都是惰性执行的，只有在终端操作（如forEach、collect等）被调用时才会触发实际计算。Stream流可以简化代码并提高代码的可读性，同时也可以让编译器更好地进行优化，提高代码的执行效率。</p><h2 id="14-2-常见方法"><a href="#14-2-常见方法" class="headerlink" title="14.2 常见方法"></a>14.2 常见方法</h2><p>Stream流的三类方法</p><ul><li>获取Stream流<ul><li>创建一条流水线并把数据放到流水线上准备进行操作</li></ul></li><li>中间方法<ul><li>流水线上的操作</li><li>一次操作完毕之后,还可以继续进行其他操作</li></ul></li><li>终结方法<ul><li>一个Stream流只能有一个终结方法</li><li>是流水线上的最后一个操作</li></ul></li></ul><h3 id="1-获取Stream的方式"><a href="#1-获取Stream的方式" class="headerlink" title="1.获取Stream的方式"></a>1.获取Stream的方式</h3><p><img src="https://pic.imgdb.cn/item/672b3c08d29ded1a8cd7a2d2.png" alt="20"></p><p>Stream流中的方法大多数都是函数式接口，因此可以用lambda表达式来简化开发</p><h3 id="2-中间方法"><a href="#2-中间方法" class="headerlink" title="2.中间方法"></a>2.中间方法</h3><p><img src="https://pic.imgdb.cn/item/672b3c08d29ded1a8cd7a22a.png" alt="21"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Demo05 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        Collections.addAll(list,&quot;1&quot;,&quot;2&quot;,&quot;3&quot;);</span><br><span class="line">//        list.stream().map(new Function&lt;String, Integer&gt;() &#123;</span><br><span class="line">//            @Override</span><br><span class="line">//            public Integer apply(String s) &#123;</span><br><span class="line">//                return Integer.parseInt(s);</span><br><span class="line">//            &#125;</span><br><span class="line">//        &#125;).forEach(s-&gt; System.out.println(s.getClass() + &quot; &quot; + s));</span><br><span class="line"> </span><br><span class="line">        //用lambda表达式后</span><br><span class="line">        list.stream()</span><br><span class="line">                .map(s -&gt; Integer.parseInt(s))</span><br><span class="line">                .forEach(s-&gt; System.out.println(s.getClass() + &quot; &quot; + s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">输出结果：</span><br><span class="line"> </span><br><span class="line">class java.lang.Integer  1</span><br><span class="line">class java.lang.Integer  2</span><br><span class="line">class java.lang.Integer  3</span><br></pre></td></tr></table></figure><h3 id="3-终结方法"><a href="#3-终结方法" class="headerlink" title="3.终结方法"></a>3.终结方法</h3><p><img src="https://pic.imgdb.cn/item/672b3da9d29ded1a8cd96866.png" alt="22"></p><p>案例如下:</p><h4 id="3-1toArray-终结方法"><a href="#3-1toArray-终结方法" class="headerlink" title="3.1toArray()终结方法:"></a>3.1toArray()终结方法:</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class Demo06 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        Collections.addAll(list,&quot;林俊杰&quot;,&quot;林忆莲&quot;,&quot;周杰伦&quot;,&quot;周兴哲&quot;);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        // toArray()          收集流中的数据，放到数组中</span><br><span class="line">        //Object[] arr1 = list.stream().toArray();</span><br><span class="line">        //System.out.println(Arrays.toString(arr1));</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        //IntFunction的泛型：具体要保存的数据类型</span><br><span class="line">        //apply的形参：流中的数据个数，要跟数组的长度保持一致</span><br><span class="line">        //apply的返回值：具体要保存的数据类型,这里需要指定values个数,不然会报错</span><br><span class="line">        String[] array = list.stream().toArray(new IntFunction&lt;String[]&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public String[] apply(int value) &#123;</span><br><span class="line">                return new String[value];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">输出结果：</span><br><span class="line"> </span><br><span class="line">[林俊杰, 林忆莲, 周杰伦, 周兴哲]</span><br></pre></td></tr></table></figure><h4 id="3-2-collect-Collector-collector"><a href="#3-2-collect-Collector-collector" class="headerlink" title="3.2 collect(Collector collector)"></a>3.2 collect(Collector collector)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">public class Demo07 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"> </span><br><span class="line">        /*</span><br><span class="line">            collect(Collector collector)            收集流中的数据，放到集合中 (List Set Map)</span><br><span class="line">            注意点：</span><br><span class="line">                如果我们要收集到Map集合当中，键不能重复，否则会报错</span><br><span class="line">       */</span><br><span class="line"> </span><br><span class="line">        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        Collections.addAll(list, &quot;张无忌-男-15&quot;, &quot;周芷若-女-14&quot;, &quot;赵敏-女-13&quot;, &quot;张强-男-20&quot;,</span><br><span class="line">                &quot;张三丰-男-100&quot;, &quot;张翠山-男-40&quot;, &quot;张良-男-35&quot;, &quot;王二麻子-男-37&quot;, &quot;谢广坤-男-41&quot;);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        //收集List集合当中</span><br><span class="line">        //需求：</span><br><span class="line">        //我要把所有的男性收集起来</span><br><span class="line">        List&lt;String&gt; newList1 = list.stream()</span><br><span class="line">                .filter(s -&gt; &quot;男&quot;.equals(s.split(&quot;-&quot;)[1]))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        //System.out.println(newList1);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        //收集Set集合当中</span><br><span class="line">        //需求：</span><br><span class="line">        //我要把所有的男性收集起来</span><br><span class="line">        Set&lt;String&gt; newList2 = list.stream().filter(s -&gt; &quot;男&quot;.equals(s.split(&quot;-&quot;)[1]))</span><br><span class="line">                .collect(Collectors.toSet());</span><br><span class="line">        //System.out.println(newList2);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        //收集Map集合当中</span><br><span class="line">        //谁作为键,谁作为值.</span><br><span class="line">        //我要把所有的男性收集起来</span><br><span class="line">        //键：姓名。 值：年龄</span><br><span class="line">        Map&lt;String, Integer&gt; map = list.stream()</span><br><span class="line">                .filter(s -&gt; &quot;男&quot;.equals(s.split(&quot;-&quot;)[1]))</span><br><span class="line">                /*</span><br><span class="line">                 *   toMap : 参数一表示键的生成规则</span><br><span class="line">                 *           参数二表示值的生成规则</span><br><span class="line">                 *</span><br><span class="line">                 * 参数一：</span><br><span class="line">                 *       Function泛型一：表示流中每一个数据的类型</span><br><span class="line">                 *               泛型二：表示Map集合中键的数据类型</span><br><span class="line">                 *</span><br><span class="line">                 *        方法apply形参：依次表示流里面的每一个数据</span><br><span class="line">                 *               方法体：生成键的代码</span><br><span class="line">                 *               返回值：已经生成的键</span><br><span class="line">                 *</span><br><span class="line">                 *</span><br><span class="line">                 * 参数二：</span><br><span class="line">                 *        Function泛型一：表示流中每一个数据的类型</span><br><span class="line">                 *                泛型二：表示Map集合中值的数据类型</span><br><span class="line">                 *</span><br><span class="line">                 *       方法apply形参：依次表示流里面的每一个数据</span><br><span class="line">                 *               方法体：生成值的代码</span><br><span class="line">                 *               返回值：已经生成的值</span><br><span class="line">                 *</span><br><span class="line">                 * */</span><br><span class="line">                .collect(Collectors.toMap(new Function&lt;String, String&gt;() &#123;</span><br><span class="line">                                              @Override</span><br><span class="line">                                              public String apply(String s) &#123;</span><br><span class="line">                                                  //张无忌-男-15</span><br><span class="line">                                                  return s.split(&quot;-&quot;)[0];</span><br><span class="line">                                              &#125;</span><br><span class="line">                                          &#125;,</span><br><span class="line">                        new Function&lt;String, Integer&gt;() &#123;</span><br><span class="line">                            @Override</span><br><span class="line">                            public Integer apply(String s) &#123;</span><br><span class="line">                                return Integer.parseInt(s.split(&quot;-&quot;)[2]);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;));</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        Map&lt;String, Integer&gt; map2 = list.stream()</span><br><span class="line">                .filter(s -&gt; &quot;男&quot;.equals(s.split(&quot;-&quot;)[1]))</span><br><span class="line">                .collect(Collectors.toMap(</span><br><span class="line">                        s -&gt; s.split(&quot;-&quot;)[0],</span><br><span class="line">                        s -&gt; Integer.parseInt(s.split(&quot;-&quot;)[2])));</span><br><span class="line"> </span><br><span class="line">        System.out.println(map2);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="15-方法引用"><a href="#15-方法引用" class="headerlink" title="15.方法引用"></a>15.方法引用</h1><p>(简化lambda表达式)</p><p>1.什么是方法引用?<br>把已经存在的方法拿过来用，当做函数式接口中抽象方法的方法体<br>2.方法引用时要注意什么?</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">需要有函数式接口</span><br><span class="line">被引用方法必须已经存在</span><br><span class="line">被引用方法的形参和返回值需要跟抽象方法保持一致</span><br><span class="line">被引用方法的功能要满足当前的需求</span><br></pre></td></tr></table></figure><h4 id="1-引用静态方法"><a href="#1-引用静态方法" class="headerlink" title="1.引用静态方法"></a>1.引用静态方法</h4><p>类名::静态方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer::parseInt</span><br></pre></td></tr></table></figure><h4 id="2-引用成员方法"><a href="#2-引用成员方法" class="headerlink" title="2.引用成员方法"></a>2.引用成员方法</h4><p>对象::成员方法</p><p> 其他类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">其他类对象::方法名</span><br></pre></td></tr></table></figure><p>本类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>::方法名</span><br></pre></td></tr></table></figure><p>父类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">super</span>::方法名</span><br></pre></td></tr></table></figure><h4 id="3-使用类名引用成员方法"><a href="#3-使用类名引用成员方法" class="headerlink" title="3.使用类名引用成员方法"></a>3.使用类名引用成员方法</h4><p>类名::成员方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String::substring</span><br></pre></td></tr></table></figure><p>后续补充</p><h1 id="16-IO流"><a href="#16-IO流" class="headerlink" title="16.IO流"></a>16.IO流</h1><h2 id="1-io流的分类"><a href="#1-io流的分类" class="headerlink" title="1.io流的分类"></a>1.io流的分类</h2><p><img src="https://pic.imgdb.cn/item/672b3c16d29ded1a8cd7ae90.png" alt="26"></p><p>注意，纯文本文件指的是：Windows 自带的记事本打开能读懂的文件，比如：txt、md、xml、lrc 等，它们可以用字符流的方式处理。而 docx、xls 等文件不是纯文本文件，只能用字节流的方式处理。</p><h2 id="2-io流的体系结构"><a href="#2-io流的体系结构" class="headerlink" title="2.io流的体系结构"></a>2.io流的体系结构</h2><p><img src="https://pic.imgdb.cn/item/672b3c16d29ded1a8cd7ae4e.png" alt="27"></p><p><img src="https://pic.imgdb.cn/item/672b3c1bd29ded1a8cd7b2c3.png" alt="28"></p><h2 id="3-FileOutputStream-字节流"><a href="#3-FileOutputStream-字节流" class="headerlink" title="3.FileOutputStream(字节流)"></a>3.FileOutputStream(字节流)</h2><p>FileOutputStream 是操作本地文件的字节输出流，可以把程序中的数据写到本地文件中。</p><p>① 创建字节输出流对象。<br>② 写数据。<br>③ 释放资源。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package IOByteStream;</span><br><span class="line"></span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class ByteStreamDemo1 &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        /*</span><br><span class="line">            演示：字节输出流FileOutputStream</span><br><span class="line">            需求：写出一段文字到本地文件中（写出）</span><br><span class="line">            实现步骤：创建对象、写出数据、释放资源</span><br><span class="line">         */</span><br><span class="line"></span><br><span class="line">        //1.创建对象</span><br><span class="line">        FileOutputStream fos = new FileOutputStream(&quot;D:\\IdeaProjects\\HelloWord\\src\\IOByteStream\\a.txt&quot;);</span><br><span class="line"></span><br><span class="line">        //2.写出数据</span><br><span class="line">        fos.write(97);</span><br><span class="line"></span><br><span class="line">        //3.释放资源</span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 在输出到文件的过程中存在诸多细节：</p><p>1.创建字节输出流对象时，参数可以是字符串表示的路径，也可以是 File 对象。<br>2.如果参数中的文件不存在会创建一个新的文件，但是一定要保证这个文件的父级路径是存在的。<br>3.如果文件已存在，会先清空这个文件，再写入。<br>4.write 方法的参数是整数，但是实际上写到本地文件中的是整数在ASCII上对应的字符，97 –&gt; a。<br>5.每次使用完流之后，都要释放资源。</p><h3 id="3-1-FileOutputStream-写数据的3种方式"><a href="#3-1-FileOutputStream-写数据的3种方式" class="headerlink" title="3.1 FileOutputStream 写数据的3种方式"></a>3.1 FileOutputStream 写数据的3种方式</h3><p><img src="https://pic.imgdb.cn/item/672b3c1bd29ded1a8cd7b2d1.png" alt="29"></p><h3 id="3-2换行写"><a href="#3-2换行写" class="headerlink" title="3.2换行写"></a>3.2换行写</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">package IOByteStream;</span><br><span class="line"></span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class ByteStreamDemo3 &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        /*</span><br><span class="line">            换行写</span><br><span class="line">            Windows换行是 \r\n</span><br><span class="line">            Java中可以写 \r \n 任何一个作为换行符，在底层可以自动补全</span><br><span class="line"></span><br><span class="line">            续写</span><br><span class="line">         */</span><br><span class="line"></span><br><span class="line">        //1.创建对象</span><br><span class="line">        FileOutputStream fos = new FileOutputStream(&quot;D:\\IdeaProjects\\HelloWord\\src\\IOByteStream\\a.txt&quot;);</span><br><span class="line"></span><br><span class="line">        //2.写出数据</span><br><span class="line">        //kankelaoyezuishuai</span><br><span class="line">        String str1 = &quot;kankelaoyezuishuai&quot;;</span><br><span class="line">        byte[] bytes1 = str1.getBytes();</span><br><span class="line">        fos.write(bytes1);</span><br><span class="line"></span><br><span class="line">        String br = &quot;\r\n&quot;;</span><br><span class="line">        byte[] bytes2 = br.getBytes();</span><br><span class="line">        fos.write(bytes2);</span><br><span class="line"></span><br><span class="line">        String str2 = &quot;666&quot;;</span><br><span class="line">        byte[] bytes3 = str2.getBytes();</span><br><span class="line">        fos.write(bytes3);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //3.释放资源</span><br><span class="line">        fos.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3续写"><a href="#3-3续写" class="headerlink" title="3.3续写"></a>3.3续写</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package IOByteStream;</span><br><span class="line"></span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class ByteStreamDemo4 &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        /*</span><br><span class="line">            续写开关 boolean append</span><br><span class="line">            在创建对象时,这个变量如果是true,文件就不会清空，可以续写；如果是false，文件就会被覆盖</span><br><span class="line">         */</span><br><span class="line"></span><br><span class="line">        //1.创建对象</span><br><span class="line">        FileOutputStream fos = new FileOutputStream(&quot;D:\\IdeaProjects\\HelloWord\\src\\IOByteStream\\a.txt&quot;,true);</span><br><span class="line"></span><br><span class="line">        //2.写出数据</span><br><span class="line">        //kankelaoyezuishuai</span><br><span class="line">        String str1 = &quot;kankelaoyezuishuai&quot;;</span><br><span class="line">        byte[] bytes1 = str1.getBytes();</span><br><span class="line">        fos.write(bytes1);</span><br><span class="line">        </span><br><span class="line">        //3.释放资源</span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-FileInputStream"><a href="#4-FileInputStream" class="headerlink" title="4.FileInputStream"></a>4.FileInputStream</h2><p> FileInputStream 字节输入流可以操作本地文件，把里面的数据读取到程序中来。<br>书写步骤：<br>    ① 创建字节输入流对象。<br>    ② 读数据。<br>    ③ 释放资源。</p><h3 id="4-1-FileInputStream-循环读取"><a href="#4-1-FileInputStream-循环读取" class="headerlink" title="4.1 FileInputStream 循环读取"></a>4.1 FileInputStream 循环读取</h3><p>由于 read 方法每次只能读取一个字节，所以我们要学习循环读取，这样才能读完一个文件中所有的内容。<br>定义一个变量 b ，用来存储读到的每一个字符，然后用一个 while 循环打印每一个字符，循环条件用 read() 方法赋值给 b，每进行一次这个赋值，读取字符的“指针”就前进一步，循环直到 read() 方法返回 -1，此时意味着读到了文件尾，循环结束。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package IOByteStream;</span><br><span class="line"></span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class ByteStreamDemo6 &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        /*</span><br><span class="line">            字节输入流循环读取</span><br><span class="line">         */</span><br><span class="line"></span><br><span class="line">        //1.创建对象</span><br><span class="line">        FileInputStream fis = new FileInputStream(&quot;D:\\IdeaProjects\\HelloWord\\src\\IOByteStream\\a.txt&quot;);</span><br><span class="line"></span><br><span class="line">        //2.循环读取</span><br><span class="line">        int b;</span><br><span class="line">        while((b = fis.read()) != -1) &#123;</span><br><span class="line">            System.out.print((char)b);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //3.释放资源</span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2文件拷贝"><a href="#4-2文件拷贝" class="headerlink" title="4.2文件拷贝"></a>4.2文件拷贝</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">package IOByteStream;</span><br><span class="line"></span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class ByteStreamDemo7 &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        /*</span><br><span class="line">            文件拷贝</span><br><span class="line">            把D:\IdeaProjects\HelloWord\src\Files\beCopied拷贝到当前模块下</span><br><span class="line"></span><br><span class="line">        */</span><br><span class="line"></span><br><span class="line">        //1.创建对象</span><br><span class="line">        FileInputStream fis = new FileInputStream(&quot;D:\\IdeaProjects\\HelloWord\\src\\Files\\beCopied&quot;);</span><br><span class="line">        FileOutputStream fos = new FileOutputStream(&quot;D:\\IdeaProjects\\HelloWord\\src\\IOByteStream\\Copy.txt&quot;);</span><br><span class="line"></span><br><span class="line">        //2.拷贝</span><br><span class="line">        //核心思想：边读边写</span><br><span class="line">        int b;</span><br><span class="line">        while((b = fis.read()) != -1) &#123;</span><br><span class="line">            fos.write(b);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //3.释放资源</span><br><span class="line">        //规则：先开的流最后再关闭</span><br><span class="line">        fos.close();</span><br><span class="line">        fis.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文件拷贝存在一个很严肃的问题，如果拷贝的文件过大，速度会不会有影响？会的，速度非常慢。因为 FileInputStream 在拷贝时，一次只读写一个字节，有多少个字节，就要循环多少次。<br>        如果想要提高拷贝的速度，就需要一次读取多个字节，它也有相关的方法，看下面的表格：<br><img src="https://pic.imgdb.cn/item/672b3c1bd29ded1a8cd7b2f4.png" alt="30"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package IOByteStream;</span><br><span class="line"></span><br><span class="line">import java.io.FileInputStream;</span><br><span class="line">import java.io.FileNotFoundException;</span><br><span class="line">import java.io.FileOutputStream;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class ByteStreamDemo9 &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        /*</span><br><span class="line">            &quot;D:\\IdeaProjects\\HelloWord\\src\\Files\\beCopied&quot;拷贝到&quot;D:\\IdeaProjects\\HelloWord\\src\\IOByteStream\\Copy.txt&quot;</span><br><span class="line">         */</span><br><span class="line"></span><br><span class="line">        long l1 = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        //1.创建IO流</span><br><span class="line">        FileInputStream fis = new FileInputStream(&quot;D:\\IdeaProjects\\HelloWord\\src\\Files\\beCopied&quot;);</span><br><span class="line">        FileOutputStream fos = new FileOutputStream(&quot;D:\\IdeaProjects\\HelloWord\\src\\IOByteStream\\Copy.txt&quot;);</span><br><span class="line"></span><br><span class="line">        //2.一次读取多个字节的数据</span><br><span class="line">        int len;</span><br><span class="line">        byte[] bytes = new byte[1024 * 1024 * 5];</span><br><span class="line">        while((len = fis.read(bytes)) != -1) &#123;</span><br><span class="line">            fos.write(bytes,0, len);            //将bytes[] 数组中 0索引开始 len 长度的数据写入文件</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //3.关闭IO流</span><br><span class="line">        fis.close();</span><br><span class="line">        fos.close();</span><br><span class="line"></span><br><span class="line">        long l2 = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        System.out.println(l2 - l1);            //用了2毫秒</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="17-字符集"><a href="#17-字符集" class="headerlink" title="17.字符集"></a>17.字符集</h1><p>一、常见的字符集</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. GB2312 字符集：1980年发布，1981年5月1日实施的简体中文汉字编码标准，收录7445个图形字符，其中包括6763个简体汉字。</span><br><span class="line">2. BIG5 字符集：台湾地区繁体中文标准字符集，共收录13053个中文汉字，1984年实施。</span><br><span class="line">3. GBK 字符集：2000年3月17日发布，收录21003个汉字，包含国家标准 GB13000-1 中的全部中日韩汉字，和 BIG5 编码中的所有汉字。在 Windows 系统中默认使用的字符集就是 GBK。GB 代表国标，K 代表扩展。在微软系统中起的名字叫 ANSI 。</span><br><span class="line">4. Unicode 字符集：国际标准字符集，它将世界各种语言的每个字符定义一个唯一的编码，以满足跨语言、跨平台的文本信息转换。</span><br></pre></td></tr></table></figure><img src="D:\面试文档\assets\31.jpg" alt="31" style="zoom: 67%;" /><p>二、计算机的 GBK 存储规则（英文）</p><p>​    GBK 编码是完全向下兼容 ASCII 码的。英文字母用一个字节来存储，完全兼容 ASCII 。在存储字符时，不足8位在前面补0。</p><p><img src="https://pic.imgdb.cn/item/672b3c1bd29ded1a8cd7b2b2.png" alt="32"></p><p>三、计算机的 GBK 存储规则（汉字）<br>        一个汉字的长度是 2 个字节（16 bit）。第一个字节被称为高位字节，第二个字节被称为低位字节。高位字节的二进制一定以1开头，转成十进制后是一个负数。字节码的二进制格式在存储到计算机中时，不需要变动。计算机底层以编码最高位是 0 还是 1 来区分中文字符和英文字符<br><img src="https://pic.imgdb.cn/item/672b3c20d29ded1a8cd7b7db.png" alt="33"></p><p>四、Unicode 字符集</p><p>​    Unicode 字符集是统一码联盟发布的一个统一字符集，包含了世界上大部分国家的文字字符。Unicode 在编码时，有多种编码方案。早前有 UTF-16、UTF-32 等编码方案，后都已废弃。后来出现了 UTF-8 编码规则，它是一种针对 Unicode 字符集的可变长度编码规则，它规定一个字符用 1~4 个字节保存。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UTF-8 规定，如果是 ASCII 码中有的字符，就用 1 个字节存储；如果是拉丁文、希伯来文等文字，用 2 个字节存储；如果中日韩文字、东南亚文字、中东文字，用 3 个字节存储；其他语言，用 4 个字节存储。四种编码的数字补充格式如下：</span><br><span class="line">1.Unicode字符集的UTF-8编码格式</span><br><span class="line">一个英文占一个字节，二进制第一位是0，转成十进制是正数</span><br><span class="line"></span><br><span class="line">一个中文占三个字节，二进制第一位是1，第一个字节转成十进制是负数</span><br></pre></td></tr></table></figure><p>UTF-8解码:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1. **识别字节顺序和长度**：</span><br><span class="line">   - 对于UTF-8编码，每个字符根据其Unicode码点范围使用不同数量的字节进行编码。</span><br><span class="line">     - 单字节：U+0000至U+007F，编码为`0xxxxxxx`</span><br><span class="line">     - 双字节：U+0080至U+07FF，编码为`110xxxxx 10xxxxxx`</span><br><span class="line">     - 三字节：U+0800至U+FFFF，编码为`1110xxxx 10xxxxxx 10xxxxxx`</span><br><span class="line">     - 四字节：U+10000至U+10FFFF，编码为`11110xxx 10xxxxxx 10xxxxxx 10xxxxxx`</span><br><span class="line">2. **解码过程**：</span><br><span class="line">   - 遍历UTF-8字符串的每个字节。</span><br><span class="line">   - 根据首位的1的数量确定后续字节的数量和模式。</span><br><span class="line">   - 分别从每个字节中提取有效位并拼接起来，形成最终的Unicode码点</span><br><span class="line">eg:</span><br><span class="line">UTF-8编码1110 1001 1010 0011 1001 1110  将1.中的xx取出来得到 1001 1000 1101 1110就是对应unicode编码</span><br></pre></td></tr></table></figure><h1 id="18-字符流"><a href="#18-字符流" class="headerlink" title="18.字符流"></a>18.字符流</h1><p>什么是字符流?</p><p> 字符流的底层就是字符流+字符集，它能实现在读取时，碰到英文字母，还按 1 个字节读取，碰到汉字时，则按多个字节读取（UTF-8 是 3 个字节，GBK 是 2 个字节）。因此，字符流用于纯文本场景的数据输入和输出。</p><h2 id="18-1Reader-——-字符输入流"><a href="#18-1Reader-——-字符输入流" class="headerlink" title="18.1Reader —— 字符输入流"></a>18.1Reader —— 字符输入流</h2><pre><code>Reader 是字符输入流的抽象总类，它不能直接创建对象。但是有 FileReader 继承 Reader，它可以实现对本地文件的字符输入。FileReader 的使用步骤如下：</code></pre><p><img src="https://pic.imgdb.cn/item/672b3c20d29ded1a8cd7b7ea.png" alt="34"></p><p><img src="https://pic.imgdb.cn/item/672b3c20d29ded1a8cd7b80c.png" alt="35"></p><h3 id="1-read-空参读取："><a href="#1-read-空参读取：" class="headerlink" title="1.read() 空参读取："></a>1.read() 空参读取：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package IOCharStream;</span><br><span class="line"></span><br><span class="line">import java.io.FileReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class CharStreamDemo1 &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        /*</span><br><span class="line">            字符输入流的使用</span><br><span class="line">         */</span><br><span class="line"></span><br><span class="line">        //1.创建对象</span><br><span class="line">        FileReader fr = new FileReader(&quot;D:\\IdeaProjects\\HelloWord\\src\\IOCharStream\\hhh.txt&quot;);</span><br><span class="line"></span><br><span class="line">        //2.读取数据 read() 空参</span><br><span class="line">        int ch;</span><br><span class="line">        while((ch = fr.read()) != -1)&#123;</span><br><span class="line">            System.out.print((char)ch);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //read() 细节：</span><br><span class="line">        //1.默认一个字节一个字节读取，但是遇到中文会一次读 3 个字节（默认UTF-8）</span><br><span class="line">        //2.该方法读取的字符会将二进制转成十进制，这个十进制也表示在字符集上的数字</span><br><span class="line">        //3.如果想看中文汉字，直接将这些十进制数据强转即可</span><br><span class="line"></span><br><span class="line">        //3.释放资源</span><br><span class="line">        fr.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-带参-read-方法详解："><a href="#2-带参-read-方法详解：" class="headerlink" title="2.带参 read() 方法详解："></a>2.带参 read() 方法详解：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package IOCharStream;</span><br><span class="line"></span><br><span class="line">import java.io.FileReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class CharStreamDemo2 &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        /*</span><br><span class="line">            public int read(char[]  buffer)     //一次读取多个数据，参数为char类型数组，返回值为读取到的字符个数</span><br><span class="line">         */</span><br><span class="line"></span><br><span class="line">        //1.创建对象</span><br><span class="line">        FileReader fr = new FileReader(&quot;D:\\IdeaProjects\\HelloWord\\src\\IOCharStream\\hhh.txt&quot;);</span><br><span class="line"></span><br><span class="line">        //2.读取数据</span><br><span class="line">        char[] chars = new char[2];         //一次读两个字符</span><br><span class="line">        int len;</span><br><span class="line">        //read(chars):读取数据，解码，强制类型转换，三合一，将强转之后的字符放入数组中</span><br><span class="line">        //带参read = 空参read + 强转</span><br><span class="line">        while((len = fr.read(chars)) != -1)&#123;</span><br><span class="line">            //把数组中的数据变成字符串再打印</span><br><span class="line">            System.out.print(new String(chars, 0 , len));           //转字符串细节：从0索引到len索引转</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //3.释放资源</span><br><span class="line">        fr.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="18-2Writer-——-字符输出流"><a href="#18-2Writer-——-字符输出流" class="headerlink" title="18.2Writer —— 字符输出流"></a>18.2Writer —— 字符输出流</h2><p>Writer 是字符输出流的抽象总类，它不能直接创建对象。但有 FileWriter 继承自它，可以实现对本地文件数据的输出。<br>FileWriter 的使用方法如下：</p><h3 id="①利用构造方法生成对象。"><a href="#①利用构造方法生成对象。" class="headerlink" title="①利用构造方法生成对象。"></a>①利用构造方法生成对象。</h3><p><img src="https://pic.imgdb.cn/item/672b3c20d29ded1a8cd7b81f.png" alt="36"></p><p>细节1：参数是字符串表示的路径或者 File 对象表示的路径都可以。<br>细节2：如果文件不存在，会自动创建一个新的文件，但要保证父级路径是存在的。<br>细节3：如果文件已存在，默认覆写文件，如果不想清空可以打开续写开关。</p><h3 id="②-调用成员方法写出。"><a href="#②-调用成员方法写出。" class="headerlink" title="② 调用成员方法写出。"></a>② 调用成员方法写出。</h3><p>![1730879855873](D:\新建文件夹\WeChat Files\wxid_cqgchisdtjwi22\FileStorage\Temp\1730879855873.jpg)</p><p>细节：如果 write 方法的参数是一个整数，实际上写到本地文件中的是这个整数在字符集上对应的 char 字符。</p><p>③ 释放资源</p><p><img src="https://pic.imgdb.cn/item/672b3c20d29ded1a8cd7b7c9.png" alt="37"></p><h1 id="19-高级流"><a href="#19-高级流" class="headerlink" title="19.高级流"></a>19.高级流</h1><h2 id="19-1缓冲流体系"><a href="#19-1缓冲流体系" class="headerlink" title="19.1缓冲流体系"></a>19.1缓冲流体系</h2><p><img src="https://pic.imgdb.cn/item/672b3c26d29ded1a8cd7bce7.png" alt="38"></p><h3 id="1-字节缓冲流"><a href="#1-字节缓冲流" class="headerlink" title="1.字节缓冲流"></a>1.字节缓冲流</h3><p>字节缓冲流底层自带了一次可以读写 8192 长度的缓冲区。它的构造方法是将基本流通过一个方法进行包装，加入缓冲区。</p><p><img src="https://pic.imgdb.cn/item/672b3c26d29ded1a8cd7bcfc.png" alt="39"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">以下演示了如何利用字节缓冲流来拷贝一个文件：</span><br><span class="line">package BufferedStream;</span><br><span class="line"></span><br><span class="line">import java.io.*;</span><br><span class="line"></span><br><span class="line">public class BufferedStreamDemo1 &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        /*</span><br><span class="line">            字节缓冲流拷贝文件（一次读写一个字节）</span><br><span class="line">         */</span><br><span class="line"></span><br><span class="line">        //1.创建缓冲流对象</span><br><span class="line">        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;D:\\IdeaProjects\\HelloWord\\src\\BufferedStream\\a.txt&quot;));</span><br><span class="line">        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;D:\\IdeaProjects\\HelloWord\\src\\BufferedStream\\a_Copied.txt&quot;));</span><br><span class="line"></span><br><span class="line">        //2.循环读取并写入目的地</span><br><span class="line">        int b;</span><br><span class="line">        while((b = bis.read()) != -1)&#123;</span><br><span class="line">            bos.write(b);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //3.释放资源</span><br><span class="line">        bos.close();</span><br><span class="line">        bis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package BufferedStream;</span><br><span class="line"></span><br><span class="line">import java.io.*;</span><br><span class="line"></span><br><span class="line">public class BufferedStreamDemo2 &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        /*</span><br><span class="line">            字节缓冲流拷贝文件（一次读写一个字节数组）</span><br><span class="line">         */</span><br><span class="line"></span><br><span class="line">        //1.创建缓冲流对象</span><br><span class="line">        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(&quot;D:\\IdeaProjects\\HelloWord\\src\\BufferedStream\\a.txt&quot;));</span><br><span class="line">        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(&quot;D:\\IdeaProjects\\HelloWord\\src\\BufferedStream\\a_Copied.txt&quot;));</span><br><span class="line"></span><br><span class="line">        //2.字节数组</span><br><span class="line">        byte[] bytes = new byte[1024 * 1024 * 5];</span><br><span class="line">        int len;</span><br><span class="line">        while((len = bis.read(bytes)) != -1)&#123;</span><br><span class="line">            bos.write(bytes,0,len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //3.关闭流</span><br><span class="line">        bos.close();</span><br><span class="line">        bis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-字节缓冲流提高效率的底层原理"><a href="#2-字节缓冲流提高效率的底层原理" class="headerlink" title="2.字节缓冲流提高效率的底层原理"></a>2.字节缓冲流提高效率的底层原理</h3><p><img src="https://pic.imgdb.cn/item/672b3c26d29ded1a8cd7bd0a.png" alt="40"></p><p>可以看到，读写数据时，字节数据是在<strong>内存</strong>中的缓冲区进行倒手的，而内存的读写数据是非常非常快的，它的读写速度快到这个倒手的过程可以忽略不计，大大节省了数据与硬盘之间的交互时间。</p><h2 id="19-2字符缓冲流"><a href="#19-2字符缓冲流" class="headerlink" title="19.2字符缓冲流"></a>19.2字符缓冲流</h2><p><img src="https://pic.imgdb.cn/item/672b3c26d29ded1a8cd7bd2c.png" alt="41"></p><p>构造方法如下：</p><p><img src="https://pic.imgdb.cn/item/672b3c26d29ded1a8cd7bd38.png" alt="42"></p><p><img src="https://pic.imgdb.cn/item/672b3c28d29ded1a8cd7c05a.png" alt="43"></p><h3 id="1-字符缓冲输入流的用法："><a href="#1-字符缓冲输入流的用法：" class="headerlink" title="1.字符缓冲输入流的用法："></a>1.字符缓冲输入流的用法：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package BufferedStream;</span><br><span class="line"></span><br><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.FileReader;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class BufferedStreamDemo3 &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        /*</span><br><span class="line">            字符缓冲输入流</span><br><span class="line">         */</span><br><span class="line"></span><br><span class="line">        //1.创建字符缓冲输入流对象</span><br><span class="line">        BufferedReader br = new BufferedReader(new FileReader(&quot;D:\\IdeaProjects\\HelloWord\\src\\BufferedStream\\a.txt&quot;));</span><br><span class="line"></span><br><span class="line">        //2.一行一行读</span><br><span class="line">        String line;</span><br><span class="line">        while((line = br.readLine()) != null) &#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //3.释放资源</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-字符缓冲输出流的用法"><a href="#2-字符缓冲输出流的用法" class="headerlink" title="2.字符缓冲输出流的用法:"></a>2.字符缓冲输出流的用法:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package BufferedStream;</span><br><span class="line"></span><br><span class="line">import java.io.BufferedWriter;</span><br><span class="line">import java.io.FileWriter;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">public class BufferedStreamDemo5 &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        /*</span><br><span class="line">            字符缓冲输出流</span><br><span class="line">         */</span><br><span class="line"></span><br><span class="line">        //1.创建</span><br><span class="line">        BufferedWriter bw = new BufferedWriter(new FileWriter(&quot;D:\\IdeaProjects\\HelloWord\\src\\BufferedStream\\b.txt&quot;));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //2.写出数据</span><br><span class="line">        bw.write(&quot;你嘴角上扬的样子，百度搜索不到&quot;);</span><br><span class="line">        bw.newLine();       //跨平台换行</span><br><span class="line">        bw.write(&quot;以后如果我结婚了，你一定要来哦，没有新娘我会很尴尬&quot;);</span><br><span class="line">        bw.newLine();</span><br><span class="line"></span><br><span class="line">        //3.释放资源</span><br><span class="line">        bw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="19-3转换流"><a href="#19-3转换流" class="headerlink" title="19.3转换流"></a>19.3转换流</h2><h2 id="19-4序列化流和反序列化流"><a href="#19-4序列化流和反序列化流" class="headerlink" title="19.4序列化流和反序列化流"></a>19.4序列化流和反序列化流</h2>]]></content>
      
      
      <categories>
          
          <category> 工作ing~ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>暗藏玄机</title>
      <link href="/posts/45351.html"/>
      <url>/posts/45351.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="270ab4bc50c0c2d0f9ed761b1e6a2410fb75185325653c8363c034db38c4079a">b7ceb76c270f3503934243b777b7d095ad21e42370d3d1a7461ec33e7efff163</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">oi!小鬼,又来视奸o.O?.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> 作为日记加密 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何解决精神上的内耗,完成自我的救赎</title>
      <link href="/posts/37560.html"/>
      <url>/posts/37560.html</url>
      
        <content type="html"><![CDATA[<div align=center class="aspect-ratio">    <iframe src="https://player.bilibili.com/player.html?aid=113187454193838&&page=1&as_wide=1&high_quality=1&danmaku=0"     scrolling="no"     border="0"     frameborder="no"     framespacing="0"     high_quality=1    danmaku=1     allowfullscreen="true">     </iframe></div>]]></content>
      
      
      <categories>
          
          <category> 无脑发癫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 颠颠的 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逆水寒日常</title>
      <link href="/posts/2281.html"/>
      <url>/posts/2281.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 逆水寒手游 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CS </tag>
            
            <tag> 密码币 </tag>
            
            <tag> 太极拔剑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/16107.html"/>
      <url>/posts/16107.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 工作ing~ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 标签示例 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/custom.css"/>
      <url>/css/custom.css</url>
      
        <content type="html"><![CDATA[/* 页脚与头图透明 */#footer {    background: transparent !important;  }  #page-header {    background: transparent !important;  }    /* 白天模式遮罩透明 */  #footer::before {    background: transparent !important;  }  #page-header::before {    background: transparent !important;  }    /* 夜间模式遮罩透明 */  [data-theme="dark"] #footer::before {    background: transparent !important;  }  [data-theme="dark"] #page-header::before {    background: transparent !important;  }  /* 日间模式不生效 */[data-theme="light"] #site-name,[data-theme="light"] #site-title,[data-theme="light"] #site-subtitle,[data-theme="light"] #post-info {  animation: none;}/* 夜间模式生效 */[data-theme="dark"] #site-name,[data-theme="dark"] #site-title {  animation: light_15px 10s linear infinite;}[data-theme="dark"] #site-subtitle {  animation: light_10px 10s linear infinite;}[data-theme="dark"] #post-info {  animation: light_5px 10s linear infinite;}/* 关键帧描述 */@keyframes light_15px {  0% {    text-shadow: #5636ed 0 0 15px;  }  12.5% {    text-shadow: #11ee5e 0 0 15px;  }  25% {    text-shadow: #f14747 0 0 15px;  }  37.5% {    text-shadow: #f1a247 0 0 15px;  }  50% {    text-shadow: #f1ee47 0 0 15px;  }  50% {    text-shadow: #b347f1 0 0 15px;  }  62.5% {    text-shadow: #002afa 0 0 15px;  }  75% {    text-shadow: #ed709b 0 0 15px;  }  87.5% {    text-shadow: #39c5bb 0 0 15px;  }  100% {    text-shadow: #5636ed 0 0 15px;  }}@keyframes light_10px {  0% {    text-shadow: #5636ed 0 0 10px;  }  12.5% {    text-shadow: #11ee5e 0 0 10px;  }  25% {    text-shadow: #f14747 0 0 10px;  }  37.5% {    text-shadow: #f1a247 0 0 10px;  }  50% {    text-shadow: #f1ee47 0 0 10px;  }  50% {    text-shadow: #b347f1 0 0 10px;  }  62.5% {    text-shadow: #002afa 0 0 10px;  }  75% {    text-shadow: #ed709b 0 0 10px;  }  87.5% {    text-shadow: #39c5bb 0 0 10px;  }  100% {    text-shadow: #5636ed 0 0 10px;  }}@keyframes light_5px {  0% {    text-shadow: #5636ed 0 0 5px;  }  12.5% {    text-shadow: #11ee5e 0 0 5px;  }  25% {    text-shadow: #f14747 0 0 5px;  }  37.5% {    text-shadow: #f1a247 0 0 15px;  }  50% {    text-shadow: #f1ee47 0 0 5px;  }  50% {    text-shadow: #b347f1 0 0 5px;  }  62.5% {    text-shadow: #002afa 0 0 5px;  }  75% {    text-shadow: #ed709b 0 0 5px;  }  87.5% {    text-shadow: #39c5bb 0 0 5px;  }  100% {    text-shadow: #5636ed 0 0 5px;  }}/* 背景宇宙星光  */#universe{    display: block;    position: fixed;    margin: 0;    padding: 0;    border: 0;    outline: 0;    left: 0;    top: 0;    width: 100%;    height: 100%;    pointer-events: none;    /* 这个是调置顶的优先级的，-1在文章页下面，背景上面，个人推荐这种 */    z-index: -1;  }  /* 侧边栏个人信息卡片动态渐变色 */#aside-content > .card-widget.card-info {  background: linear-gradient(    -45deg,    #e8d8b9,    #eccec5,    #a3e9eb,    #bdbdf0,    #eec1ea  );  box-shadow: 0 0 5px rgb(66, 68, 68);  position: relative;  background-size: 400% 400%;  -webkit-animation: Gradient 10s ease infinite;  -moz-animation: Gradient 10s ease infinite;  animation: Gradient 10s ease infinite !important;}@-webkit-keyframes Gradient {  0% {    background-position: 0% 50%;  }  50% {    background-position: 100% 50%;  }  100% {    background-position: 0% 50%;  }}@-moz-keyframes Gradient {  0% {    background-position: 0% 50%;  }  50% {    background-position: 100% 50%;  }  100% {    background-position: 0% 50%;  }}@keyframes Gradient {  0% {    background-position: 0% 50%;  }  50% {    background-position: 100% 50%;  }  100% {    background-position: 0% 50%;  }}/* 黑夜模式适配 */[data-theme="dark"] #aside-content > .card-widget.card-info {  background: #191919ee;}/* 个人信息Follow me按钮 */#aside-content > .card-widget.card-info > #card-info-btn {  background-color: #3eb8be;  border-radius: 8px;}/* 侧边栏个人信息卡片动态渐变色 */#aside-content > .card-widget.card-info {    background: linear-gradient(      -45deg,      #e8d8b9,      #eccec5,      #a3e9eb,      #bdbdf0,      #eec1ea    );    box-shadow: 0 0 5px rgb(66, 68, 68);    position: relative;    background-size: 400% 400%;    -webkit-animation: Gradient 10s ease infinite;    -moz-animation: Gradient 10s ease infinite;    animation: Gradient 10s ease infinite !important;  }  @-webkit-keyframes Gradient {    0% {      background-position: 0% 50%;    }    50% {      background-position: 100% 50%;    }    100% {      background-position: 0% 50%;    }  }  @-moz-keyframes Gradient {    0% {      background-position: 0% 50%;    }    50% {      background-position: 100% 50%;    }    100% {      background-position: 0% 50%;    }  }  @keyframes Gradient {    0% {      background-position: 0% 50%;    }    50% {      background-position: 100% 50%;    }    100% {      background-position: 0% 50%;    }  }    /* 黑夜模式适配 */  [data-theme="dark"] #aside-content > .card-widget.card-info {    background: #191919ee;  }    /* 个人信息Follow me按钮 */  #aside-content > .card-widget.card-info > #card-info-btn {    background-color: #3eb8be;    border-radius: 8px;  }  /*哔哩哔哩视频适配*/.aspect-ratio {  position: relative;  width: 90%;  height: auto;  padding-bottom: 75%;  margin: 3% auto;  text-align: center;}.aspect-ratio iframe {  position: absolute;  width: 100%;  height: 86%;  left: 0;  top: 0;}/* 头像呼吸灯 */[data-theme="light"] .avatar-img {  animation: huxi_light 4s ease-in-out infinite;}[data-theme="dark"] .avatar-img {  animation: huxi_dark 4s ease-in-out infinite;}@keyframes huxi_light {  0% {    box-shadow: 0px 0px 1px 1px #e9f5fa;  }  50% {    box-shadow: 0px 0px 5px 5px #e9f5fa;  }  100% {    box-shadow: 0px 0px 1px 1px #e9f5fa;  }}@keyframes huxi_dark {  0% {    box-shadow: 0px 0px 1px 1px #39c5bb;  }  50% {    box-shadow: 0px 0px 5px 5px #39c5bb;  }  100% {    box-shadow: 0px 0px 1px 1px #39c5bb;  }}/* 帧率检测 */#fps {  position: fixed;  /* 指定位置 */  right: 10px;  bottom: 10px;  z-index: 1919810;}[data-theme="light"] #fps {  background-color: rgba(255, 255, 255, 0.85);  backdrop-filter: var(--backdrop-filter);  padding: 4px;  border-radius: 4px;}[data-theme="dark"] #fps {  background-color: rgba(0, 0, 0, 0.72);  backdrop-filter: var(--backdrop-filter);  padding: 4px;  border-radius: 4px;}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/runtime.js"/>
      <url>/js/runtime.js</url>
      
        <content type="html"><![CDATA[var now=new Date;function createtime(){now.setTime(now.getTime()+1e3);var e=new Date("09/30/2024 00:00:00"),t=Math.trunc(234e8+(now-e)/1e3*17),a=(t/1496e5).toFixed(6),o=new Date("10/18/2024 00:00:00"),n=(now-o)/1e3/60/60/24,r=Math.floor(n),i=(now-o)/1e3/60/60-24*r,s=Math.floor(i);1==String(s).length&&(s="0"+s);var d=(now-o)/1e3/60-1440*r-60*s,l=Math.floor(d);1==String(l).length&&(l="0"+l);var g=(now-o)/1e3-86400*r-3600*s-60*l,b=Math.round(g);1==String(b).length&&(b="0"+b);let c="";c=s<18&&s>=9?`<img class='boardsign' src='' title='什么时候能够实现财富自由呀~'><br> <div style="font-size:13px;font-weight:bold">本站居然运行了 ${r} 天 ${s} 小时 ${l} 分 ${b} 秒 <i id="heartbeat" class='fas fa-heartbeat'></i> <br> 旅行者 1 号当前距离地球 ${t} 千米，约为 ${a} 个天文单位 🚀</div>`:`<img class='boardsign' src='https://sourcebucket.s3.ladydaily.com/badge/F小屋-下班休息啦.svg' title='下班了就该开开心心地玩耍~'><br> <div style="font-size:13px;font-weight:bold">本站居然运行了 ${r} 天 ${s} 小时 ${l} 分 ${b} 秒 <i id="heartbeat" class='fas fa-heartbeat'></i> <br> 旅行者 1 号当前距离地球 ${t} 千米，约为 ${a} 个天文单位 🚀</div>`,document.getElementById("workboard")&&(document.getElementById("workboard").innerHTML=c)}setInterval((()=>{createtime()}),1e3);]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>説説</title>
      <link href="/shuoshuo/index.html"/>
      <url>/shuoshuo/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/console.js"/>
      <url>/js/console.js</url>
      
        <content type="html"><![CDATA[var now1 = new Date();function createtime1() {    var grt = new Date("09/30/2024 00:00:00"); //此处修改你的建站时间或者网站上线时间    now1.setTime(now1.getTime() + 250);    var days = (now1 - grt) / 1000 / 60 / 60 / 24;    var dnum = Math.floor(days);    var ascll = [        `欢迎来到无名🥝の小家!`,        `Future is now 🍭🍭🍭`,        "小站已经苟活",        dnum,        "天啦!",        "©2024 By wuming",    ];    setTimeout(        console.log.bind(            console,            `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,            "color:#39c5bb",            "",            "color:#39c5bb",            "color:#39c5bb",            "",            "color:#39c5bb",            ""        )    );}createtime1();function createtime2() {    var ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为「大聪明」`, `Photo captured: `, ` 🤪 `];    setTimeout(        console.log.bind(            console,            `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}`,            "color:white; background-color:#10bcc0",            "",            "",            'background:url("") no-repeat;font-size:450%'        )    );    setTimeout(console.log.bind(console, "%c WELCOME %c 欢迎光临，大聪明", "color:white; background-color:#23c682", ""));    setTimeout(        console.warn.bind(            console,            "%c ⚡ Powered by wuming🥝 %c 你正在访问无名🥝の小家",            "color:white; background-color:#f0ad4e",            ""        )    );    setTimeout(console.log.bind(console, "%c W23-12 %c 系统监测到你已打开控制台", "color:white; background-color:#4f90d9", ""));    setTimeout(        console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中", "color:white; background-color:#d9534f", "")    );}createtime2();// 重写console方法console.log = function () { };console.error = function () { };console.warn = function () { };]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/fps.js"/>
      <url>/js/fps.js</url>
      
        <content type="html"><![CDATA[if (window.localStorage.getItem("fpson") == undefined || window.localStorage.getItem("fpson") == "1") {    var rAF = function () {        return (            window.requestAnimationFrame ||            window.webkitRequestAnimationFrame ||            function (callback) {                window.setTimeout(callback, 1000 / 60);            }        );    }();    var frame = 0;    var allFrameCount = 0;    var lastTime = Date.now();    var lastFameTime = Date.now();    var loop = function () {        var now = Date.now();        var fs = (now - lastFameTime);        var fps = Math.round(1000 / fs);        lastFameTime = now;        // 不置 0，在动画的开头及结尾记录此值的差值算出 FPS        allFrameCount++;        frame++;        if (now > 1000 + lastTime) {            var fps = Math.round((frame * 1000) / (now - lastTime));            if (fps <= 5) {                var kd = `<span style="color:#bd0000">卡成ppt🤢</span>`            } else if (fps <= 15) {                var kd = `<span style="color:red">电竞级帧率😖</span>`            } else if (fps <= 25) {                var kd = `<span style="color:orange">有点难受😨</span>`            } else if (fps < 35) {                var kd = `<span style="color:#9338e6">不太流畅🙄</span>`            } else if (fps <= 45) {                var kd = `<span style="color:#08b7e4">还不错哦😁</span>`            } else {                var kd = `<span style="color:#39c5bb">十分流畅🤣</span>`            }            document.getElementById("fps").innerHTML = `FPS:${fps} ${kd}`;            frame = 0;            lastTime = now;        };        rAF(loop);    }    loop();} else {    document.getElementById("fps").style = "display:none!important"}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/title.js"/>
      <url>/js/title.js</url>
      
        <content type="html"><![CDATA[//动态标题var OriginTitile = document.title;var titleTime;document.addEventListener('visibilitychange', function () {  if (document.hidden) {    //离开当前页面时标签显示内容    document.title = '👀跑哪里去捏~';    clearTimeout(titleTime);  } else {    //返回当前页面时标签显示内容    document.title = '🐖抓到你啦嘻嘻～';    //两秒后变回正常标题    titleTime = setTimeout(function () {      document.title = OriginTitile;    }, 2000);  }});]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>友情链接</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>文章分类</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/universe.js"/>
      <url>/js/universe.js</url>
      
        <content type="html"><![CDATA[function dark() {window.requestAnimationFrame=window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame||window.msRequestAnimationFrame;var n,e,i,h,t=.05,s=document.getElementById("universe"),o=!0,a="180,184,240",r="226,225,142",d="226,225,224",c=[];function f(){n=window.innerWidth,e=window.innerHeight,i=.216*n,s.setAttribute("width",n),s.setAttribute("height",e)}function u(){h.clearRect(0,0,n,e);for(var t=c.length,i=0;i<t;i++){var s=c[i];s.move(),s.fadeIn(),s.fadeOut(),s.draw()}}function y(){this.reset=function(){this.giant=m(3),this.comet=!this.giant&&!o&&m(10),this.x=l(0,n-10),this.y=l(0,e),this.r=l(1.1,2.6),this.dx=l(t,6*t)+(this.comet+1-1)*t*l(50,120)+2*t,this.dy=-l(t,6*t)-(this.comet+1-1)*t*l(50,120),this.fadingOut=null,this.fadingIn=!0,this.opacity=0,this.opacityTresh=l(.2,1-.4*(this.comet+1-1)),this.do=l(5e-4,.002)+.001*(this.comet+1-1)},this.fadeIn=function(){this.fadingIn&&(this.fadingIn=!(this.opacity>this.opacityTresh),this.opacity+=this.do)},this.fadeOut=function(){this.fadingOut&&(this.fadingOut=!(this.opacity<0),this.opacity-=this.do/2,(this.x>n||this.y<0)&&(this.fadingOut=!1,this.reset()))},this.draw=function(){if(h.beginPath(),this.giant)h.fillStyle="rgba("+a+","+this.opacity+")",h.arc(this.x,this.y,2,0,2*Math.PI,!1);else if(this.comet){h.fillStyle="rgba("+d+","+this.opacity+")",h.arc(this.x,this.y,1.5,0,2*Math.PI,!1);for(var t=0;t<30;t++)h.fillStyle="rgba("+d+","+(this.opacity-this.opacity/20*t)+")",h.rect(this.x-this.dx/4*t,this.y-this.dy/4*t-2,2,2),h.fill()}else h.fillStyle="rgba("+r+","+this.opacity+")",h.rect(this.x,this.y,this.r,this.r);h.closePath(),h.fill()},this.move=function(){this.x+=this.dx,this.y+=this.dy,!1===this.fadingOut&&this.reset(),(this.x>n-n/4||this.y<0)&&(this.fadingOut=!0)},setTimeout(function(){o=!1},50)}function m(t){return Math.floor(1e3*Math.random())+1<10*t}function l(t,i){return Math.random()*(i-t)+t}f(),window.addEventListener("resize",f,!1),function(){h=s.getContext("2d");for(var t=0;t<i;t++)c[t]=new y,c[t].reset();u()}(),function t(){document.getElementsByTagName('html')[0].getAttribute('data-theme')=='dark'&&u(),window.requestAnimationFrame(t)}()};dark()]]></content>
      
    </entry>
    
    
  
</search>
